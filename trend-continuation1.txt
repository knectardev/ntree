TREND-CONTINUATION SYSTEM (VWAP + BB Confluence Pullback)

A complete, clean, formalized version of what you’re already intuitively trading.

This system trades trend continuation, not mean-reversion.
You don’t buy dips just because they’re dips — you buy pullbacks into institutional support (VWAP) while the dominant trend is intact.

1️⃣ MARKET FILTER (Trend Direction)

You only consider LONGS when:

✔ Price is above VWAP
✔ AND VWAP has an upward slope

Definition:

VWAP > VWAP[20]


or any reasonable lookback.

✔ AND price is above the middle Bollinger band (20 SMA) for most of the last N bars

This eliminates chop and sideways regimes.

This is the “continuation only” filter.
No fadey counter-trend junk.
No guessing bottoms.

2️⃣ PULLBACK SETUP (High-Probability Re-entry)

A valid pullback occurs when all of these happen:

✔ Price touches the lower Bollinger Band (20,2)

→ indicates a two-standard-deviation pullback

✔ AND price touches (or comes within a small tolerance of) VWAP

→ institutional support test

✔ AND the pullback occurs inside an uptrend, not breaking structure

Example rule:

Higher low above previous swing low

✔ AND you get a bullish rejection candle

(hammer, long lower wick, bullish engulfing, bottom-wick > 50% candle height)

This candle becomes the signal candle.

This is your exact chart logic.

3️⃣ ENTRY TRIGGER (Continuation Confirmation)
✔ Enter long only if price breaks ABOVE the signal candle’s high

This guarantees bullish absorption and follow-through.

It also avoids:

premature entries,

deepening pullbacks,

chop inside the VWAP cloud.

4️⃣ STOP LOSS (Safe + Trend-Compatible)

Three variants; your chart seems closest to #1:

Option A — Below the signal candle low (safest)

Maintains structural integrity.

Option B — Below VWAP by a fixed buffer

Good when VWAP is tight and price respects it cleanly.

Option C — Below recent swing low

For trending markets with shallow pullbacks.

5️⃣ PROFIT TARGET (Trend-Continuation Version)

Since this is NOT mean-reversion, your target isn't the BB midline — it's the next trend leg.

You have three clear choices:

Target Model A — Structure Target (Most Natural)

Take profits at the next:

prior high

liquidity band

overhead consolidation zone

This is exactly where you drew the blue rectangles:
sell strength into likely short-seller stop pockets.

Target Model B — ATR / Multiple of Risk

Standard trend-following exit:

TP = Entry + (R * 2.0 to 3.0)


Because continuation often gives large runs.

Target Model C — Trail Above Middle BB or EMA 21

This is cleaner:

Exit only when candle CLOSES below middle BB (20 SMA) or EMA21

Allows trend legs to breathe

Works beautifully with VWAP-based pullbacks

6️⃣ FAILURE CONDITIONS (When NOT to Trade)
❌ Avoid trading when VWAP is flat

Trend continuation does not exist in horizontal VWAP regimes.

❌ Avoid buying lower BB touches that don’t reach VWAP

Those are often early fades, not real pullbacks.

❌ Avoid continuation trades after multiple lower highs

Trend exhaustion → avoid continuation entries late in cycle.

7️⃣ SUMMARY OF THE SYSTEM IN 5 LINES

Trend:

Price > VWAP

VWAP sloping up

Price mostly above BB midline

Pullback:

Price touches lower BB AND VWAP

Bullish rejection candle forms

Enter on break of signal candle high

Exit:

Trend-based target, not mean-reversion

Prefer liquidity zones or mid-BB trailing exits

Stop:

Below signal candle low or below VWAP buffer

Below is a self-contained function in the same style as your VWAP/EMA crossover example, but implementing the VWAP + lower Bollinger Band trend-continuation pullback we just defined.

You can tweak the parameters at the top (BB length, std, VWAP slope lookback, intersection tolerance, wick ratio) as you test.

"""
VWAP + Bollinger Band Trend-Continuation Pullback (v1)

Idea:
- Only look for LONG continuation trades in an established intraday uptrend.
- Uptrend defined by: price above VWAP and VWAP sloping up.
- Pullback defined by: VWAP ~ lower Bollinger Band (confluence) and price
  probing that area.
- Entry signal defined by: bullish rejection candle at the VWAP/BB area.

This is a *pattern recognizer*, not a full trade system. It marks bars where
this setup is present and returns useful context (prices, bands, slope flags).
"""

import pandas as pd
from strategies.utils import clean_series
from utils import calculate_vwap_per_trading_day

try:
    import pandas_ta as ta
except ImportError:
    ta = None


def compute_vwap_bb_trend_continuation_signals(
    df_prices,
    rth_mask=None,
    bb_length: int = 20,
    bb_std: float = 2.0,
    vwap_slope_lookback: int = 10,
    intersection_tolerance: float = 0.0015,  # ≈0.15% of price
    wick_ratio: float = 0.5,                 # lower wick ≥ 50% of candle range
):
    """
    Detects LONG trend-continuation pullbacks where:

    1) Context (uptrend filter)
       - close > vwap
       - vwap > vwap.shift(vwap_slope_lookback)  (upward slope)
       - close is generally trading above BB midline (20 SMA)

    2) Pullback / confluence
       - vwap is approximately equal to lower Bollinger Band (within
         `intersection_tolerance` relative distance) OR crosses it.
       - Price probes the VWAP/BB area (low <= max(vwap, bb_lower))

    3) Bullish rejection candle
       - Candle has a bullish close (close > open) OR small body.
       - Lower wick is at least `wick_ratio` of total range.

    Returns a JSON-serializable dict, with one element per bar:

    {
        'long_entry': [bool, ...],             # True where setup is present
        'direction': ['bullish'|None, ...],    # For future extensibility
        'entry_price': [...],                  # next-bar open
        'stop_price': [...],                   # suggested stop (signal low)
        'vwap': [...],
        'bb_middle': [...],
        'bb_upper': [...],
        'bb_lower': [...],
        'vwap_slope_up': [bool, ...],
        'has_rejection_wick': [bool, ...],
        'timestamp': ['iso8601', ...],
    }
    """
    if df_prices is None or df_prices.empty:
        return {}

    df = df_prices.copy()
    df.index = pd.to_datetime(df.index)
    idx = df.index

    # ------------------------------------------------------------------ #
    # Session mask
    # ------------------------------------------------------------------ #
    if rth_mask is not None:
        try:
            rth_mask = pd.Series(rth_mask, index=idx).astype(bool)
        except Exception:
            rth_mask = None

    if rth_mask is None or len(rth_mask) != len(df):
        rth_mask = pd.Series([True] * len(df), index=idx)

    # ------------------------------------------------------------------ #
    # VWAP
    # ------------------------------------------------------------------ #
    if 'vwap' not in df.columns:
        vwap_series = calculate_vwap_per_trading_day(
            df.rename(
                columns={
                    'open': 'open',
                    'high': 'high',
                    'low': 'low',
                    'close': 'close',
                    'volume': 'volume',
                }
            )
        )
        df['vwap'] = vwap_series

    vwap = df['vwap']

    # ------------------------------------------------------------------ #
    # Bollinger Bands (20, 2 by default)
    # ------------------------------------------------------------------ #
    close = df['close']

    if ta is not None:
        bb = ta.bbands(close, length=bb_length, std=bb_std)
        # pandas_ta names: e.g. 'BBL_20_2.0', 'BBM_20_2.0', 'BBU_20_2.0'
        bb_lower_col = [c for c in bb.columns if c.startswith('BBL_')][0]
        bb_middle_col = [c for c in bb.columns if c.startswith('BBM_')][0]
        bb_upper_col = [c for c in bb.columns if c.startswith('BBU_')][0]
        df['bb_lower'] = bb[bb_lower_col]
        df['bb_middle'] = bb[bb_middle_col]
        df['bb_upper'] = bb[bb_upper_col]
    else:
        mid = close.rolling(bb_length, min_periods=bb_length).mean()
        std = close.rolling(bb_length, min_periods=bb_length).std()
        df['bb_middle'] = mid
        df['bb_upper'] = mid + bb_std * std
        df['bb_lower'] = mid - bb_std * std

    bb_lower = df['bb_lower']
    bb_middle = df['bb_middle']
    bb_upper = df['bb_upper']

    # ------------------------------------------------------------------ #
    # Context: uptrend filter
    # ------------------------------------------------------------------ #
    vwap_slope_up = (vwap.notna()) & (vwap > vwap.shift(vwap_slope_lookback))
    price_above_vwap = close > vwap
    price_above_mid_bb = close > bb_middle

    uptrend_context = vwap_slope_up & price_above_vwap & price_above_mid_bb

    # ------------------------------------------------------------------ #
    # Pullback / confluence at VWAP + lower BB
    # ------------------------------------------------------------------ #
    # 1) VWAP ~ lower BB intersection (either near-equality or line cross)
    diff = vwap - bb_lower
    prev_diff = diff.shift(1)

    near_equal = (diff.abs() / vwap.abs().clip(lower=1e-9)) <= intersection_tolerance
    cross_band = (
        diff.notna()
        & prev_diff.notna()
        & (diff * prev_diff <= 0)
        & (diff != prev_diff)
    )
    vwap_bb_confluence = (near_equal | cross_band)

    # 2) Price probing the confluence area
    low = df['low']
    high = df['high']

    # Candle low reaches at or below VWAP/BB area
    price_probing = low <= (vwap.combine(bb_lower, func=lambda v, b: max(v, b)))

    pullback_zone = vwap_bb_confluence & price_probing

    # ------------------------------------------------------------------ #
    # Bullish rejection candle at the pullback
    # ------------------------------------------------------------------ #
    open_ = df['open']
    body = (close - open_).abs()
    rng = (high - low).replace(0, pd.NA)

    lower_wick = (open_.where(open_ < close, close) - low)
    lower_wick_ratio = lower_wick / rng

    bullish_close_or_small_body = (close > open_) | (body <= 0.2 * rng)
    has_rejection_wick = lower_wick_ratio >= wick_ratio

    rejection_candle = bullish_close_or_small_body & has_rejection_wick

    # ------------------------------------------------------------------ #
    # Final long-entry condition
    # ------------------------------------------------------------------ #
    long_entry = (
        uptrend_context
        & pullback_zone
        & rejection_candle
        & rth_mask.astype(bool)
        & vwap.notna()
        & bb_lower.notna()
    )

    # Entry on next bar open; stop under signal candle low
    entry_price = df['open'].shift(-1)
    stop_price = low  # you can later adjust to low - ATR or buffer

    return {
        'long_entry': [bool(x) if pd.notna(x) else False for x in long_entry],
        'direction': ['bullish' if le else None for le in long_entry],
        'entry_price': clean_series(entry_price),
        'stop_price': clean_series(stop_price),
        'vwap': clean_series(vwap),
        'bb_middle': clean_series(bb_middle),
        'bb_upper': clean_series(bb_upper),
        'bb_lower': clean_series(bb_lower),
        'vwap_slope_up': [bool(x) if pd.notna(x) else False for x in vwap_slope_up],
        'has_rejection_wick': [
            bool(x) if pd.notna(x) else False for x in has_rejection_wick
        ],
        'timestamp': [ts.isoformat() for ts in df.index],
    }
