Right now you have three separate “gaps” that prevent entry↔exit linking (and partials):

UI hover is bar-only, not marker hit-testing

Strategy markers are per-bar booleans, no stable ID to pair with anything

Backtest execution_events are exit-only (SL/TP only) and have no trade_id, and the renderer effectively assumes one marker per bar

So Cursor is right: pairing isn’t possible yet with the current event schema, and partials aren’t representable.

What I’d do next (minimal diff that unlocks hover pairing)
Option A (best “small diff”): extend execution_events

Have the backtest emit a richer stream of events that includes both entry and exit and a stable ID:

New/extended fields

trade_id (int)

event = "entry" | "exit" (or more specific: "stop_loss", "take_profit", "signal_exit", etc.)

exit_reason (for exits)

qty and/or qty_delta (optional now, required later for partials)

event_seq (optional; helps ordering if multiple events share same bar)

Why this is the smallest diff:
You already have a place to return execution_events; you just make it richer, and the UI can build trade_id -> { entry, exits[] }.

What changes in the UI (also small, but very high leverage)
1) Build a “pickables” buffer during render

When you draw each marker, also record its screen coords + trade_id.

Example record:

pickables.push({ kind: "entry", trade_id, x, y, r: 10 });
pickables.push({ kind: "exit", trade_id, x, y, r: 10 });

2) Extend hover logic to hit-test markers

On mousemove, you already update crosshair hover index. Add:

find nearest pickable within radius

set state.hoverTradeId = pickable.trade_id

re-render

3) Highlight counterpart(s) on draw

If hoverTradeId is set:

dim all other trade markers

brighten entry + all exits with same trade_id

optionally draw a faint connector entry→exit (only on hover)

This gives you the “connected to which exit?” clarity without clutter.

About partial exits (Cursor is also right)

Partials are not supported yet for two reasons:

Engine models 1 entry → 1 exit and does not track quantity per trade lifecycle (so no scale-outs).

Renderer assumes max one execution marker per bar, which breaks if you have multiple exit events on the same candle.

You can still implement Option A now in a way that is “partial-ready”:

include qty_delta on events even if it’s always full size at first

allow the renderer to store arrays per bar (or better: don’t index by bar at all—just render from events)

Then when you later add partials:

the UI path doesn’t change

only the engine begins emitting multiple exit events per trade_id

My recommendation for ntree (pragmatic)

Implement Option A now:

add trade_id

emit an "entry" event

emit an "exit" event with exit_reason

update UI for hit-testing + paired highlighting

Later, add partials by:

introducing qty / qty_delta in the engine

allowing multiple exits per trade_id

ensuring the renderer supports multiple markers per bar

This gets you hover pairing quickly, and you won’t have to redo it when you add scale-outs.