<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connected OCLH Chart (Static JSON)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --grid:#1b2838;
      --text:#d7e0ea;
      --muted:#8aa0b5;
      --sidebarW: 280px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    /* Full-width, responsive layout: left sidebar placeholder + right chart. */
    .layout{
      display:grid;
      grid-template-columns: var(--sidebarW) 1fr;
      /* Row 1: title. Row 2: size to the chart card so sidebar matches chart height. */
      grid-template-rows: auto auto;
      gap:18px;
      padding:18px;
      max-width: 1600px;
      margin: 0 auto;
      box-sizing:border-box;
      align-items: stretch;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; grid-template-rows: auto auto; }
    }
    .pageTop{ grid-column: 1 / -1; }
    .sidebar{
      align-self:stretch;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.07);
      background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      padding:12px;
      min-height: 0;
    }
    .sidebar h2{margin:0 0 8px 0;font-size:13px;font-weight:750;letter-spacing:.2px;color:rgba(215,224,234,.92)}
    .sidebar .hint{margin:0;font-size:12px;color:var(--muted);line-height:1.35}
    .sideCard{
      margin-top:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(8,12,18,.55);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
      padding:10px;
    }
    .sideCardTitle{
      margin:0 0 10px 0;
      font-size:12px;
      font-weight:750;
      letter-spacing:.2px;
      color:rgba(215,224,234,.92);
    }
    .sideList{display:flex;flex-direction:column;gap:10px}
    .chkRow{display:flex;gap:10px;align-items:flex-start}
    .chkRow input[type="checkbox"]{transform: translateY(2px)}
    .chkLbl{display:flex;flex-direction:column;gap:6px;min-width:0}
    .chkName{font-size:12px;color:rgba(215,224,234,.92);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .swatch{
      width:44px;height:3px;border-radius:999px;background:rgba(255,255,255,.25);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset;
    }
    .swatch.ema9{background:rgb(255, 80, 120)}
    .swatch.ema21{background:rgb(0, 162, 255)}
    .swatch.ema50{background:rgb(255, 200, 90)}
    .swatch.vwap{background:rgb(30, 200, 170)}
    .sideDivider{height:1px;background:rgba(255,255,255,.07);margin:10px 0}
    .formGroup{display:flex;flex-direction:column;gap:8px}
    .fieldLabel{font-size:12px;color:rgba(215,224,234,.92);font-weight:650}
    .select{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      color:rgba(215,224,234,.92);
      outline:none;
      font-size:12px;
    }
    .select:focus{border-color:rgba(90,150,255,.65)}
    .btnPrimary{
      cursor:pointer;
      width:100%;
      border-radius:10px;
      padding:10px 12px;
      border:1px solid rgba(90,150,255,.35);
      background:rgba(90,150,255,.18);
      color:rgba(235,245,255,.98);
      font-weight:750;
      font-size:12px;
    }
    .btnPrimary:hover{background:rgba(90,150,255,.24)}
    .main{min-width:0}
    .wrap{max-width:none;margin:0;padding:0}
    .top{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:10px}
    h1{font-size:18px;margin:0;font-weight:650;letter-spacing:.2px}
    .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.07);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
    .toolbar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid rgba(255,255,255,.07);background:rgba(15,22,32,.7);backdrop-filter: blur(10px)}
    .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:999px}
    .pill label{font-size:12px;color:var(--muted);user-select:none;white-space:nowrap}
    .pill input[type="range"]{width:160px}
    .pill input[type="checkbox"]{transform: translateY(1px)}
    .pill input[type="text"], .pill select{width:92px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.20);color:var(--text);outline:none}
    .pill input[type="text"]:focus, .pill select:focus{border-color:rgba(90,150,255,.65)}
    .pill select{appearance:none}
    /* Hide No-cross option in the toolbar UI (feature remains enabled by default). */
    .pill.pill--nocross{display:none}
    .btn{cursor:pointer;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);color:var(--text);border-radius:12px;padding:8px 10px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.09)}
    canvas{display:block;width:100%;height:560px}
    .footer{display:flex;justify-content:space-between;gap:10px;align-items:center;padding:10px 12px;border-top:1px solid rgba(255,255,255,.07);color:var(--muted);font-size:12px;min-height:40px}
    .k{color:var(--text)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

    /* Custom dropdown (replaces native <select> so colors are consistent in dark theme) */
    .dd{position:relative}
    .ddBtn{
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      color:var(--text);
      outline:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
    }
    .ddBtn:focus{border-color:rgba(90,150,255,.65)}
    .ddBtn:disabled{opacity:.55; cursor:not-allowed}
    .ddChevron{opacity:.8;font-size:10px;transform: translateY(-1px)}
    .ddMenu{
      position:absolute;
      top:calc(100% + 6px);
      left:0;
      min-width:84px;
      z-index:50;
      padding:6px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(8,12,18,.98);
      box-shadow:0 18px 50px rgba(0,0,0,.55);
      display:none;
    }
    .dd.open .ddMenu{display:block}
    .ddItem{
      cursor:pointer;
      user-select:none;
      padding:7px 10px;
      border-radius:10px;
      font-size:12px;
      color:rgba(215,224,234,.92);
      white-space:nowrap;
    }
    .ddItem:hover{background:rgba(255,255,255,.07)}
    .ddItem.sel{background:rgba(90,150,255,.18); color:rgba(235,245,255,.98)}

    /* Top-right status chip */
    .statusChip{
      position:fixed;
      top:12px;
      right:14px;
      z-index:1000;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(8,12,18,.78);
      backdrop-filter: blur(10px);
      box-shadow:0 12px 34px rgba(0,0,0,.45);
      font-size:12px;
      color:rgba(215,224,234,.92);
      user-select:none;
      pointer-events:none;
    }
    .statusDot{
      width:8px;
      height:8px;
      border-radius:50%;
      background:rgba(140,150,165,.8);
      box-shadow:0 0 0 2px rgba(255,255,255,.06) inset;
    }
    .statusDot.ok{ background:rgba(80,220,140,.9); }
    .statusDot.live{ background:rgba(90,150,255,.92); }
    .statusDot.warn{ background:rgba(255,200,90,.95); }
    .statusDot.err{ background:rgba(255,110,110,.92); }
    .statusMono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; }
  </style>
  <style>
    /* Static demo tweaks */
    /* When embedded/served by Flask as an API-backed band chart, we flip body->.api in JS. */
    body.api #pickStaticDir{display:none !important;}
    body.api #pickBarsFile{display:none !important;}
  </style>
</head>
<body>
  <div class="statusChip" id="updateChip" aria-live="polite">
    <span class="statusDot" id="updateDot"></span>
    <span id="updateText" class="statusMono">Last update: —</span>
  </div>
  <div class="layout">
    <div class="pageTop top">
      <h1>.</h1>
    </div>
    <aside class="sidebar" aria-label="Indicator controls">
      <h2>Indicators</h2>
      <p class="hint">Placeholder panel — indicator controls will live here.</p>

      <!-- Placeholders only (no logic wired yet) -->
      <div class="sideCard" aria-label="Indicator toggles">
        <div class="sideList">
          <label class="chkRow">
            <input type="checkbox" checked />
            <span class="chkLbl">
              <span class="chkName">EMA 9</span>
              <span class="swatch ema9" aria-hidden="true"></span>
            </span>
          </label>

          <label class="chkRow">
            <input type="checkbox" checked />
            <span class="chkLbl">
              <span class="chkName">EMA 21</span>
              <span class="swatch ema21" aria-hidden="true"></span>
            </span>
          </label>

          <label class="chkRow">
            <input type="checkbox" />
            <span class="chkLbl">
              <span class="chkName">EMA 50</span>
              <span class="swatch ema50" aria-hidden="true"></span>
            </span>
          </label>

          <label class="chkRow">
            <input type="checkbox" checked />
            <span class="chkLbl">
              <span class="chkName">VWAP</span>
              <span class="swatch vwap" aria-hidden="true"></span>
            </span>
          </label>
        </div>
      </div>

      <div class="sideCard" aria-label="Candlestick overlays">
        <label class="chkRow">
          <input type="checkbox" />
          <span class="chkLbl">
            <span class="chkName">Candlestick Bias Overlay</span>
          </span>
        </label>
      </div>

      <div class="sideCard" aria-label="Strategy controls">
        <div class="sideCardTitle">Strategy</div>
        <div class="formGroup">
          <label class="fieldLabel" for="strategySelect">Strategy</label>
          <select class="select" id="strategySelect" disabled>
            <option selected>None</option>
          </select>

          <label class="fieldLabel" for="btConfigSelect">Backtest config</label>
          <select class="select" id="btConfigSelect" disabled>
            <option selected>Default (risk 0.5%, RR 2.0, fee 0)</option>
          </select>

          <button class="btnPrimary" type="button" disabled>Run Backtest</button>
        </div>
      </div>
    </aside>
    <main class="main">
      <div class="wrap">
        <div class="card">
          <div class="toolbar">
            <div class="left">
              <div class="pill">
                <label>Ticker</label>
                <div class="dd" id="tickerDD">
                  <button class="ddBtn mono" id="tickerBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
                    <span id="tickerLabel" class="mono">ES</span>
                    <span class="ddChevron">▾</span>
                  </button>
                  <div class="ddMenu" id="tickerMenu" role="listbox" aria-label="Ticker"></div>
                </div>
              </div>

          <div class="pill">
            <label for="window">Bar size (W)</label>
            <input id="window" type="range" min="30" max="86400" value="60" step="30" />
            <span id="windowVal" class="k mono">60s</span>
          </div>

          <div class="pill"><label><input id="autoW" type="checkbox" checked /> Auto W</label></div>

          <div class="pill"><label><input id="showBands" type="checkbox" checked /> Bands</label></div>
          <div class="pill">
            <label><input id="showCandles" type="checkbox" /> Candles</label>
            <div class="dd" id="candleStyleDD">
              <button class="ddBtn" id="candleStyleBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
                <span id="candleStyleLabel">Standard</span>
                <span class="ddChevron">▾</span>
              </button>
              <div class="ddMenu" id="candleStyleMenu" role="listbox" aria-label="Candle style">
                <div class="ddItem" role="option" data-value="std">Standard</div>
                <div class="ddItem" role="option" data-value="ha">Heikin Ashi</div>
              </div>
            </div>
          </div>
          <div class="pill"><label><input id="showVolume" type="checkbox" checked /> Volume</label></div>
          <div class="pill"><label><input id="grid" type="checkbox" checked /> Grid</label></div>
          <div class="pill"><label><input id="scale" type="checkbox" checked /> Auto-scale Y</label></div>
          <div class="pill pill--nocross"><label><input id="nocross" type="checkbox" checked /> No-cross</label></div>
          <div class="pill"><label><input id="fills" type="checkbox" checked /> Fill bands</label></div>
          <div class="pill"><label><input id="smooth" type="checkbox" checked /> Smooth</label></div>
          <div class="pill"><label><input id="outer" type="checkbox" checked /> High/Low bands (or wicks)</label></div>
          <div class="pill"><label><input id="avgline" type="checkbox" checked /> Avg line</label></div>
        </div>
        <div class="right">
          <button class="btn" id="pickStaticDir" title="Pick a folder containing catalog.json and bars/*.json (works on file:// in Chromium browsers).">Pick snapshot folder</button>
          <button class="btn" id="pickBarsFile" title="Pick a single bars JSON file (works on file://).">Pick bars file</button>
          <button class="btn" id="regen">Load snapshot</button>
        </div>
          </div>

          <canvas id="c"></canvas>

      <div class="footer" aria-label="Footer (reserved for future controls)">
        <div></div>
        <div></div>
      </div>
        </div>
      </div>
    </main>
  </div>

  <script>
  'use strict';

  // helpers
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a, b, t){ return a + (b - a) * t; }

  function getQueryParam(key, fallback){
    var qs = window.location.search || '';
    var re = new RegExp('[?&]' + key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '=([^&]*)');
    var m = re.exec(qs);
    if(!m) return fallback;
    return decodeURIComponent(m[1].replace(/\+/g, ' '));
  }

  function regenButtonLabel(){
    // Single action button label.
    return STATIC_MODE ? 'Load snapshot' : 'Fetch Latest Data';
  }

  // Mode selection:
  // - static (default): load from ./static/*.json or file:// pickers
  // - api: fetch from same-origin (or ?api_base=...) /window endpoint
  var MODE = getQueryParam('mode', 'static');
  // Static-only mode: no server calls.
  var STATIC_MODE = (String(MODE || '').toLowerCase() !== 'api');
  // When in api mode, the chart calls: buildUrl(API_BASE, '/window', ...)
  // Use same-origin by default; override with ?api_base=http://127.0.0.1:5000 if needed.
  var API_BASE = getQueryParam('api_base', '');
  // Single-symbol convenience: when ?single=1&symbol=SPY, build a catalog from the symbol.
  var SINGLE_MODE = (getQueryParam('single', '') !== '');
  try{
    if(document && document.body){
      document.body.classList.remove('static','api');
      document.body.classList.add(STATIC_MODE ? 'static' : 'api');
    }
  } catch(_e){}

  function buildUrl(base, path, params){
    var b = String(base || '').replace(/\/+$/,'');
    var p = String(path || '');
    var q = [];
    for(var k in (params || {})){
      if(!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if(v === undefined || v === null || v === '') continue;
      q.push(encodeURIComponent(k) + '=' + encodeURIComponent(String(v)));
    }
    return b + p + (q.length ? ('?' + q.join('&')) : '');
  }

  // When served over http(s), we can fetch relative JSON files from here.
  var STATIC_BASE = getQueryParam('static_base', './static');
  // When opened via file://, use Directory Picker (Chromium) to read local files.
  // Folder selection modes:
  // - root: selected folder contains catalog.json and (optionally) bars/
  // - bars: selected folder is the bars/ folder itself
  var _staticDirMode = ''; // 'root' | 'bars' | ''
  var _staticRootDirHandle = null;
  var _staticBarsDirHandle = null;
  var _staticGeneratedCatalog = null; // { symbols:[{dataset,symbol}], _generated:true }
  var _staticBarsByKey = {}; // key: `${symbol}_${bar_s}` => barsPayload
  var _staticBaseBySymbol = {}; // symbol => smallest-bar_s barsPayload (best for aggregation)

  function joinPath(a, b){
    var aa = String(a || '').replace(/\/+$/,'');
    var bb = String(b || '').replace(/^\/+/,'');
    return aa + '/' + bb;
  }

  async function readTextFromDirHandle(dirHandle, relPath){
    if(!dirHandle) throw new Error('No directory handle selected');
    var parts = String(relPath || '').split('/').filter(function(x){ return !!x; });
    var cur = dirHandle;
    for(var i=0;i<parts.length;i++){
      var name = parts[i];
      var isLast = (i === parts.length - 1);
      if(isLast){
        var fh = await cur.getFileHandle(name);
        var f = await fh.getFile();
        return await f.text();
      }
      cur = await cur.getDirectoryHandle(name);
    }
    throw new Error('Invalid relPath: ' + relPath);
  }

  function inferDatasetFromSymbol(sym){
    var s = String(sym || '').trim().toUpperCase();
    if(!s) return '';
    // Prefer prefix before _CONT if present.
    var m0 = /^([A-Z0-9]+)_CONT$/.exec(s);
    if(m0 && m0[1]) return m0[1];
    // Otherwise take leading letters (ESZ5 -> ES, NQH6 -> NQ).
    var m1 = /^([A-Z]{1,6})/.exec(s);
    if(m1 && m1[1]) return m1[1];
    return '';
  }

  function barsKey(symbol, bar_s){
    var sym = String(symbol || '').trim();
    var bs = Math.floor(Number(bar_s) || 0);
    return sym + '_' + bs;
  }

  function rememberBarsPayload(j){
    try{
      if(!j || typeof j !== 'object') return;
      var sym = String(j.symbol || '').trim();
      var bs = Math.floor(Number(j.bar_s) || 0);
      if(!sym || !Number.isFinite(bs) || bs <= 0) return;
      var k = barsKey(sym, bs);
      _staticBarsByKey[k] = j;
      var cur = _staticBaseBySymbol[sym] || null;
      var curBs = cur ? Math.floor(Number(cur.bar_s) || 0) : 0;
      if(!cur || !Number.isFinite(curBs) || curBs <= 0 || bs < curBs){
        _staticBaseBySymbol[sym] = j;
      }
    } catch(_e){}
  }

  function aggregateBarsPayload(basePayload, targetBarS){
    // Aggregate OHLCV from a smaller bar size into a larger one.
    // We align buckets relative to the first timestamp to keep the chart stable.
    if(!basePayload || typeof basePayload !== 'object') throw new Error('No base payload to aggregate');
    var sym = String(basePayload.symbol || '').trim();
    var baseS = Math.floor(Number(basePayload.bar_s) || 0);
    var tgtS = Math.floor(Number(targetBarS) || 0);
    if(!sym) throw new Error('Base payload missing symbol');
    if(!Number.isFinite(baseS) || baseS <= 0) throw new Error('Base payload missing bar_s');
    if(!Number.isFinite(tgtS) || tgtS <= 0) throw new Error('Invalid target bar_s');
    if(tgtS < baseS) throw new Error('Cannot downsample below base bar_s (' + baseS + 's)');

    var t = basePayload.t_ms, o = basePayload.o, h = basePayload.h, l = basePayload.l, c = basePayload.c, v = basePayload.v;
    if(!Array.isArray(t) || !Array.isArray(o) || !Array.isArray(h) || !Array.isArray(l) || !Array.isArray(c) || !Array.isArray(v)){
      throw new Error('Base payload missing arrays t_ms,o,h,l,c,v');
    }
    var n = t.length;
    if(!n) throw new Error('Base payload has no data');
    if(o.length !== n || h.length !== n || l.length !== n || c.length !== n || v.length !== n){
      throw new Error('Base payload has mismatched array lengths');
    }
    var t0 = Number(t[0]);
    if(!Number.isFinite(t0)) throw new Error('Base payload t_ms[0] not finite');
    var bucketMs = tgtS * 1000;

    var outT = [];
    var outO = [];
    var outH = [];
    var outL = [];
    var outC = [];
    var outV = [];

    var curBucket = null;
    var bo = NaN, bh = -Infinity, bl = Infinity, bc = NaN, bv = 0;
    var bt = NaN;

    function flush(){
      if(curBucket === null) return;
      outT.push(bt);
      outO.push(bo);
      outH.push(bh);
      outL.push(bl);
      outC.push(bc);
      outV.push(bv);
    }

    for(var i=0;i<n;i++){
      var ti = Number(t[i]);
      if(!Number.isFinite(ti)) continue;
      var b = Math.floor((ti - t0) / bucketMs);
      if(curBucket === null){
        curBucket = b;
        bt = t0 + b * bucketMs;
        bo = Number(o[i]);
        bh = Number(h[i]);
        bl = Number(l[i]);
        bc = Number(c[i]);
        bv = Number(v[i]);
        continue;
      }
      if(b !== curBucket){
        flush();
        curBucket = b;
        bt = t0 + b * bucketMs;
        bo = Number(o[i]);
        bh = Number(h[i]);
        bl = Number(l[i]);
        bc = Number(c[i]);
        bv = Number(v[i]);
        continue;
      }
      // same bucket
      var hi = Number(h[i]); if(Number.isFinite(hi)) bh = Math.max(bh, hi);
      var li = Number(l[i]); if(Number.isFinite(li)) bl = Math.min(bl, li);
      bc = Number(c[i]);
      var vi = Number(v[i]); if(Number.isFinite(vi)) bv += vi;
    }
    flush();

    var out = {
      symbol: sym,
      bar_s: tgtS,
      dataset_start: basePayload.dataset_start || null,
      dataset_end: basePayload.dataset_end || null,
      start: basePayload.start || null,
      end: basePayload.end || null,
      t_ms: outT,
      o: outO,
      h: outH,
      l: outL,
      c: outC,
      v: outV,
      _derived_from_bar_s: baseS
    };
    // If start/end not present, derive from timestamps.
    try{
      if(outT.length){
        if(!out.start) out.start = new Date(outT[0]).toISOString().replace('.000Z','Z');
        if(!out.end) out.end = new Date(outT[outT.length-1]).toISOString().replace('.000Z','Z');
      }
    } catch(_e){}
    return out;
  }

  async function generateCatalogFromBarsDir(dirHandle){
    // Build a minimal catalog from filenames like <symbol>_<bar_s>.json.
    var symbols = [];
    var seen = {};
    try{
      for await (var entry of dirHandle.values()){
        try{
          if(!entry || entry.kind !== 'file') continue;
          var name = String(entry.name || '');
          var m = /^(.+)_([0-9]+)\.json$/i.exec(name);
          if(!m) continue;
          var sym = String(m[1] || '').trim();
          if(!sym) continue;
          if(seen[sym]) continue;
          seen[sym] = true;
          symbols.push({ dataset: inferDatasetFromSymbol(sym), symbol: sym });
        } catch(_e){}
      }
    } catch(_e){}
    // Ensure stable order.
    symbols.sort(function(a,b){ return String(a.symbol||'').localeCompare(String(b.symbol||'')); });
    return { symbols: symbols, _generated: true };
  }

  async function readJsonFromStatic(relPath){
    // Prefer dirHandle when present (file:// safe), else fetch from STATIC_BASE.
    var p = String(relPath || '').replace(/^\/+/,'');
    // In-memory override (file picker)
    if(/^bars\//.test(p)){
      var m = /^bars\/(.+)_([0-9]+)\.json$/.exec(p);
      if(m){
        var k = barsKey(m[1], m[2]);
        if(_staticBarsByKey && _staticBarsByKey[k]) return _staticBarsByKey[k];
      }
    }
    if(p === 'catalog.json' && _staticGeneratedCatalog) return _staticGeneratedCatalog;
    if(_staticDirMode === 'root' && _staticRootDirHandle){
      var txt0 = await readTextFromDirHandle(_staticRootDirHandle, p);
      return JSON.parse(txt0);
    }
    if(_staticDirMode === 'bars' && _staticBarsDirHandle){
      if(p === 'catalog.json'){
        // No catalog.json in bars-only mode; return generated.
        var gen = await generateCatalogFromBarsDir(_staticBarsDirHandle);
        _staticGeneratedCatalog = gen;
        return gen;
      }
      // Map bars/<file> to <file> in selected bars directory.
      var p2 = p;
      if(/^bars\//.test(p2)) p2 = p2.replace(/^bars\//,'');
      var txt1 = await readTextFromDirHandle(_staticBarsDirHandle, p2);
      return JSON.parse(txt1);
    }
    var url = joinPath(STATIC_BASE, p);
    var res = await fetch(url, { method:'GET', cache:'no-store' });
    if(!res.ok) throw new Error('HTTP ' + res.status + ' for ' + url);
    return await res.json();
  }

  async function loadStaticCatalog(){
    // Expected: { symbols: [{dataset,symbol}, ...] } or a plain array of {dataset,symbol}.
    var j = await readJsonFromStatic('catalog.json');
    var arr = [];
    if(Array.isArray(j)) arr = j;
    else if(j && Array.isArray(j.symbols)) arr = j.symbols;
    var out = [];
    for(var i=0;i<arr.length;i++){
      var item = arr[i];
      if(typeof item === 'string'){
        var sym = String(item || '').trim();
        if(!sym) continue;
        out.push({ symbol: sym, dataset: '', synthetic: false });
        continue;
      }
      if(item && typeof item === 'object' && typeof item.symbol === 'string'){
        out.push({
          symbol: String(item.symbol || '').trim(),
          dataset: String(item.dataset || '').trim(),
          synthetic: !!item.synthetic
        });
      }
    }
    return out;
  }

  async function loadStaticBars(symbol, bar_s){
    var sym = String(symbol || '').trim();
    var bs = Math.floor(Number(bar_s) || 60);
    if(!sym) throw new Error('Missing symbol');
    if(!Number.isFinite(bs) || bs <= 0) throw new Error('Invalid bar_s');
    var k = barsKey(sym, bs);
    if(_staticBarsByKey && _staticBarsByKey[k]) return _staticBarsByKey[k];
    var name = 'bars/' + sym + '_' + bs + '.json';
    var j = await readJsonFromStatic(name);
    rememberBarsPayload(j);
    return j;
  }

  // UI config persistence (static mode): localStorage instead of server.
  var UI_CFG_KEY = 'char_ui_config_v1';

  function coerceBool(v, fallback){
    if(v === true || v === false) return v;
    if(v === 1 || v === 0) return !!v;
    var s = (v === null || v === undefined) ? '' : String(v).toLowerCase();
    if(s === 'true' || s === '1') return true;
    if(s === 'false' || s === '0') return false;
    return !!fallback;
  }

  function coerceInt(v, fallback){
    var n = Number(v);
    if(!Number.isFinite(n)) return Number(fallback);
    return Math.floor(n);
  }

  var persist = {
    enabled: false,
    applying: false,
    hadConfig: false,
    saveTimer: null
  };

  async function fetchUiConfig(){
    try{
      var raw = localStorage.getItem(UI_CFG_KEY);
      if(!raw) return null;
      var j = JSON.parse(raw);
      if(!j || typeof j !== 'object') return null;
      return j;
    } catch(_e){
      return null;
    }
  }

  function getTicker(){
    var t = String(state.ticker || '').trim();
    if(t) return t;
    if(ui.tickerLabel){
      var tt = String(ui.tickerLabel.textContent || '').trim();
      if(tt) return tt;
    }
    return 'ES';
  }

  function getSymbol(){
    var s = String(state.symbol || '').trim();
    if(s) return s;
    if(ui.symbolLabel){
      var t = String(ui.symbolLabel.textContent || '').trim();
      if(t) return t;
    }
    return 'ESZ5';
  }

  function closeTickerMenu(){
    if(!ui.tickerDD) return;
    ui.tickerDD.classList.remove('open');
    if(ui.tickerBtn) ui.tickerBtn.setAttribute('aria-expanded','false');
  }

  function toggleTickerMenu(){
    if(!ui.tickerDD || !ui.tickerBtn) return;
    var open = ui.tickerDD.classList.toggle('open');
    ui.tickerBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }

  function setTicker(ticker){
    var v = String(ticker || '').trim().toUpperCase();
    if(!v) v = 'ES';
    state.ticker = v;
    if(ui.tickerLabel) ui.tickerLabel.textContent = v;
    if(ui.tickerMenu){
      var items = ui.tickerMenu.querySelectorAll('.ddItem');
      for(var i=0;i<items.length;i++){
        var it = items[i];
        var val = it.getAttribute('data-value');
        if(val === v) it.classList.add('sel');
        else it.classList.remove('sel');
      }
    }
  }

  function ensureTickerItem(ticker){
    if(!ui.tickerMenu) return;
    var v = String(ticker || '').trim().toUpperCase();
    if(!v) return;
    var items = ui.tickerMenu.querySelectorAll('.ddItem');
    for(var i=0;i<items.length;i++){
      if(items[i].getAttribute('data-value') === v) return;
    }
    var div = document.createElement('div');
    div.className = 'ddItem mono';
    div.setAttribute('role','option');
    div.setAttribute('data-value', v);
    div.textContent = v;
    ui.tickerMenu.appendChild(div);
  }

  function closeSymbolMenu(){
    if(!ui.symbolDD) return;
    ui.symbolDD.classList.remove('open');
    if(ui.symbolBtn) ui.symbolBtn.setAttribute('aria-expanded','false');
  }

  function toggleSymbolMenu(){
    if(!ui.symbolDD || !ui.symbolBtn) return;
    var open = ui.symbolDD.classList.toggle('open');
    ui.symbolBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }

  function setSymbol(sym){
    var v = String(sym || '').trim();
    if(!v) v = 'ESZ5';
    state.symbol = v;
    if(ui.symbolLabel) ui.symbolLabel.textContent = v;
    if(ui.symbolMenu){
      var items = ui.symbolMenu.querySelectorAll('.ddItem');
      for(var i=0;i<items.length;i++){
        var it = items[i];
        var val = it.getAttribute('data-value');
        if(val === v) it.classList.add('sel');
        else it.classList.remove('sel');
      }
    }
  }

  function symbolDisplayText(sym){
    var s = String(sym || '').trim();
    if(!s) return '';
    // Generic continuous labels: <ROOT>_CONT or <ROOT>1!
    if(/^[A-Z0-9]+_CONT$/.test(s)){
      var root = s.replace(/_CONT$/,'');
      return s + ' (Continuous ' + root + ' \u2013 calendar roll)';
    }
    if(/^[A-Z0-9]+1!$/.test(s)){
      var root2 = s.replace(/1!$/,'');
      return s + ' (Continuous ' + root2 + ' \u2013 calendar roll)';
    }
    // Legacy explicit labels (kept for a nicer first impression on ES).
    if(s === 'ESU5') return 'ESU5 (Sep 2025 \u2013 single contract)';
    if(s === 'ESZ5') return 'ESZ5 (Dec 2025 \u2013 single contract)';
    return s;
  }

  function ensureSymbolItem(sym){
    if(!ui.symbolMenu) return;
    var v = String(sym || '').trim();
    if(!v) return;
    var items = ui.symbolMenu.querySelectorAll('.ddItem');
    for(var i=0;i<items.length;i++){
      if(items[i].getAttribute('data-value') === v) return;
    }
    var div = document.createElement('div');
    div.className = 'ddItem mono';
    div.setAttribute('role','option');
    div.setAttribute('data-value', v);
    div.textContent = symbolDisplayText(v);
    ui.symbolMenu.appendChild(div);
  }

  async function fetchSymbolCatalog(){
    try{
      if(STATIC_MODE){
        return await loadStaticCatalog();
      }
      // API mode: if we're in single mode, synthesize a 1-item catalog.
      var symQ = String(getQueryParam('symbol', '') || '').trim();
      if(SINGLE_MODE && symQ){
        return [{ symbol: symQ, dataset: (inferDatasetFromSymbol(symQ) || symQ), synthetic: false }];
      }
      // Optional: if you later add an endpoint that returns catalog items, this will use it.
      // Expected: [{dataset,symbol}, ...] or {symbols:[...]}
      try{
        var url = buildUrl(API_BASE, '/api/symbols', {});
        var res = await fetch(url, { method:'GET', cache:'no-store' });
        if(res && res.ok){
          var j = await res.json();
          if(Array.isArray(j)) return j;
          if(j && Array.isArray(j.symbols)) return j.symbols;
        }
      } catch(_e2){}
      if(symQ) return [{ symbol: symQ, dataset: (inferDatasetFromSymbol(symQ) || symQ), synthetic: false }];
      return [];
    } catch(_e){
      return [];
    }
  }

  async function fetchMetaForSymbol(symbol){
    try{
      // In static mode, dataset bounds come from the bars file payload.
      return null;
    } catch(_e){
      return null;
    }
  }

  function buildCatalogIndex(items){
    // Returns { datasets:[], byDataset:{DS:[symbols...]}, datasetBySymbol:{sym:DS} }
    var byDataset = {};
    var datasetBySymbol = {};
    for(var i=0;i<items.length;i++){
      var it = items[i];
      if(!it) continue;
      var sym = String(it.symbol || '').trim();
      if(!sym) continue;
      var ds = String(it.dataset || '').trim().toUpperCase();
      // Fallback: infer ES by known synthetic/contract patterns if dataset missing.
      if(!ds){
        if(sym === 'ES_CONT' || sym === 'ES1!' || /^ES[A-Z]\\d$/.test(sym)) ds = 'ES';
      }
      if(!ds) continue;
      if(!byDataset[ds]) byDataset[ds] = [];
      byDataset[ds].push(sym);
      datasetBySymbol[sym] = ds;
    }
    var datasets = Object.keys(byDataset).sort();
    for(var k=0;k<datasets.length;k++){
      var d = datasets[k];
      // Unique + stable order.
      var seen = {};
      var dedup = [];
      var arr = byDataset[d] || [];
      for(var j=0;j<arr.length;j++){
        var s2 = String(arr[j] || '').trim();
        if(!s2 || seen[s2]) continue;
        seen[s2] = true;
        dedup.push(s2);
      }
      // Prefer ES_CONT at top for ES.
      if(d === 'ES'){
        dedup.sort();
        if(dedup.indexOf('ES_CONT') >= 0){
          dedup = ['ES_CONT'].concat(dedup.filter(function(x){ return x !== 'ES_CONT'; }));
        }
      } else {
        dedup.sort();
      }
      byDataset[d] = dedup;
    }
    return { datasets: datasets, byDataset: byDataset, datasetBySymbol: datasetBySymbol };
  }

  function refreshSymbolMenuForTicker(){
    if(!ui.symbolMenu) return;
    var ds = String(getTicker() || 'ES').trim().toUpperCase();
    var catalog = state._catalog || null;
    var syms = (catalog && catalog.byDataset && catalog.byDataset[ds]) ? catalog.byDataset[ds] : [];
    ui.symbolMenu.innerHTML = '';
    for(var i=0;i<syms.length;i++) ensureSymbolItem(syms[i]);
  }

  function chooseDefaultSymbolForTicker(ds){
    var d = String(ds || '').trim().toUpperCase();
    var catalog = state._catalog || null;
    var syms = (catalog && catalog.byDataset && catalog.byDataset[d]) ? catalog.byDataset[d] : [];
    if(!syms || !syms.length) return (d === 'ES' ? 'ES_CONT' : '');
    if(d === 'ES' && syms.indexOf('ES_CONT') >= 0) return 'ES_CONT';
    return String(syms[0] || '').trim();
  }

  function applyUiConfig(cfg){
    if(!cfg || typeof cfg !== 'object') return false;
    persist.applying = true;
    try{
      if(typeof cfg.ticker === 'string' && cfg.ticker.trim()){
        ensureTickerItem(cfg.ticker.trim());
        setTicker(cfg.ticker.trim());
        refreshSymbolMenuForTicker();
      }
      if(typeof cfg.symbol === 'string' && cfg.symbol.trim()){
        ensureSymbolItem(cfg.symbol.trim());
        setSymbol(cfg.symbol.trim());
      }

      if(ui.autoW && cfg.auto_w !== undefined) ui.autoW.checked = coerceBool(cfg.auto_w, ui.autoW.checked);
      if(ui.showBands && cfg.showBands !== undefined) ui.showBands.checked = coerceBool(cfg.showBands, ui.showBands.checked);
      if(ui.showCandles && cfg.showCandles !== undefined) ui.showCandles.checked = coerceBool(cfg.showCandles, ui.showCandles.checked);
      if(ui.showVolume && cfg.showVolume !== undefined) ui.showVolume.checked = coerceBool(cfg.showVolume, ui.showVolume.checked);
      if(ui.grid && cfg.grid !== undefined) ui.grid.checked = coerceBool(cfg.grid, ui.grid.checked);
      if(ui.scale && cfg.scale !== undefined) ui.scale.checked = coerceBool(cfg.scale, ui.scale.checked);
      if(ui.nocross && cfg.nocross !== undefined) ui.nocross.checked = coerceBool(cfg.nocross, ui.nocross.checked);
      if(ui.fills && cfg.fills !== undefined) ui.fills.checked = coerceBool(cfg.fills, ui.fills.checked);
      if(ui.smooth && cfg.smooth !== undefined) ui.smooth.checked = coerceBool(cfg.smooth, ui.smooth.checked);
      if(ui.outer && cfg.outer !== undefined) ui.outer.checked = coerceBool(cfg.outer, ui.outer.checked);
      if(ui.avgline && cfg.avgline !== undefined) ui.avgline.checked = coerceBool(cfg.avgline, ui.avgline.checked);

      if(cfg.bar_s !== undefined){
        var ww = clamp(coerceInt(cfg.bar_s, 60), 30, 86400);
        ww = snapToPreset(ww);
        state.windowSec = ww;
        if(ui.window) ui.window.value = String(ww);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(ww);
      }

      if(typeof cfg.candleStyle === 'string' && cfg.candleStyle){
        setCandleStyle(cfg.candleStyle);
      }

      syncCandleStyleEnabled();
      return true;
    } catch(_e){
      return false;
    } finally {
      persist.applying = false;
    }
  }

  function collectUiConfig(){
    return {
      version: 1,
      // saved_at is set server-side too, but keeping it here is handy for debugging.
      saved_at: new Date().toISOString().replace('.000Z','Z'),
      ticker: getTicker(),
      symbol: getSymbol(),
      bar_s: Math.floor(Number(state.windowSec) || 60),
      auto_w: !!(ui.autoW && ui.autoW.checked),
      showBands: !!(ui.showBands && ui.showBands.checked),
      showCandles: !!(ui.showCandles && ui.showCandles.checked),
      candleStyle: String(state.candleStyle || 'std'),
      showVolume: !!(ui.showVolume && ui.showVolume.checked),
      grid: !!(ui.grid && ui.grid.checked),
      scale: !!(ui.scale && ui.scale.checked),
      nocross: !!(ui.nocross && ui.nocross.checked),
      fills: !!(ui.fills && ui.fills.checked),
      smooth: !!(ui.smooth && ui.smooth.checked),
      outer: !!(ui.outer && ui.outer.checked),
      avgline: !!(ui.avgline && ui.avgline.checked)
    };
  }

  function scheduleSaveUiConfig(){
    if(!persist.enabled || persist.applying) return;
    if(persist.saveTimer) clearTimeout(persist.saveTimer);
    persist.saveTimer = setTimeout(function(){
      try{
        localStorage.setItem(UI_CFG_KEY, JSON.stringify(collectUiConfig()));
      } catch(_e){}
    }, 250);
  }

  // Robust rounded-rect path: never passes a negative radius to arcTo.
  function roundRect(ctx, x, y, w, h, r){
    if(!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return;
    if(w < 0){ x += w; w = -w; }
    if(h < 0){ y += h; h = -h; }
    if(w <= 0 || h <= 0) return;
    var rr = Math.max(0, Math.min(Number.isFinite(r) ? r : 0, w/2, h/2));
    ctx.beginPath();
    if(rr === 0){ ctx.rect(x, y, w, h); return; }
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // Stroke a polyline with gap support. smooth=true uses quadratic smoothing via midpoints.
  function strokePolyline(ctx, pts, style, width, smooth, dash){
    if(!pts || pts.length < 2) return;
    ctx.save();
    ctx.strokeStyle = style;
    ctx.lineWidth = width;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    if(Array.isArray(dash)) ctx.setLineDash(dash);

    var seg = [];

    function strokeSeg(segPts){
      if(segPts.length < 2) return;
      ctx.beginPath();
      if(!smooth || segPts.length < 3){
        ctx.moveTo(segPts[0][0], segPts[0][1]);
        for(var i=1;i<segPts.length;i++) ctx.lineTo(segPts[i][0], segPts[i][1]);
        ctx.stroke();
        return;
      }
      ctx.moveTo(segPts[0][0], segPts[0][1]);
      for(var j=1;j<segPts.length-1;j++){
        var p1 = segPts[j];
        var p2 = segPts[j+1];
        var mx = (p1[0] + p2[0]) / 2;
        var my = (p1[1] + p2[1]) / 2;
        ctx.quadraticCurveTo(p1[0], p1[1], mx, my);
      }
      var pn1 = segPts[segPts.length-2];
      var pn = segPts[segPts.length-1];
      ctx.quadraticCurveTo(pn1[0], pn1[1], pn[0], pn[1]);
      ctx.stroke();
    }

    for(var k=0;k<pts.length;k++){
      var p = pts[k];
      var px = p[0];
      var py = p[1];
      if(!Number.isFinite(px) || !Number.isFinite(py)){
        strokeSeg(seg);
        seg = [];
        continue;
      }
      seg.push([px,py]);
    }
    strokeSeg(seg);

    ctx.restore();
  }

  // Fill between two polylines with gap support.
  function fillBetween(ctx, upperPts, lowerPts, fillStyle, smooth){
    var n = Math.min(upperPts.length, lowerPts.length);
    if(n < 2) return;

    ctx.save();
    ctx.fillStyle = fillStyle;

    var segUpper = [];
    var segLower = [];

    function appendSmoothLineTo(pts){
      for(var i=1;i<pts.length-1;i++){
        var p1 = pts[i];
        var p2 = pts[i+1];
        var mx = (p1[0] + p2[0]) / 2;
        var my = (p1[1] + p2[1]) / 2;
        ctx.quadraticCurveTo(p1[0], p1[1], mx, my);
      }
      var pn1 = pts[pts.length-2];
      var pn = pts[pts.length-1];
      ctx.quadraticCurveTo(pn1[0], pn1[1], pn[0], pn[1]);
    }

    function flush(){
      if(segUpper.length < 2 || segLower.length < 2){ segUpper = []; segLower = []; return; }
      ctx.beginPath();
      ctx.moveTo(segUpper[0][0], segUpper[0][1]);
      if(!smooth || segUpper.length < 3){
        for(var i=1;i<segUpper.length;i++) ctx.lineTo(segUpper[i][0], segUpper[i][1]);
      } else {
        appendSmoothLineTo(segUpper);
      }
      var rev = segLower.slice().reverse();
      ctx.lineTo(rev[0][0], rev[0][1]);
      if(!smooth || rev.length < 3){
        for(var j=1;j<rev.length;j++) ctx.lineTo(rev[j][0], rev[j][1]);
      } else {
        appendSmoothLineTo(rev);
      }
      ctx.closePath();
      ctx.fill();
      segUpper = []; segLower = [];
    }

    for(var k=0;k<n;k++){
      var ux = upperPts[k][0], uy = upperPts[k][1];
      var lx = lowerPts[k][0], ly = lowerPts[k][1];
      var ok = Number.isFinite(ux) && Number.isFinite(uy) && Number.isFinite(lx) && Number.isFinite(ly);
      if(!ok){ flush(); continue; }
      segUpper.push([ux,uy]);
      segLower.push([lx,ly]);
    }
    flush();

    ctx.restore();
  }

  function orderSig(d){
    var arr = [
      ['l', d.l],
      ['o', d.o],
      ['c', d.c],
      ['h', d.h]
    ].sort(function(a,b){ return a[1]-b[1]; });
    return arr.map(function(x){ return x[0]; }).join('');
  }

  function formatWindow(sec){
    if(sec >= 3600 && sec % 3600 === 0) return (sec/3600) + 'h';
    if(sec >= 3600){
      var hh = Math.floor(sec/3600);
      var rem = sec % 3600;
      if(rem % 60 === 0) return hh + 'h' + (rem/60) + 'm';
      var mm = Math.floor(rem/60);
      var ss = rem % 60;
      return hh + 'h' + mm + 'm' + ss + 's';
    }
    if(sec < 60) return sec + 's';
    if(sec % 60 === 0) return (sec/60) + 'm';
    var m = Math.floor(sec/60);
    var s = sec % 60;
    return m + 'm' + s + 's';
  }

  // Display contract:
  // - static mode: can support 30s (if your dataset provides it)
  // - api mode (SQLite 1m canonical): minimum resolution is 60s (see bandchart.md note)
  // Keep this list ordered ascending.
  var SNAP_PRESETS = [
    // Canonical TFs only (client-side contract).
    // NOTE: UI and backend aggregation plans assume exactly this set.
    30, 60, 300, 1800, 3600, 14400, 86400
  ];

  // If we're in API mode backed by a 1-minute store, remove 30s to keep the UI honest.
  if(!STATIC_MODE){
    SNAP_PRESETS = [60, 300, 1800, 3600, 14400, 86400];
  }

  // Auto W targets roughly this many candles on screen.
  // Clamp is applied at call-sites to keep behavior stable if this value changes.
  var AUTO_W_TARGET_BARS = 400; // target ~300–500 candles visible

  // Default initial window when URL doesn't specify start/end and full history isn't requested.
  // This avoids "full-history bootstrap" which forces coarse bars + slow loads.
  var DEFAULT_INIT_SPAN_MS = 24 * 60 * 60 * 1000; // 24h (increase to 7d if you prefer)

  function parseIsoToMs(s){
    // Accept ISO strings with Z or offsets. If timezone-less, interpret as UTC.
    var str = String(s || '').trim();
    if(!str) return NaN;
    var ms = Date.parse(str);
    if(Number.isFinite(ms)) return ms;
    // If missing timezone, Date.parse can be inconsistent across environments; treat as UTC.
    if(!/[zZ]|[+\-]\d\d:\d\d$/.test(str)) ms = Date.parse(str + 'Z');
    return ms;
  }

  function snapToPreset(sec){
    var best = SNAP_PRESETS[0];
    var bestD = Math.abs(sec - best);
    for(var i=0;i<SNAP_PRESETS.length;i++){
      var p = SNAP_PRESETS[i];
      var d = Math.abs(sec - p);
      if(d < bestD){ bestD = d; best = p; }
    }
    return best;
  }

  function snapCeilToPreset(sec){
    var s = Math.max(30, Math.floor(Number(sec) || 30));
    for(var i=0;i<SNAP_PRESETS.length;i++){
      if(SNAP_PRESETS[i] >= s) return SNAP_PRESETS[i];
    }
    return SNAP_PRESETS[SNAP_PRESETS.length-1];
  }

  function recommendBarSec(spanMs, limit, targetBars){
    var span = Number(spanMs);
    if(!Number.isFinite(span) || span <= 0) return 60;
    var spanSec = Math.max(1, Math.floor(span / 1000));
    var tgt = Math.max(50, Math.floor(Number(targetBars) || 800));
    var lim = Math.floor(Number(limit) || 0);
    var minForLimit = (lim > 0) ? Math.max(1, Math.ceil(spanSec / lim)) : 1;
    var raw = Math.max(1, Math.floor(spanSec / tgt), minForLimit);
    return clamp(snapCeilToPreset(raw), 30, 86400);
  }

  function getVisibleSpanMs(requestSpanMs){
    // Visible time span is driven by zoom: visibleSpan = requestSpan / xZoom.
    var span = Number(requestSpanMs);
    if(!Number.isFinite(span) || span <= 0) return NaN;
    var z = Number(state.xZoom);
    if(!Number.isFinite(z) || z <= 0) z = 1;
    return span / z;
  }

  function recommendBarSecForVisibleSpan(visibleSpanMs, effMaxBars){
    var target = clamp(Math.floor(Number(AUTO_W_TARGET_BARS) || 400), 150, 800);
    return recommendBarSec(visibleSpanMs, effMaxBars, target);
  }

  // chart state
  var canvas = document.getElementById('c');
  var ctx = canvas.getContext('2d');

  var ui = {
    tickerDD: document.getElementById('tickerDD'),
    tickerBtn: document.getElementById('tickerBtn'),
    tickerMenu: document.getElementById('tickerMenu'),
    tickerLabel: document.getElementById('tickerLabel'),
    window: document.getElementById('window'),
    autoW: document.getElementById('autoW'),
    grid: document.getElementById('grid'),
    scale: document.getElementById('scale'),
    nocross: document.getElementById('nocross'),
    fills: document.getElementById('fills'),
    smooth: document.getElementById('smooth'),
    outer: document.getElementById('outer'),
    avgline: document.getElementById('avgline'),
    showBands: document.getElementById('showBands'),
    showCandles: document.getElementById('showCandles'),
    showVolume: document.getElementById('showVolume'),
    candleStyleDD: document.getElementById('candleStyleDD'),
    candleStyleBtn: document.getElementById('candleStyleBtn'),
    candleStyleMenu: document.getElementById('candleStyleMenu'),
    candleStyleLabel: document.getElementById('candleStyleLabel'),
    windowVal: document.getElementById('windowVal'),
    regen: document.getElementById('regen')
  };

    var state = {
    data: [],
    ha: [],
    candleStyle: 'std', // 'std' | 'ha'
    xOffset: 0,
    xZoom: 1,
    dragging: false,
    dragX0: 0,
    dragY0: 0,
    xOffset0: 0,
    yPan: 0,      // price-space vertical pan offset (added to yMin/yMax)
    yPan0: 0,
    lastDragDx: 0,
    yDragging: false,
    yScale0: 1,
    yScaleFactor: 1,
    hoverIdx: -1,
    hoverX: NaN,
    hoverY: NaN,
    symbol: 'ESZ5',
    windowSec: 60,
    // Navigation anchor: requested window span (not the full dataset span).
    viewSpanMs: NaN,
    viewEndMs: NaN,
    followLatest: true,
    datasetStartMs: NaN,
    datasetEndMs: NaN,
    _bootstrappedInitialWindow: false,
    _lastYSpan: NaN,
    _lastPlotH: NaN,
    _loadedBarS: NaN
  };

  // Live mode is disabled in this app integration (use "Fetch Latest Data" instead).
  var LIVE_POLL_MS = 10_000;
  var livePollTimer = null;
  var liveStatusTimer = null;
  state._liveStatus = null; // { enabled, connected, last_ts_event: {sym: iso}, ... }
  state._liveStatusAtMs = NaN;
  state._lastFullSyncAtMs = NaN;

  function closeCandleStyleMenu(){
    if(!ui.candleStyleDD) return;
    ui.candleStyleDD.classList.remove('open');
    if(ui.candleStyleBtn) ui.candleStyleBtn.setAttribute('aria-expanded','false');
  }

  function toggleCandleStyleMenu(){
    if(!ui.candleStyleDD || !ui.candleStyleBtn || ui.candleStyleBtn.disabled) return;
    var open = ui.candleStyleDD.classList.toggle('open');
    ui.candleStyleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }

  function setCandleStyle(v){
    var key = String(v || 'std');
    if(key !== 'std' && key !== 'ha') key = 'std';
    state.candleStyle = key;
    if(ui.candleStyleLabel) ui.candleStyleLabel.textContent = (key === 'ha') ? 'Heikin Ashi' : 'Standard';
    if(ui.candleStyleMenu){
      var items = ui.candleStyleMenu.querySelectorAll('.ddItem');
      for(var i=0;i<items.length;i++){
        var it = items[i];
        var val = it.getAttribute('data-value');
        if(val === key) it.classList.add('sel');
        else it.classList.remove('sel');
      }
    }
  }

  function syncCandleStyleEnabled(){
    var enabled = !!(ui.showCandles && ui.showCandles.checked);
    if(ui.candleStyleBtn) ui.candleStyleBtn.disabled = !enabled;
    if(!enabled) closeCandleStyleMenu();
  }

  function msToIsoZ(ms){
    // API accepts Z or offsets; keep URLs compact using ISO Z.
    return new Date(ms).toISOString().replace('.000Z','Z');
  }

  function resize(){
    var dpr = Math.max(1, window.devicePixelRatio || 1);
    var r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }

  function computeYBounds(){
    // Auto-scale Y should reflect the currently visible X window, so the price action
    // uses as much vertical space as possible in the current view.
    //
    // This is also what the Y-axis double-click ("auto-fit") expects: reset to a
    // tight-but-not-clipped range for the visible bars.
    if(!state.data.length) return {min:0,max:1};

    var n = state.data.length;
    var xZoom = Number(state.xZoom);
    if(!Number.isFinite(xZoom) || xZoom <= 0) xZoom = 1;

    var barsVisible = Math.min(n, Math.max(8, Math.floor(n / xZoom)));

    // Keep behavior consistent with draw(): if xOffset is unset/0 on first load,
    // right-align the view.
    var xOffset = Number(state.xOffset);
    if(!Number.isFinite(xOffset) || xOffset === 0){
      xOffset = Math.max(0, n - barsVisible);
    }
    xOffset = clamp(xOffset, 0, Math.max(0, n - barsVisible));

    var start = Math.floor(xOffset);
    var end = Math.min(n - 1, start + barsVisible + 1);

    // If candles are shown and Heikin Ashi is active, fit to HA highs/lows to match
    // the displayed candles; otherwise fit to raw highs/lows.
    var useHa = false;
    if(ui && ui.showCandles && ui.showCandles.checked && state.candleStyle === 'ha'){
      if(Array.isArray(state.ha) && state.ha.length === state.data.length) useHa = true;
    }
    var arr = useHa ? state.ha : state.data;

    var min = Infinity, max = -Infinity;
    for(var i=start; i<=end; i++){
      var d = arr[i];
      if(!d) continue;
      var lo = Number(d.l);
      var hi = Number(d.h);
      if(!Number.isFinite(lo) || !Number.isFinite(hi)) continue;
      if(lo < min) min = lo;
      if(hi > max) max = hi;
    }

    if(!Number.isFinite(min) || !Number.isFinite(max) || max <= min){
      // Fallback to something sane (should be rare).
      min = 0; max = 1;
    }

    // Small padding to prevent wick/body clipping while keeping the chart "maxed" vertically.
    var span = (max - min);
    var pad = span * 0.02;
    if(!Number.isFinite(pad) || pad <= 0) pad = 1;
    return { min: min - pad, max: max + pad };
  }
    
  function yAxisAutoFit(){
    state.yScaleFactor = 1;
    state.yPan = 0;
    ui.scale.checked = true;
    draw();
  }

  function drawGrid(plot){
    var x = plot.x, y = plot.y, w = plot.w, h = plot.h;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;

    var rows = 6;
    for(var i=0;i<=rows;i++){
      var yy = y + (h/rows)*i;
      ctx.beginPath();
      ctx.moveTo(x, yy);
      ctx.lineTo(x+w, yy);
      ctx.stroke();
    }

    var cols = 10;
    for(var j=0;j<=cols;j++){
      var xx = x + (w/cols)*j;
      ctx.beginPath();
      ctx.moveTo(xx, y);
      ctx.lineTo(xx, y+h);
      ctx.stroke();
    }

    ctx.restore();
  }

  function xForIndex(i, plot, barsVisible){
    var t = (i - state.xOffset) / barsVisible;
    return plot.x + t * plot.w;
  }

  function yForPrice(p, plot, yMin, yMax){
    var t = (p - yMin) / (yMax - yMin);
    return plot.y + plot.h * (1 - t);
  }

  function chooseTimeStepMs(spanMs, plotW, minPxPerTick){
    // Pick a tick step so labels don't overlap.
    // NOTE: This is intentionally "pixel-aware": we estimate how many ticks we can fit
    // based on the plot width, then choose the nearest step >= target.
    var span = Number(spanMs);
    if(!Number.isFinite(span) || span <= 0) return 60 * 1000;
    var plotWidth = Number(plotW);
    var minPx = Number(minPxPerTick);
    if(!Number.isFinite(plotWidth) || plotWidth <= 0) plotWidth = 900;
    if(!Number.isFinite(minPx) || minPx <= 10) minPx = 140;

    var maxTicks = Math.max(2, Math.floor(plotWidth / minPx));
    var target = Math.max(1, Math.floor(span / maxTicks)); // ms per tick

    var steps = [
      1000, 2000, 5000, 10_000, 15_000, 30_000,
      60_000, 2*60_000, 5*60_000, 10*60_000, 15*60_000, 30*60_000,
      60*60_000, 2*60*60_000, 4*60*60_000, 6*60*60_000, 12*60*60_000,
      24*60*60_000, 2*24*60*60_000, 7*24*60*60_000, 14*24*60*60_000, 30*24*60*60_000
    ];
    for(var i=0;i<steps.length;i++){
      if(steps[i] >= target) return steps[i];
    }
    return steps[steps.length-1];
  }

  // Display timezone: NYSE / Eastern Time (handles EST/EDT automatically).
  var DISPLAY_TZ = 'America/New_York';

  function fmtEt(ms, opts){
    try{
      var d = new Date(ms);
      if(!Number.isFinite(d.getTime())) return '';
      return new Intl.DateTimeFormat('en-US', Object.assign({
        timeZone: DISPLAY_TZ
      }, (opts || {}))).format(d);
    } catch(_e){
      // Fallback: local time
      var dd = new Date(ms);
      return (Number.isFinite(dd.getTime()) ? dd.toLocaleString() : '');
    }
  }

  function formatTimeLabelUtc(ms, stepMs){
    // (Name kept for minimal diff) Render in ET, 12-hour time.
    if(stepMs < 60_000) return fmtEt(ms, { hour:'numeric', minute:'2-digit', second:'2-digit', hour12:true });
    if(stepMs < 24*60*60_000) return fmtEt(ms, { hour:'numeric', minute:'2-digit', hour12:true });
    return fmtEt(ms, { year:'numeric', month:'2-digit', day:'2-digit' });
  }

  function formatDayLabelPartsUtc(ms, prevMs){
    // (Name kept for minimal diff) Returns {top,bottom} in ET: top=month at transitions, bottom=day number.
    var day = fmtEt(ms, { day:'numeric' });
    var top = '';
    var mon = fmtEt(ms, { month:'short' });
    var ym = fmtEt(ms, { year:'numeric', month:'2-digit' });
    var prevYm = (prevMs === null || prevMs === undefined) ? '' : fmtEt(prevMs, { year:'numeric', month:'2-digit' });
    if(!prevYm || prevYm !== ym) top = mon;
    // also show month on the 1st
    var dayNum = parseInt(String(day), 10);
    if(dayNum === 1) top = mon;
    return { top: top, bottom: String(day) };
  }

  function formatTooltipTimeUtc(ms){
    // (Name kept for minimal diff) Tooltip/crosshair time in ET, non-military, with TZ abbreviation.
    return fmtEt(ms, { year:'numeric', month:'2-digit', day:'2-digit', hour:'numeric', minute:'2-digit', hour12:true, timeZoneName:'short' });
  }

  function formatAxisTimeUtc(ms, stepMs){
    // (Name kept for minimal diff) Compact axis label in ET.
    if(Number(stepMs) >= 24*60*60_000) return fmtEt(ms, { month:'short', day:'numeric' });
    return fmtEt(ms, { hour:'numeric', minute:'2-digit', hour12:true });
  }

  function formatVolume(v){
    var x = Number(v);
    if(!Number.isFinite(x)) return '';
    var ax = Math.abs(x);
    if(ax >= 1e9) return (x/1e9).toFixed(2).replace(/\.00$/,'') + 'B';
    if(ax >= 1e6) return (x/1e6).toFixed(2).replace(/\.00$/,'') + 'M';
    if(ax >= 1e3) return (x/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
    return String(Math.round(x));
  }

  function computeHeikinAshi(bars){
    // Returns an array of {o,h,l,c} (same length as bars).
    // HA is sequential:
    // haClose = (o + h + l + c)/4
    // haOpen  = (prevHaOpen + prevHaClose)/2, seed: (o0 + c0)/2
    // haHigh  = max(h, haOpen, haClose)
    // haLow   = min(l, haOpen, haClose)
    if(!Array.isArray(bars) || !bars.length) return [];
    var out = new Array(bars.length);
    var prevOpen = NaN;
    var prevClose = NaN;
    for(var i=0;i<bars.length;i++){
      var b = bars[i];
      if(!b){
        out[i] = { o: NaN, h: NaN, l: NaN, c: NaN };
        continue;
      }
      var o = Number(b.o), h = Number(b.h), l = Number(b.l), c = Number(b.c);
      var haClose = (o + h + l + c) / 4;
      var haOpen = (i === 0 || !Number.isFinite(prevOpen) || !Number.isFinite(prevClose)) ? ((o + c) / 2) : ((prevOpen + prevClose) / 2);
      var haHigh = Math.max(h, haOpen, haClose);
      var haLow = Math.min(l, haOpen, haClose);
      out[i] = { o: haOpen, h: haHigh, l: haLow, c: haClose };
      prevOpen = haOpen;
      prevClose = haClose;
    }
    return out;
  }

  function findIndexByTimeMs(data, tMs){
    // data must be sorted by .t ascending.
    var lo = 0, hi = data.length - 1;
    while(lo <= hi){
      var mid = (lo + hi) >> 1;
      var v = data[mid].t;
      if(v < tMs) lo = mid + 1;
      else if(v > tMs) hi = mid - 1;
      else return mid;
    }
    return clamp(lo, 0, data.length - 1);
  }

  async function loadFromAPI(force){
    if(STATIC_MODE){
      return await loadFromStatic(force);
    }
    // Prevent overlapping requests from live polling / repeated UI events.
    // We still allow internal "one-hop" recursion (Auto W refinement) via force=true.
    if(!force && ui.regen && ui.regen.disabled) return;
    // Prevent out-of-order fetches (e.g. rapid slider drags) from overwriting newer data.
    state._reqSeq = (state._reqSeq || 0) + 1;
    var myReq = state._reqSeq;

    var symbol = String(getSymbol() || 'ESZ5').trim();
    if(!symbol) symbol = 'ESZ5';

    // Optional pass-through query params, if your backend supports them.
    var start = getQueryParam('start', '');
    var end = getQueryParam('end', '');
    var maxBarsQ = getQueryParam('max_bars', '');
    var limit = getQueryParam('limit', ''); // back-compat
    var explicitWindow = !!(start && end);
    var derivedWindow = false;
    var hadReqWindow = false;
    var reqStartMs = NaN;
    var reqEndMs = NaN;
    // If we start with unknown bounds, the server will default to "last hour ending at dataset end".
    // After the first response we can learn dataset_end and then request our preferred default window.
    var postBootstrapInitialWindow = false;

    // Cap the payload by default. If `max_bars` is set, use it; else fall back to legacy `limit`.
    // Auto W will increase bar_s to keep the returned bar count within this budget.
    var effMaxBars = (maxBarsQ !== '' ? maxBarsQ : (limit !== '' ? limit : '5000'));

    // If caller didn't specify a start/end in the URL, drive the request from the app's view anchors:
    //   - state.viewEndMs: right edge of requested window
    //   - state.viewSpanMs: requested window span (not the full dataset)
    //
    // When following latest, intentionally omit `end` so the backend can extend the window using live data.
    // When NOT following latest (manual browsing), send explicit end so panning/zooming is stable.
    if(!start && !end){
      if(Number.isFinite(state.datasetStartMs) && Number.isFinite(state.datasetEndMs)){
        var dsStart = Number(state.datasetStartMs);
        var dsEnd = Number(state.datasetEndMs);

        // Initialize anchors if unset.
        if(!Number.isFinite(state.viewEndMs)) state.viewEndMs = dsEnd;
        if(!Number.isFinite(state.viewSpanMs) || state.viewSpanMs <= 0){
          state.viewSpanMs = DEFAULT_INIT_SPAN_MS;
        }

        // Clamp anchors to dataset bounds.
        var spanMs0 = clamp(Number(state.viewSpanMs), 60*1000, Math.max(60*1000, dsEnd - dsStart));
        var endMs0 = clamp(Number(state.viewEndMs), dsStart + spanMs0, dsEnd);
        var startMs0 = Math.max(dsStart, endMs0 - spanMs0);

        state.viewSpanMs = spanMs0;
        state.viewEndMs = endMs0;

        start = msToIsoZ(startMs0);
        // omit end only in followLatest mode so server can extend window with live
        end = state.followLatest ? '' : msToIsoZ(endMs0);

        derivedWindow = true;
        reqStartMs = startMs0;
        reqEndMs = endMs0;
      }
    } else {
    // URL-driven explicit window disables followLatest.
      state.followLatest = false;
      if(start && end){
        reqStartMs = parseIsoToMs(start);
        reqEndMs = parseIsoToMs(end);
      }
    }
    hadReqWindow = !!(explicitWindow || derivedWindow);

    // Auto bar sizing: choose bar_s using the *visible* span implied by zoom (not the full dataset span).
    // Target ~300–500 candles on screen (clamped 150–800).
    // If start/end aren't provided, we'll optionally do a one-time post-adjust using the server window labels.
    var autoW = (ui.autoW ? !!ui.autoW.checked : false);
    if(autoW && start && end){
      var sMs = parseIsoToMs(start);
      var eMs = parseIsoToMs(end);
      if(Number.isFinite(sMs) && Number.isFinite(eMs) && eMs > sMs){
        var visSpanMsA = getVisibleSpanMs(eMs - sMs);
        var rec = recommendBarSecForVisibleSpan(visSpanMsA, effMaxBars);
        state.windowSec = rec;
        if(ui.window) ui.window.value = String(rec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec);
        updateUrlBarSize();
      }
    } else if(autoW && Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0){
      // Prefer the currently requested span (derived window or previously set viewSpanMs).
      var visSpanMsB = getVisibleSpanMs(state.viewSpanMs);
      if(Number.isFinite(visSpanMsB) && visSpanMsB > 0){
        var rec2 = recommendBarSecForVisibleSpan(visSpanMsB, effMaxBars);
        state.windowSec = rec2;
        if(ui.window) ui.window.value = String(rec2);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec2);
        updateUrlBarSize();
      }
    }

    // Bar size: UI drives bar_s; always normalize to preset increments (snapped state).
    var bar_s = clamp(Number(state.windowSec || ui.window.value || 60), 30, 86400);
    if(!Number.isFinite(bar_s)) bar_s = 60;
    bar_s = snapToPreset(bar_s);
    state.windowSec = bar_s;
    if(ui.window) ui.window.value = String(bar_s);
    if(ui.windowVal) ui.windowVal.textContent = formatWindow(bar_s);

    // If the full-history span would exceed the max bars budget, bump bar_s up to the smallest
    // preset that fits within effMaxBars (even if Auto W is off).
    (function enforceMaxBars(){
      try{
        var cap = Math.max(1, Math.floor(Number(effMaxBars) || 1));
        var spanMs = NaN;
        if(start && end){
          var ssMs2 = parseIsoToMs(start);
          var eeMs2 = parseIsoToMs(end);
          if(Number.isFinite(ssMs2) && Number.isFinite(eeMs2) && eeMs2 > ssMs2) spanMs = eeMs2 - ssMs2;
        } else if(Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0){
          spanMs = Number(state.viewSpanMs);
        }
        if(!Number.isFinite(spanMs) || spanMs <= 0) return;
        var visSpanMs = getVisibleSpanMs(spanMs);
        if(!Number.isFinite(visSpanMs) || visSpanMs <= 0) return;
        var visSec = Math.max(1, Math.floor(visSpanMs / 1000));
        var need = Math.ceil(visSec / Math.max(1, Math.floor(bar_s)));
        if(Number.isFinite(need) && need > cap){
          var minBar = snapCeilToPreset(Math.ceil(visSec / cap));
          minBar = clamp(minBar, 30, 86400);
          if(minBar !== bar_s){
            bar_s = minBar;
            state.windowSec = bar_s;
            if(ui.window) ui.window.value = String(bar_s);
            if(ui.windowVal) ui.windowVal.textContent = formatWindow(bar_s);
            updateUrlBarSize();
          }
        }
      } catch(_e){}
    })();

    var url = buildUrl(API_BASE, '/window', {
      symbol: symbol,
      start: start,
      end: end,
      max_bars: effMaxBars,
      // send legacy `limit` too for older servers
      limit: effMaxBars,
      bar_s: Math.floor(bar_s)
    });
    if(ui.reqInfo) ui.reqInfo.textContent = 'bar_s=' + Math.floor(bar_s) + ' (loading…)';

    var prevText = ui.regen ? ui.regen.textContent : '';
    if(ui.regen){ ui.regen.disabled = true; ui.regen.textContent = 'Loading…'; }

    // Update the "last update" chip (top-right) on success/error.
    function setUpdateChip(status, text){
      try{
        var dot = document.getElementById('updateDot');
        var el = document.getElementById('updateText');
        if(dot){
          dot.classList.remove('ok','live','warn','err');
          if(status === 'ok') dot.classList.add('ok');
          else if(status === 'live') dot.classList.add('live');
          else if(status === 'warn') dot.classList.add('warn');
          else if(status === 'err') dot.classList.add('err');
        }
        if(el) el.textContent = String(text || '');
      } catch(_e){}
    }

    try{
      // Client-side request timing (high-level): headers, download, parse.
      var t0 = (window.performance && performance.now) ? performance.now() : Date.now();
      var res = await fetch(url, { method: 'GET', cache: 'no-store' });
      var t1 = (window.performance && performance.now) ? performance.now() : Date.now();
      if(!res.ok) throw new Error('HTTP ' + res.status + ' from ' + url);
      var txt = await res.text();
      var t2 = (window.performance && performance.now) ? performance.now() : Date.now();
      var j = JSON.parse(txt);
      var t3 = (window.performance && performance.now) ? performance.now() : Date.now();
      if(myReq !== state._reqSeq) return; // stale response

      // Capture dataset bounds (if present) for navigation clamping.
      if(j && j.dataset_start){
        var ds = parseIsoToMs(j.dataset_start);
        if(Number.isFinite(ds)) state.datasetStartMs = ds;
      }
      if(j && j.dataset_end){
        var de = parseIsoToMs(j.dataset_end);
        if(Number.isFinite(de)) state.datasetEndMs = de;
      }
      state._lastFullSyncAtMs = Date.now();

      // Cold-load UX:
      // - Always render the first response (server default is "last hour ending at dataset end")
      // - Then (once bounds are known) do ONE follow-up fetch for the preferred default window
      //   ending at dataset end. Never auto-bootstrap to full-history.
      if(!explicitWindow && !derivedWindow && !start && !end && Number.isFinite(state.datasetStartMs) && Number.isFinite(state.datasetEndMs)){
        if(!state._bootstrappedInitialWindow){
          state._bootstrappedInitialWindow = true;
          state.viewEndMs = state.datasetEndMs;
          state.viewSpanMs = clamp(DEFAULT_INIT_SPAN_MS, 60*1000, Math.max(60*1000, state.datasetEndMs - state.datasetStartMs));
          postBootstrapInitialWindow = true;
        }
      }

      // Track navigation anchors from what we *asked* for (preferred) or, if absent, what we got.
      if((explicitWindow || derivedWindow) && Number.isFinite(reqEndMs) && Number.isFinite(reqStartMs) && reqEndMs > reqStartMs){
        state.viewEndMs = reqEndMs;
        state.viewSpanMs = reqEndMs - reqStartMs;
      } else if(!hadReqWindow && j && j.start && j.end){
        // Discovery only: set end anchor so subsequent requests can be anchored consistently.
        var we2 = parseIsoToMs(j.end);
        if(Number.isFinite(we2)) state.viewEndMs = we2;
      }
      if(state.followLatest && Number.isFinite(state.datasetEndMs)) state.viewEndMs = state.datasetEndMs;

      // If start/end weren't specified, use the server-reported window once to pick a better bar size.
      // Guard against infinite loops by only auto-adjusting if bar_s actually changes.
      if(autoW && (!start || !end) && j && j.start && j.end){
        var js = parseIsoToMs(j.start);
        var je = parseIsoToMs(j.end);
        if(Number.isFinite(js) && Number.isFinite(je) && je > js){
          var visSpanMsC = getVisibleSpanMs(je - js);
          var rec2 = recommendBarSecForVisibleSpan(visSpanMsC, (effMaxBars || j.max_bars || j.limit || ''));
          if(Math.floor(rec2) !== Math.floor(bar_s)){
            state.windowSec = rec2;
            if(ui.window) ui.window.value = String(rec2);
            if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec2);
            updateUrlBarSize();
            // Re-fetch with the refined bar size (one hop). Bump reqSeq via recursion; current response is discarded.
            loadFromAPI(true);
            return;
          }
        }
      }

      var t = j.t_ms, o = j.o, h = j.h, l = j.l, c = j.c, v = j.v;
      // Treat server bar_s as authoritative (server may normalize non-multiple-of-30).
      // Also reset Y pan/zoom on bar size changes so the chart visibly re-scales as expected.
      var serverBar = (j && j.bar_s !== undefined && j.bar_s !== null) ? Number(j.bar_s) : NaN;
      var effBar = Number.isFinite(serverBar) ? Math.floor(serverBar) : Math.floor(bar_s);
      if(Number.isFinite(effBar) && effBar > 0){
        if(!Number.isFinite(state._loadedBarS) || Math.floor(state._loadedBarS) !== effBar){
          state._loadedBarS = effBar;
          // Keep X behavior consistent: data loads always right-align and reset zoom.
          // (Already done below.) For Y, reset pan/zoom so auto-scale feels responsive to bar changes.
          state.yPan = 0;
          state.yScaleFactor = 1;
        }
        // Keep UI + URL consistent with what the server actually served.
        state.windowSec = clamp(effBar, 30, 86400);
        if(ui.window) ui.window.value = String(state.windowSec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(state.windowSec);
        updateUrlBarSize();
      }

      if(!Array.isArray(t) || !Array.isArray(o) || !Array.isArray(h) || !Array.isArray(l) || !Array.isArray(c) || !Array.isArray(v)){
        throw new Error('Unexpected JSON shape. Expected arrays: t_ms,o,h,l,c,v');
      }
      var n = t.length;
      if(o.length !== n || h.length !== n || l.length !== n || c.length !== n || v.length !== n){
        throw new Error('Mismatched array lengths in payload');
      }

      var out = new Array(n);
      for(var i=0;i<n;i++){
        out[i] = {
          t: Number(t[i]),
          o: Number(o[i]),
          h: Number(h[i]),
          l: Number(l[i]),
          c: Number(c[i]),
          v: Number(v[i]),
          bid: NaN,
          ask: NaN
        };
      }

      // Preserve the user's view when NOT following latest:
      // snapshot a time anchor near the center of the current view, then re-center on it after refresh.
      var anchorT = NaN;
      var anchorZoom = Number(state.xZoom);
      if(!Number.isFinite(anchorZoom) || anchorZoom <= 0) anchorZoom = 1;
      if(!state.followLatest && Array.isArray(state.data) && state.data.length){
        try{
          var n0 = state.data.length;
          var barsVis0 = Math.min(n0, Math.max(8, Math.floor(n0 / anchorZoom)));
          var off0 = Number(state.xOffset);
          if(!Number.isFinite(off0)) off0 = 0;
          var centerIdx = Math.floor(off0 + barsVis0 * 0.5);
          centerIdx = clamp(centerIdx, 0, n0 - 1);
          anchorT = Number(state.data[centerIdx].t);
        } catch(_e){}
      }

      state.data = out;
      state.ha = computeHeikinAshi(out);
      // X view policy:
      // - If following latest: keep right-aligned but do NOT reset zoom.
      // - If not following latest: keep your pan/zoom centered on the previous time anchor.
      if(!Number.isFinite(state.xZoom) || state.xZoom <= 0) state.xZoom = 1;
      if(state.followLatest){
        state.xOffset = 0; // draw() will right-align based on barsVisible
      } else if(Number.isFinite(anchorT) && state.data.length){
        state.xZoom = anchorZoom;
        var n1 = state.data.length;
        var barsVis1 = Math.min(n1, Math.max(8, Math.floor(n1 / state.xZoom)));
        var idx1 = findIndexByTimeMs(state.data, anchorT);
        state.xOffset = idx1 - barsVis1 * 0.5;
      }
      state.hoverIdx = -1;
      draw();
      // Now that we have *something* rendered, upgrade to the preferred initial window.
      // This keeps cold-load fast and avoids the long "Loading..." stall.
      if(postBootstrapInitialWindow){
        if(windowTimer) clearTimeout(windowTimer);
        windowTimer = setTimeout(function(){ loadFromAPI(); }, 30);
      }
      if(ui.reqInfo){
        var s = 'bars=' + n + ' · bar_s=' + Math.floor(bar_s);
        if(j && j.truncated) s += ' · truncated';
        if(j && j.live_merged) s += ' · live';
        try{
          var fetchMs = Math.max(0, (t1 - t0));
          var dlMs = Math.max(0, (t2 - t1));
          var parseMs = Math.max(0, (t3 - t2));
          s += ' · net=' + Math.round(fetchMs) + 'ms';
          s += ' · dl=' + Math.round(dlMs) + 'ms';
          s += ' · parse=' + Math.round(parseMs) + 'ms';
        } catch(_e){}
        if(Number.isFinite(serverBar)){
          if(Math.floor(serverBar) !== Math.floor(bar_s)) s += ' (server=' + Math.floor(serverBar) + ')';
        } else if(Math.floor(bar_s) !== 1) {
          // Helpful hint: older servers ignore bar_s and won't include it in the payload.
          s += ' (server missing bar_s; restart api_server or use ?api=...)';
        }
        ui.reqInfo.textContent = s;
      }

      // Chip: show fetch time AND data freshness (end timestamp + age).
      (function(){
        var now = new Date();
        var hh = String(now.getHours()).padStart(2,'0');
        var mm = String(now.getMinutes()).padStart(2,'0');
        var ss = String(now.getSeconds()).padStart(2,'0');
        var mode = (j && j.live_merged) ? 'LIVE' : 'HIST';

        // Prefer dataset_end if present; otherwise use the last bar time from the payload.
        var dataEndMs = NaN;
        if(j && j.dataset_end) dataEndMs = parseIsoToMs(j.dataset_end);
        if(!Number.isFinite(dataEndMs) && Array.isArray(t) && t.length) dataEndMs = Number(t[t.length - 1]);
        if(!Number.isFinite(dataEndMs) && j && j.end) dataEndMs = parseIsoToMs(j.end);

        var ageSec = Number.isFinite(dataEndMs) ? Math.max(0, Math.floor((Date.now() - dataEndMs) / 1000)) : NaN;
        var ageTxt = Number.isFinite(ageSec) ? (ageSec >= 3600 ? (Math.floor(ageSec/3600) + 'h') : (ageSec >= 60 ? (Math.floor(ageSec/60) + 'm') : (ageSec + 's'))) : '—';
        var dataTxt = Number.isFinite(dataEndMs) ? formatTooltipTimeUtc(dataEndMs) : '—';

        // If following latest but data is old, warn. (Futures can be closed; still useful signal.)
        var stale = Number.isFinite(ageSec) && ageSec > 120 && state.followLatest;
        var status = (j && j.live_merged) ? 'live' : (stale ? 'warn' : 'ok');

        // Optional ingest freshness hint (from /live/status), if available.
        var ingestTxt = '';
        try{
          var ls = state._liveStatus || null;
          if(ls && ls.enabled){
            var lastMap = ls.last_ts_event || {};
            var sym = String(getSymbol() || '');
            // Prefer exact symbol; fallback to first/only symbol if present.
            var iso = lastMap[sym];
            if(!iso){
              var keys = Object.keys(lastMap || {});
              if(keys && keys.length === 1) iso = lastMap[keys[0]];
            }
            var ms = iso ? parseIsoToMs(iso) : NaN;
            var a2 = Number.isFinite(ms) ? Math.max(0, Math.floor((Date.now() - ms)/1000)) : NaN;
            var a2Txt = Number.isFinite(a2) ? (a2 >= 3600 ? (Math.floor(a2/3600) + 'h') : (a2 >= 60 ? (Math.floor(a2/60) + 'm') : (a2 + 's'))) : '—';
            ingestTxt = ' · ingest: ' + a2Txt + ' ago';
          }
        } catch(_e){}

        setUpdateChip(status, 'Fetched: ' + hh + ':' + mm + ':' + ss + ' · ' + mode + ' · data: ' + dataTxt + ' (' + ageTxt + ' ago)' + ingestTxt);
      })();
    } catch(e){
      console.error(e);
      state.data = [];
      draw();
      var msg = String(e && e.message ? e.message : e);
      if(ui.reqInfo) ui.reqInfo.textContent = 'bar_s=' + Math.floor(bar_s) + ' (error: ' + msg + ')';
      (function(){
        var now = new Date();
        var hh = String(now.getHours()).padStart(2,'0');
        var mm = String(now.getMinutes()).padStart(2,'0');
        var ss = String(now.getSeconds()).padStart(2,'0');
        setUpdateChip('err', 'Last update: ' + hh + ':' + mm + ':' + ss + ' · ERROR');
      })();
      // Avoid blocking alerts for transient reload/network blips; rely on footer + console.
      // Common during uvicorn --reload restarts.
    } finally {
      if(ui.regen){ ui.regen.disabled = false; ui.regen.textContent = regenButtonLabel(); }
    }
  }

  async function loadFromStatic(force){
    // Keep UI behavior similar to API version, but load from ./static/bars/<symbol>_<bar_s>.json
    if(!force && ui.regen && ui.regen.disabled) return;
    state._reqSeq = (state._reqSeq || 0) + 1;
    var myReq = state._reqSeq;

    var symbol = String(getSymbol() || '').trim();
    if(!symbol) symbol = 'ES_CONT';

    // Bar size
    var bar_s = clamp(Number(state.windowSec || (ui.window ? ui.window.value : 60) || 60), 30, 86400);
    if(!Number.isFinite(bar_s)) bar_s = 60;
    bar_s = snapToPreset(bar_s);
    state.windowSec = bar_s;
    if(ui.window) ui.window.value = String(bar_s);
    if(ui.windowVal) ui.windowVal.textContent = formatWindow(bar_s);
    if(ui.reqInfo) ui.reqInfo.textContent = 'bar_s=' + Math.floor(bar_s) + ' (loading…)';

    var prevText = ui.regen ? ui.regen.textContent : '';
    if(ui.regen){ ui.regen.disabled = true; ui.regen.textContent = 'Loading…'; }

    function setUpdateChip(status, text){
      try{
        var dot = document.getElementById('updateDot');
        var el = document.getElementById('updateText');
        if(dot){
          dot.classList.remove('ok','live','warn','err');
          if(status === 'ok') dot.classList.add('ok');
          else if(status === 'warn') dot.classList.add('warn');
          else if(status === 'err') dot.classList.add('err');
        }
        if(el) el.textContent = String(text || '');
      } catch(_e){}
    }

    try{
      var t0 = (window.performance && performance.now) ? performance.now() : Date.now();
      var j = null;
      try{
        j = await loadStaticBars(symbol, bar_s);
      } catch(eLoad){
        // Fallback: if the exact bar_s file doesn't exist, try deriving it from the smallest available bars we have.
        var base = _staticBaseBySymbol[symbol] || null;
        if(!base){
          // try any cached payload for this symbol (pick smallest bar_s)
          var best = null;
          for(var kk in (_staticBarsByKey || {})){
            if(!Object.prototype.hasOwnProperty.call(_staticBarsByKey, kk)) continue;
            if(kk.indexOf(symbol + '_') !== 0) continue;
            var cand = _staticBarsByKey[kk];
            if(!cand) continue;
            var bs0 = Math.floor(Number(cand.bar_s) || 0);
            if(!Number.isFinite(bs0) || bs0 <= 0) continue;
            if(!best || bs0 < Math.floor(Number(best.bar_s) || 0)) best = cand;
          }
          base = best;
        }
        if(base){
          j = aggregateBarsPayload(base, bar_s);
          rememberBarsPayload(j);
        } else {
          throw eLoad;
        }
      }
      var t1 = (window.performance && performance.now) ? performance.now() : Date.now();
      if(myReq !== state._reqSeq) return; // stale

      // Bounds from payload
      if(j && j.dataset_start){
        var ds = parseIsoToMs(j.dataset_start);
        if(Number.isFinite(ds)) state.datasetStartMs = ds;
      }
      if(j && j.dataset_end){
        var de = parseIsoToMs(j.dataset_end);
        if(Number.isFinite(de)) state.datasetEndMs = de;
      }
      if(!Number.isFinite(state.datasetStartMs) && Array.isArray(j.t_ms) && j.t_ms.length) state.datasetStartMs = Number(j.t_ms[0]);
      if(!Number.isFinite(state.datasetEndMs) && Array.isArray(j.t_ms) && j.t_ms.length) state.datasetEndMs = Number(j.t_ms[j.t_ms.length-1]);

      var t = j.t_ms, o = j.o, h = j.h, l = j.l, c = j.c, v = j.v;
      if(!Array.isArray(t) || !Array.isArray(o) || !Array.isArray(h) || !Array.isArray(l) || !Array.isArray(c) || !Array.isArray(v)){
        throw new Error('Unexpected JSON shape. Expected arrays: t_ms,o,h,l,c,v');
      }
      var n = t.length;
      if(o.length !== n || h.length !== n || l.length !== n || c.length !== n || v.length !== n){
        throw new Error('Mismatched array lengths in payload');
      }
      var out = new Array(n);
      for(var i=0;i<n;i++){
        out[i] = { t:Number(t[i]), o:Number(o[i]), h:Number(h[i]), l:Number(l[i]), c:Number(c[i]), v:Number(v[i]), bid:NaN, ask:NaN };
      }
      state.followLatest = false;
      state.data = out;
      state.ha = computeHeikinAshi(out);
      state.hoverIdx = -1;
      if(!Number.isFinite(state.xZoom) || state.xZoom <= 0) state.xZoom = 1;
      state.xOffset = 0;
      draw();

      if(ui.reqInfo){
        var extra = '';
        try{
          if(j && j._derived_from_bar_s) extra = ' · derived_from=' + Math.floor(Number(j._derived_from_bar_s) || 0) + 's';
        } catch(_e){}
        ui.reqInfo.textContent = 'bars=' + n + ' · bar_s=' + Math.floor(bar_s) + extra + ' · load=' + Math.round(Math.max(0,t1-t0)) + 'ms';
      }
      setUpdateChip('ok', 'Loaded: ' + symbol + ' @ ' + Math.floor(bar_s) + 's');
    } catch(e){
      try{ setUpdateChip('err', 'Load error'); } catch(_e){}
      if(ui.reqInfo){
        var msg = String(e && e.message ? e.message : e);
        if(/Failed to fetch/i.test(msg)){
          msg += ' (if you are on file://, use Pick snapshot folder or Pick bars file)';
        }
        ui.reqInfo.textContent = 'Error: ' + msg;
      }
    } finally {
      if(ui.regen){ ui.regen.disabled = false; ui.regen.textContent = regenButtonLabel(); }
    }
  }

  async function pollLiveIncremental(){
    try{
      if(STATIC_MODE) return;
      if(!state.followLatest) return;
      if(state.dragging || state.yDragging) return;
      // Don't compete with an in-flight full request.
      if(ui.regen && ui.regen.disabled) return;
      // If we don't have a baseline yet, wait for the next full /window sync.
      if(!Array.isArray(state.data) || state.data.length === 0) return;

      var sym = String(getSymbol() || '').trim();
      if(!sym) return;
      var barS = Math.floor(Number(state.windowSec || 60));
      if(!Number.isFinite(barS) || barS <= 0) barS = 60;
      barS = snapToPreset(clamp(barS, 30, 86400));

      var lastT = Number(state.data[state.data.length - 1].t);
      if(!Number.isFinite(lastT)) return;
      // Overlap a couple buckets to handle in-progress-bar updates.
      var sinceMs = lastT - (barS * 1000 * 2);

      var url = liveSinceUrl(sym, sinceMs, barS, 2000);
      var res = await fetch(url, { method:'GET', cache:'no-store' });
      if(!res.ok) return;
      var j = await res.json();
      if(!j || !Array.isArray(j.t_ms) || !Array.isArray(j.o) || !Array.isArray(j.h) || !Array.isArray(j.l) || !Array.isArray(j.c) || !Array.isArray(j.v)) return;
      var t = j.t_ms, o = j.o, h = j.h, l = j.l, c = j.c, v = j.v;
      var n = t.length;
      if(!n) return;

      // Merge/append in time order.
      for(var i=0;i<n;i++){
        var tt = Number(t[i]);
        if(!Number.isFinite(tt)) continue;
        var nb = { t: tt, o: Number(o[i]), h: Number(h[i]), l: Number(l[i]), c: Number(c[i]), v: Number(v[i]), bid: NaN, ask: NaN };
        var cur = state.data;
        var m = cur.length;
        if(m === 0){
          cur.push(nb);
          continue;
        }
        var last = cur[m - 1];
        if(tt > last.t){
          cur.push(nb);
        } else if(tt === last.t){
          cur[m - 1] = nb;
        } else {
          // Rare: update earlier bucket (overlap). Replace if found, else insert.
          var idx = findIndexByTimeMs(cur, tt);
          if(idx >= 0 && idx < cur.length && cur[idx].t === tt){
            cur[idx] = nb;
          } else if(idx >= 0){
            cur.splice(idx, 0, nb);
          }
        }
      }

      state.ha = computeHeikinAshi(state.data);
      // Following latest: keep right-aligned.
      state.xOffset = 0;
      draw();

      // If the server reports a live_end watermark, use it to keep datasetEndMs moving.
      if(j && j.live_end){
        var le = parseIsoToMs(j.live_end);
        if(Number.isFinite(le)){
          if(!Number.isFinite(state.datasetEndMs) || le > state.datasetEndMs) state.datasetEndMs = le;
        }
      }
    } catch(_e){
      // ignore transient errors during reloads
    }
  }

  function draw(){
    var rect = canvas.getBoundingClientRect();
    var Wpx = rect.width;
    var Hpx = rect.height;

    ctx.clearRect(0, 0, Wpx, Hpx);
    ctx.save();
    ctx.fillStyle = 'rgba(15,22,32,0.55)';
    ctx.fillRect(0, 0, Wpx, Hpx);
    ctx.restore();

    var pad = 14;
    // Reserve space for X-axis tick labels so they don't get clipped at the bottom.
    // Slightly taller to support 2-line day labels (month + day) when zoomed out.
    var xAxisH = 40;
    var plotW = Math.max(1, Wpx - (pad*2 + 50));
    var plotH = Math.max(1, Hpx - pad*2 - xAxisH);
    var plot = { x: pad + 50, y: pad, w: plotW, h: plotH }; // full plot region (price+volume)
    var showVolume = ui.showVolume ? !!ui.showVolume.checked : false;
    var volSep = showVolume ? 8 : 0;
    var volH = 0;
    if(showVolume){
      // Default volume pane ~22% of plot height; clamp for small canvases.
      volH = clamp(Math.floor(plot.h * 0.22), 46, Math.floor(plot.h * 0.35));
      // Ensure we always leave a reasonable price pane (avoid negative heights on small charts).
      var maxVolH = Math.max(0, Math.floor(plot.h - 110));
      if(volH > maxVolH) volH = maxVolH;
    }
    var pricePlotH = Math.max(1, Math.floor(plot.h - (showVolume ? (volH + volSep) : 0)));
    var pricePlot = { x: plot.x, y: plot.y, w: plot.w, h: pricePlotH };
    var volPlot = null;
    if(showVolume && volH > 0){
      volPlot = { x: plot.x, y: pricePlot.y + pricePlot.h + volSep, w: plot.w, h: Math.max(1, plot.h - pricePlot.h - volSep) };
    }

    var bounds = computeYBounds();
    var yMin = bounds.min;
    var yMax = bounds.max;

    // If Auto-scale is disabled, use a slightly looser static range.
    if(!ui.scale.checked){
      var mid0 = (yMin + yMax) / 2;
      var span0 = (yMax - yMin) * 1.35;
      yMin = mid0 - span0/2;
      yMax = mid0 + span0/2;
    }

    // Apply interactive Y scale factor (drag the Y-axis up/down to zoom Y).
    var mid = (yMin + yMax) / 2;
    var span = (yMax - yMin) * clamp(state.yScaleFactor, 0.2, 6);
    if(!Number.isFinite(span) || span <= 0) span = 1;
    yMin = mid - span/2;
    yMax = mid + span/2;

    // Apply vertical panning (price-space). Positive yPan shifts the range up, moving data down.
    var yPan = Number(state.yPan) || 0;
    yMin += yPan;
    yMax += yPan;

    // Cache for mousemove pan scaling (dyPx -> price delta).
    state._lastYSpan = (yMax - yMin);
    // Only the price pane participates in Y pan/zoom interactions.
    state._lastPlotH = pricePlot.h;

    // y labels
    ctx.save();
    ctx.fillStyle = 'rgba(215,224,234,0.85)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    var rows = 6;
    for(var i=0;i<=rows;i++){
      var tt = i/rows;
      var price = lerp(yMax, yMin, tt);
      var yy = pricePlot.y + pricePlot.h * tt;
      ctx.fillText(price.toFixed(2), pricePlot.x - 8, yy);
    }
    ctx.restore();

    var n = state.data.length;
    if(!n){
      // Grid + "No data" message are still clipped to the plot area.
      ctx.save();
      roundRect(ctx, plot.x, plot.y, plot.w, plot.h, 14);
      ctx.clip();
      if(ui.grid.checked && pricePlot.w > 4 && pricePlot.h > 4) drawGrid(pricePlot);
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.font = '14px system-ui';
      ctx.fillText('No data', plot.x + 8, plot.y + 18);
      ctx.restore();
      ctx.restore(); // clip

      // Plot border (always visible)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      roundRect(ctx, plot.x, plot.y, plot.w, plot.h, 14);
      ctx.stroke();
      ctx.restore();
      return;
    }

    var barsVisible = Math.min(n, Math.max(8, Math.floor(n / state.xZoom)));
    // If we're at the initial load, keep the view right-aligned.
    if(!Number.isFinite(state.xOffset) || state.xOffset === 0){
      state.xOffset = Math.max(0, n - barsVisible);
    }
    state.xOffset = clamp(state.xOffset, 0, Math.max(0, n - barsVisible));

    var start = Math.floor(state.xOffset);
    var end = Math.min(n-1, start + barsVisible + 1);

    // X-axis ticks + labels (adaptive with zoom/span)
    (function drawXAxis(){
      if(end <= start) return;
      var t0 = Number(state.data[start].t);
      var t1 = Number(state.data[end].t);
      if(!Number.isFinite(t0) || !Number.isFinite(t1) || t1 <= t0) return;

      var spanMs = t1 - t0;
      var stepMs = chooseTimeStepMs(spanMs, plot.w, 140);
      var first = Math.floor(t0 / stepMs) * stepMs;
      if(first < t0) first += stepMs;

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      // Match Y-axis label style (font + fill) for consistency.
      ctx.fillStyle = 'rgba(215,224,234,0.85)';
      ctx.lineWidth = 1;
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      var labelY = plot.y + plot.h + 8;
      var isDayMode = stepMs >= 24*60*60_000;
      var prevTm = null;
      var lastLabelRight = -1e18;
      var labelPadPx = 6;
      for(var tm = first; tm <= t1; tm += stepMs){
        var idx = findIndexByTimeMs(state.data, tm);
        if(idx < start) idx = start;
        if(idx > end) idx = end;
        var x = xForIndex(idx + 0.5, plot, barsVisible);
        if(x < plot.x - 2 || x > plot.x + plot.w + 2) continue;

        // tick
        ctx.beginPath();
        ctx.moveTo(x, plot.y + plot.h);
        ctx.lineTo(x, plot.y + plot.h + 6);
        ctx.stroke();

        if(isDayMode){
          var parts = formatDayLabelPartsUtc(tm, prevTm);
          // Month label (top line) only at transitions; day number always.
          var wTop = parts.top ? ctx.measureText(parts.top).width : 0;
          var wBot = parts.bottom ? ctx.measureText(parts.bottom).width : 0;
          var w = Math.max(wTop, wBot);
          var left = x - (w/2) - labelPadPx;
          var right = x + (w/2) + labelPadPx;
          if(left >= lastLabelRight){
            if(parts.top) ctx.fillText(parts.top, x, labelY - 2);
            if(parts.bottom) ctx.fillText(parts.bottom, x, labelY + 12);
            lastLabelRight = right;
          }
        } else {
          var label = formatTimeLabelUtc(tm, stepMs);
          if(label){
            var lw = ctx.measureText(label).width;
            var lleft = x - (lw/2) - labelPadPx;
            var lright = x + (lw/2) + labelPadPx;
            if(lleft >= lastLabelRight){
              ctx.fillText(label, x, labelY);
              lastLabelRight = lright;
            }
          }
        }
        prevTm = tm;
      }
      ctx.restore();
    })();

    // Clip all in-plot rendering (grid + bands + candles + avg + crosshair) to the rounded plot frame.
    // Important: do this AFTER drawing the X-axis labels, because labels live below the plot.
    ctx.save();
    // Inset the clip slightly so antialiased strokes/bars don't paint over the border.
    var clipInset = 1;
    roundRect(ctx, plot.x + clipInset, plot.y + clipInset, plot.w - clipInset*2, plot.h - clipInset*2, 14 - clipInset);
    ctx.clip();

    if(ui.grid.checked && pricePlot.w > 4 && pricePlot.h > 4) drawGrid(pricePlot);

    var showBands = ui.showBands ? !!ui.showBands.checked : true;
    var showCandles = ui.showCandles ? !!ui.showCandles.checked : false;

    // Allow both off: leaves only Avg/BidAsk (if enabled).
    var isBands = showBands;
    var isCandles = showCandles;

    var useNoCross = !!ui.nocross.checked;
    var doFill = !!ui.fills.checked;
    var doSmooth = !!ui.smooth.checked;

    // 'outer' controls: outer bands in Bands view, and wick visibility in Candles view.
    var showOuterBands = !!ui.outer.checked && isBands;
    var showWicks = !!ui.outer.checked && isCandles;

    var showAvg = !!ui.avgline.checked;
    var showBA = false;

    // colors
    var strokeTop    = 'rgba(80,220,140,0.85)';
    var strokeMiddle = 'rgba(90,150,255,0.85)';
    var strokeLower  = 'rgba(255,110,110,0.85)';

    var strokeMain = 'rgba(255,62,165,0.78)';
    var strokeAlt  = 'rgba(215,224,234,0.52)';
    var strokeHiLo = 'rgba(138,160,181,0.45)';

    // Candle/volume direction colors (shared)
    var upColor = 'rgb(30, 200, 170)';   // teal-green
    var dnColor = 'rgb(235, 65, 120)';   // magenta-red

    // points
    var pts0=[], pts1=[], pts2=[], pts3=[];
    var ptsO=[], ptsC=[], ptsL=[], ptsH=[];
    var ptsAvg=[];
    // Bid/ask data isn't provided by this API demo.
    var ptsBid=[];
    var ptsAsk=[];

    var prevSig = null;
    var candleW = clamp((plot.w / barsVisible) * 0.60, 2, 16);

    // Volume pane (optional): scaled to vMax over the visible bars.
    if(volPlot && volPlot.w > 2 && volPlot.h > 2){
      // Separator line between panes (subtle)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      var sepY = pricePlot.y + pricePlot.h + Math.floor(volSep * 0.5);
      ctx.beginPath();
      ctx.moveTo(plot.x, sepY);
      ctx.lineTo(plot.x + plot.w, sepY);
      ctx.stroke();
      ctx.restore();

      var vMax = 0;
      for(var vi=start; vi<=end; vi++){
        var vd = state.data[vi];
        if(!vd) continue;
        var vv = Number(vd.v);
        if(Number.isFinite(vv) && vv > vMax) vMax = vv;
      }

      if(vMax > 0){
        var vPad = 4;
        var vBottom = volPlot.y + volPlot.h - vPad;
        var vAvail = Math.max(1, volPlot.h - vPad*2);
        var barW = Math.max(1, Math.floor(candleW));
        for(var vbi=start; vbi<=end; vbi++){
          var bd = state.data[vbi];
          if(!bd) continue;
          var v = Number(bd.v);
          if(!Number.isFinite(v) || v <= 0) continue;
          var hpx = (v / vMax) * vAvail;
          if(hpx < 1) hpx = 1;
          var cx = xForIndex(vbi + 0.5, plot, barsVisible);
          var x0 = Math.floor(cx - barW/2);
          var y0 = Math.floor(vBottom - hpx);
          var isUpV = (Number(bd.c) >= Number(bd.o));
          ctx.save();
          ctx.fillStyle = isUpV ? 'rgba(30, 200, 170, 0.55)' : 'rgba(235, 65, 120, 0.55)';
          ctx.fillRect(x0, y0, barW, Math.floor(vBottom - y0));
          ctx.restore();
        }
      }
    }

    for(var bi=start; bi<=end; bi++){
      var d = state.data[bi];
      if(!d) continue;
      var x = xForIndex(bi + 0.5, plot, barsVisible);

      if(useNoCross){
        var vals = [d.o, d.c, d.l, d.h].slice().sort(function(a,b){ return a-b; });
        pts0.push([x, yForPrice(vals[0], pricePlot, yMin, yMax)]);
        pts1.push([x, yForPrice(vals[1], pricePlot, yMin, yMax)]);
        pts2.push([x, yForPrice(vals[2], pricePlot, yMin, yMax)]);
        pts3.push([x, yForPrice(vals[3], pricePlot, yMin, yMax)]);
      } else {
        var sig = orderSig(d);
        if(prevSig !== null && sig !== prevSig){
          ptsO.push([NaN, NaN]);
          ptsC.push([NaN, NaN]);
          ptsL.push([NaN, NaN]);
          ptsH.push([NaN, NaN]);
        }
        ptsO.push([x, yForPrice(d.o, pricePlot, yMin, yMax)]);
        ptsC.push([x, yForPrice(d.c, pricePlot, yMin, yMax)]);
        ptsL.push([x, yForPrice(d.l, pricePlot, yMin, yMax)]);
        ptsH.push([x, yForPrice(d.h, pricePlot, yMin, yMax)]);
        prevSig = sig;
      }

      var avg = (d.o + d.c + d.h + d.l) / 4;
      ptsAvg.push([x, yForPrice(avg, pricePlot, yMin, yMax)]);

      ptsBid.push([NaN, NaN]);
      ptsAsk.push([NaN, NaN]);
    }

    // Candles
    if(isCandles){
      var cdata = (state.candleStyle === 'ha') ? state.ha : state.data;
      if(state.candleStyle === 'ha' && (!Array.isArray(state.ha) || state.ha.length !== state.data.length)){
        state.ha = computeHeikinAshi(state.data);
        cdata = state.ha;
      }
      for(var ci=start; ci<=end; ci++){
        var cd = cdata[ci];
        if(!cd) continue;
        var cx = xForIndex(ci + 0.5, plot, barsVisible);
        var yo = yForPrice(cd.o, pricePlot, yMin, yMax);
        var yc = yForPrice(cd.c, pricePlot, yMin, yMax);
        var yh = yForPrice(cd.h, pricePlot, yMin, yMax);
        var yl = yForPrice(cd.l, pricePlot, yMin, yMax);

        var isUp = (cd.c >= cd.o);
        var bodyColor = isUp ? upColor : dnColor;

        if(showWicks){
          ctx.save();
          ctx.strokeStyle = bodyColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx, yh);
          ctx.lineTo(cx, yl);
          ctx.stroke();
          ctx.restore();
        }
        var top = Math.min(yo, yc);
        var bot = Math.max(yo, yc);
        var bh = Math.max(1, bot - top);
        var bx = cx - candleW/2;
        var by = top;

        ctx.save();
        ctx.fillStyle = bodyColor;
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(bx, by, candleW, bh);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }

    // Band fills
    if(isBands && useNoCross && doFill){
      if(showOuterBands){
        fillBetween(ctx, pts3, pts2, 'rgba(80,220,140,0.18)', doSmooth);
        fillBetween(ctx, pts2, pts1, 'rgba(90,150,255,0.18)', doSmooth);
        fillBetween(ctx, pts1, pts0, 'rgba(255,110,110,0.18)', doSmooth);
      } else {
        fillBetween(ctx, pts2, pts1, 'rgba(90,150,255,0.18)', doSmooth);
      }
    }

    // Band lines
    if(isBands && useNoCross){
      if(showOuterBands){
        strokePolyline(ctx, pts0, strokeLower, 1.4, doSmooth);
        strokePolyline(ctx, pts1, strokeMiddle, 1.6, doSmooth);
        strokePolyline(ctx, pts2, strokeMiddle, 1.6, doSmooth);
        strokePolyline(ctx, pts3, strokeTop, 1.8, doSmooth);
      } else {
        strokePolyline(ctx, pts1, strokeMiddle, 1.7, doSmooth);
        strokePolyline(ctx, pts2, strokeMiddle, 1.7, doSmooth);
      }
    } else if(isBands) {
      strokePolyline(ctx, ptsO, strokeAlt, 1.25, doSmooth);
      strokePolyline(ctx, ptsC, strokeMain, 1.8, doSmooth);
      strokePolyline(ctx, ptsL, strokeHiLo, 1.0, doSmooth);
      strokePolyline(ctx, ptsH, strokeHiLo, 1.0, doSmooth);
    }

    // Avg line
    if(showAvg){
      // Match the bright UI blue used elsewhere (screenshot).
      strokePolyline(ctx, ptsAvg, 'rgb(0, 162, 255)', 1.15, doSmooth);
    }

    // Bid/ask dotted lines removed (not present in API data).

    // Hover label
    var hoverData = null;
    if(state.hoverIdx >= 0 && state.hoverIdx < n){
      var hi = state.hoverIdx;
      var rawHd = state.data[hi];
      var showHa = (state.candleStyle === 'ha');
      var hd = rawHd;
      if(showHa){
        if(!Array.isArray(state.ha) || state.ha.length !== state.data.length) state.ha = computeHeikinAshi(state.data);
        if(state.ha[hi]) hd = state.ha[hi];
      }
      var hx = xForIndex(hi + 0.5, plot, barsVisible);
      var hy = Number(state.hoverY);
      if(!Number.isFinite(hy)) hy = yForPrice(hd.c, pricePlot, yMin, yMax);
      hy = clamp(hy, pricePlot.y, pricePlot.y + pricePlot.h);

      // Cursor price derived from mouse Y (crosshair horizontal line).
      var cursorPrice = (yMax - ((hy - pricePlot.y) / pricePlot.h) * (yMax - yMin));

      // Store hover info; draw crosshair inside the clip, tooltip outside the clip.
      hoverData = { hi: hi, rawHd: rawHd, showHa: showHa, hd: hd, hx: hx, hy: hy, cursorPrice: cursorPrice };

      ctx.save();
      // Crosshair lines: vertical snapped to bar time, horizontal follows cursor price.
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(hx, plot.y);
      ctx.lineTo(hx, plot.y + plot.h);
      ctx.moveTo(plot.x, hy);
      ctx.lineTo(plot.x + plot.w, hy);
      ctx.stroke();
      ctx.restore();
    }

    // End of plot clip region
    ctx.restore();

    // Crosshair axis callouts (outside the clip so they're never cut off).
    if(hoverData){
      var hi2 = hoverData.hi;
      var rawHd2 = hoverData.rawHd;
      var showHa2 = hoverData.showHa;
      var hd2 = hoverData.hd;
      var hx2 = hoverData.hx;
      var hy2 = hoverData.hy;
      var cursorPrice2 = hoverData.cursorPrice;

      // Axis callouts (Webull-like): right price label + bottom time/date label.
      var stepForAxis = NaN;
      try{
        var t0a = Number(state.data[start].t);
        var t1a = Number(state.data[end].t);
        if(Number.isFinite(t0a) && Number.isFinite(t1a) && t1a > t0a){
          stepForAxis = chooseTimeStepMs(t1a - t0a, plot.w, 140);
        }
      } catch(_e){}

      var axisBg = 'rgba(120,130,145,0.70)';
      var axisBorder = 'rgba(255,255,255,0.12)';
      var axisText = 'rgba(255,255,255,0.92)';

      // Small drop shadow (subtle)
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;

      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textBaseline = 'middle';

      // Right price axis label
      var ptxt = Number.isFinite(cursorPrice2) ? cursorPrice2.toFixed(2) : '';
      var pw = ctx.measureText(ptxt).width;
      var ph = 20;
      var pPadX = 10;
      var pBoxW = Math.max(44, pw + pPadX*2);
      var pBoxX = (plot.x + plot.w) - pBoxW - 4; // inside plot edge
      var pBoxY = clamp(hy2 - ph/2, pricePlot.y + 3, pricePlot.y + pricePlot.h - ph - 3);
      ctx.fillStyle = axisBg;
      ctx.strokeStyle = axisBorder;
      ctx.lineWidth = 1;
      roundRect(ctx, pBoxX, pBoxY, pBoxW, ph, 8);
      ctx.fill();
      // Crisp edge: no shadow on stroke
      ctx.shadowColor = 'rgba(0,0,0,0)';
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.fillStyle = axisText;
      ctx.textAlign = 'center';
      ctx.fillText(ptxt, pBoxX + pBoxW/2, pBoxY + ph/2);

      // Bottom time/date axis label (in X-axis reserved area)
      var ttxt = formatAxisTimeUtc(rawHd2.t, stepForAxis);
      var tw = ctx.measureText(ttxt).width;
      var th = 20;
      var tPadX = 10;
      var tBoxW = Math.max(54, tw + tPadX*2);
      var tBoxX = clamp(hx2 - tBoxW/2, plot.x + 3, plot.x + plot.w - tBoxW - 3);
      var tBoxY = plot.y + plot.h + (xAxisH - th) - 4;
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;
      ctx.fillStyle = axisBg;
      ctx.strokeStyle = axisBorder;
      roundRect(ctx, tBoxX, tBoxY, tBoxW, th, 8);
      ctx.fill();
      ctx.shadowColor = 'rgba(0,0,0,0)';
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.fillStyle = axisText;
      ctx.textAlign = 'center';
      ctx.fillText(ttxt, tBoxX + tBoxW/2, tBoxY + th/2);

      ctx.restore();
    }

    // Plot border
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    roundRect(ctx, plot.x, plot.y, plot.w, plot.h, 14);
    ctx.stroke();
    ctx.restore();
  }

  // interaction
  function updateHover(e){
    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var xAxisH = 40;
    var plotW = Math.max(1, r.width - (pad*2 + 50));
    var plotX = pad + 50;
    var plotY = pad;
    var plotH = Math.max(1, r.height - pad*2 - xAxisH);

    var n = state.data.length;
    if(!n) return;

    var barsVisible = Math.min(n, Math.max(8, Math.floor(n / state.xZoom)));
    var x = e.clientX - r.left;
    var y = e.clientY - r.top;

    // Keep hover only when inside the plot area (not in axes).
    if(x < plotX || x > plotX + plotW || y < plotY || y > plotY + plotH){
      state.hoverIdx = -1;
      state.hoverX = NaN;
      state.hoverY = NaN;
      draw();
      return;
    }

    var t = (x - plotX) / plotW;
    var idx = Math.floor(state.xOffset + t * barsVisible);
    state.hoverIdx = clamp(idx, 0, n-1);
    state.hoverX = x;
    state.hoverY = y;
    draw();
  }

  canvas.addEventListener('mousemove', function(e){
    if(state.yDragging){
      var r = canvas.getBoundingClientRect();
      var dyPx = (e.clientY - r.top) - state.dragY0;
      // dy>0 => zoom out (expand span); dy<0 => zoom in
      var f = state.yScale0 * Math.exp(dyPx * 0.006);
      state.yScaleFactor = clamp(f, 0.2, 6);
      draw();
    } else if(state.dragging){
      var r = canvas.getBoundingClientRect();
      var dxPx = (e.clientX - r.left) - state.dragX0;
      var dyPx = (e.clientY - r.top) - state.dragY0;
      var n = state.data.length;
      var barsVisible = Math.min(n, Math.max(8, Math.floor(n / state.xZoom)));
      var plotW = Math.max(1, r.width - (14*2 + 50));
      var barsPerPx = barsVisible / plotW;
      state.xOffset = state.xOffset0 - dxPx * barsPerPx;
      state.lastDragDx = dxPx;

      // Vertical pan: convert pixel delta to price-space delta using the last computed span.
      var span = Number(state._lastYSpan);
      var ph = Number(state._lastPlotH);
      if(Number.isFinite(span) && span > 0 && Number.isFinite(ph) && ph > 0){
        state.yPan = Number(state.yPan0) + (dyPx / ph) * span;
      }
      draw();
    } else {
      updateHover(e);
    }
  });

  canvas.addEventListener('mouseleave', function(){
    state.hoverIdx = -1;
    state.hoverX = NaN;
    state.hoverY = NaN;
    state.dragging = false;
    state.yDragging = false;
    draw();
  });

  canvas.addEventListener('mousedown', function(e){
    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var plotX = pad + 50;
    var x = (e.clientX - r.left);
    var y = (e.clientY - r.top);

    // Any mouse interaction implies manual exploration; stop snapping back to latest.
    state.followLatest = false;

    // If user clicks in the Y-axis area (left of plot), start Y-zoom drag.
    if(x < plotX){
      state.yDragging = true;
      state.dragY0 = y;
      state.yScale0 = state.yScaleFactor;
      return;
    }

    // Otherwise, pan on X.
    state.dragging = true;
    state.dragX0 = x;
    state.dragY0 = y;
    state.xOffset0 = state.xOffset;
    state.yPan0 = Number(state.yPan) || 0;
  });

  canvas.addEventListener('dblclick', function(e){
    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var plotX = pad + 50; // left edge of plot area; Y-axis region is x < plotX
    var x = (e.clientX - r.left);

    if(x < plotX){
      e.preventDefault();
      e.stopPropagation();
      yAxisAutoFit();
    }
  });
    
  window.addEventListener('mouseup', function(){
    // If user panned into an edge, shift the requested window and refetch to browse history.
    // Older data: drag chart right => dx>0 => xOffset decreases and clamps to 0.
    // Newer data: drag chart left  => dx<0 => xOffset increases and clamps to max.
    try{
      if(!state.dragging) { state.lastDragDx = 0; }
      var dx = Number(state.lastDragDx) || 0;
      var n = state.data.length;
      if(n && Math.abs(dx) > 40){
        var barsVisible = Math.min(n, Math.max(8, Math.floor(n / state.xZoom)));
        var maxOff = Math.max(0, n - barsVisible);
        var atLeft = (state.xOffset <= 0.0001);
        var atRight = (state.xOffset >= maxOff - 0.0001);

        var span = Number(state.viewSpanMs);
        var endMs = Number(state.viewEndMs);
        if(Number.isFinite(span) && span > 0 && Number.isFinite(endMs)){
          var step = Math.max(60*1000, Math.floor(span * 0.7));
          if(atLeft && dx > 0){
            // go older
            state.followLatest = false;
            var newEnd = endMs - step;
            if(Number.isFinite(state.datasetStartMs)){
              newEnd = Math.max(newEnd, state.datasetStartMs + span);
            }
            if(newEnd !== endMs){
              state.viewEndMs = newEnd;
              loadFromAPI();
            }
          } else if(atRight && dx < 0){
            // go newer
            var newEnd2 = endMs + step;
            if(Number.isFinite(state.datasetEndMs)){
              newEnd2 = Math.min(newEnd2, state.datasetEndMs);
              if(newEnd2 === state.datasetEndMs) state.followLatest = true;
            } else {
              state.followLatest = false;
            }
            if(newEnd2 !== endMs){
              state.viewEndMs = newEnd2;
              loadFromAPI();
            }
          }
        }
      }
    } catch(_e){
      // ignore pan-to-fetch failures
    }
    state.dragging = false;
    state.yDragging = false;
    state.lastDragDx = 0;
  });

  canvas.addEventListener('wheel', function(e){
    e.preventDefault();
    // Zooming is manual exploration; stop snapping back to latest.
    state.followLatest = false;
    var n = state.data.length;
    if(!n) return;

    var zoomFactor = Math.exp(-e.deltaY * 0.0015);
    var oldZoom = state.xZoom;
    // Allow deep zoom-in so Auto W can reach 30s when viewing ~1h spans.
    var newZoom = clamp(oldZoom * zoomFactor, 1, 256);

    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var plotX = pad + 50;
    var plotW = Math.max(1, r.width - (pad*2 + 50));
    var mouseX = (e.clientX - r.left);
    var tt = clamp((mouseX - plotX) / plotW, 0, 1);

    var oldBarsVisible = Math.min(n, Math.max(8, Math.floor(n / oldZoom)));
    var newBarsVisible = Math.min(n, Math.max(8, Math.floor(n / newZoom)));

    var anchorBar = state.xOffset + tt * oldBarsVisible;
    state.xZoom = newZoom;
    state.xOffset = anchorBar - tt * newBarsVisible;

    draw();

    // If user zooms out to the point where we would show (nearly) all loaded bars, expand the
    // requested window span and refetch more history so zoom-out keeps working.
    try{
      // Important: when already clamped at xZoom==1, further zoom-out attempts won't change zoom.
      // Detect that via wheel direction (deltaY>0) and expand span repeatedly.
      var tryingZoomOut = (e && Number(e.deltaY) > 0);
      var atMinZoom = (oldZoom <= 1.01 && newZoom <= 1.01);
      var shouldExpand = (tryingZoomOut && atMinZoom) || (newZoom <= 1.01 && oldZoom > newZoom);
      if(shouldExpand && Number.isFinite(state.datasetStartMs) && Number.isFinite(state.datasetEndMs) && Number.isFinite(state.viewSpanMs) && Number.isFinite(state.viewEndMs)){
        var fullSpan = Math.max(60*1000, Number(state.datasetEndMs) - Number(state.datasetStartMs));
        var curSpan = clamp(Number(state.viewSpanMs), 60*1000, fullSpan);
        if(curSpan < fullSpan - 60*1000){
          // Manual zoom implies exploration; don't follow latest.
          state.followLatest = false;
          // Jump faster to reduce the number of expensive /window scans needed to reach full history.
          var monthMs = 30 * 24 * 60 * 60 * 1000;
          var nextSpan = (curSpan >= monthMs) ? fullSpan : Math.floor(curSpan * 4.0);
          state.viewSpanMs = Math.min(fullSpan, Math.max(curSpan + 60*1000, nextSpan));
          if(windowTimer) clearTimeout(windowTimer);
          windowTimer = setTimeout(function(){ loadFromAPI(); }, 90);
        }
      }
    } catch(_e){}

    // Auto W recompute on zoom: if the recommended bar size changes, refetch.
    try{
      if(ui.autoW && ui.autoW.checked && Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0){
        var vis = getVisibleSpanMs(state.viewSpanMs);
        var effMaxBars = (getQueryParam('max_bars','') !== '' ? getQueryParam('max_bars','') : (getQueryParam('limit','') !== '' ? getQueryParam('limit','') : '5000'));
        var rec = recommendBarSecForVisibleSpan(vis, effMaxBars);
        rec = snapToPreset(rec);
        if(Math.floor(rec) !== Math.floor(state.windowSec)){
          state.windowSec = rec;
          if(ui.window) ui.window.value = String(rec);
          if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec);
          updateUrlBarSize();
          if(windowTimer) clearTimeout(windowTimer);
          windowTimer = setTimeout(function(){ loadFromAPI(); }, 90);
        }
      }
    } catch(_e){}
  }, { passive:false });

  var windowTimer = null;
  function updateUrlBarSize(){
    try{
      var u = new URL(window.location.href);
      u.searchParams.set('bar_s', String(Math.floor(state.windowSec)));
      if(ui.autoW && ui.autoW.checked) u.searchParams.set('auto_w', '1');
      else u.searchParams.delete('auto_w');
      u.searchParams.set('max_bars', String(Math.floor(Number(getQueryParam('max_bars','') || '5000') || 5000)));
      // Legacy param: keep reading it on load, but don't keep emitting it.
      u.searchParams.delete('w');
      window.history.replaceState(null, '', u.toString());
    } catch(e){
      // Ignore URL update failures (e.g., very old browsers / unusual environments).
    }
  }

  function setWindowSecFromUI(fromSlider){
    // UX: if the user touches the bar size slider, treat that as "manual mode" and disable Auto W.
    if(fromSlider && ui.autoW && ui.autoW.checked){
      ui.autoW.checked = false;
    }
    // Any direct interaction implies the user is exploring history; stop snapping back to latest.
    if(fromSlider) state.followLatest = false;
    var w = Number(ui.window.value);
    // App is always in snapped mode: bar size is restricted to preset increments.
    w = snapToPreset(w);
    state.windowSec = clamp(w, 30, 86400);

    ui.windowVal.textContent = formatWindow(state.windowSec);
    ui.window.value = String(state.windowSec);

    updateUrlBarSize();
    scheduleSaveUiConfig();

    if(windowTimer) clearTimeout(windowTimer);
    windowTimer = setTimeout(function(){ loadFromAPI(); }, 120);
  }

  ui.window.addEventListener('input', function(){ setWindowSecFromUI(true); });
  ui.window.addEventListener('change', function(){ setWindowSecFromUI(true); });
  if(ui.autoW) ui.autoW.addEventListener('change', function(){ setWindowSecFromUI(false); });
  // Candle style dropdown interactions
  if(ui.candleStyleBtn){
    ui.candleStyleBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      toggleCandleStyleMenu();
    });
  }
  if(ui.candleStyleMenu){
    ui.candleStyleMenu.addEventListener('click', function(e){
      var t = e.target;
      if(!t || !t.getAttribute) return;
      var v = t.getAttribute('data-value');
      if(!v) return;
      setCandleStyle(v);
      closeCandleStyleMenu();
      scheduleSaveUiConfig();
      draw();
    });
  }
  document.addEventListener('click', function(e){
    // Close any open dropdown when clicking outside.
    if(ui.tickerDD && ui.tickerDD.classList.contains('open')){
      if(!(e && e.target && ui.tickerDD.contains(e.target))) closeTickerMenu();
    }
    if(ui.symbolDD && ui.symbolDD.classList.contains('open')){
      if(!(e && e.target && ui.symbolDD.contains(e.target))) closeSymbolMenu();
    }
    if(ui.candleStyleDD && ui.candleStyleDD.classList.contains('open')){
      if(!(e && e.target && ui.candleStyleDD.contains(e.target))) closeCandleStyleMenu();
    }
  });
  document.addEventListener('keydown', function(e){
    if(e && e.key === 'Escape'){
      closeTickerMenu();
      closeSymbolMenu();
      closeCandleStyleMenu();
    }
  });
  // (goLive removed)

  function onToggleDraw(){
    draw();
    scheduleSaveUiConfig();
  }
  ui.grid.addEventListener('change', onToggleDraw);
  ui.scale.addEventListener('change', onToggleDraw);
  ui.nocross.addEventListener('change', onToggleDraw);
  ui.fills.addEventListener('change', onToggleDraw);
  ui.smooth.addEventListener('change', onToggleDraw);
  ui.outer.addEventListener('change', onToggleDraw);
  ui.avgline.addEventListener('change', onToggleDraw);
  if(ui.showBands) ui.showBands.addEventListener('change', onToggleDraw);
  if(ui.showVolume) ui.showVolume.addEventListener('change', onToggleDraw);
  if(ui.showCandles) ui.showCandles.addEventListener('change', function(){
    syncCandleStyleEnabled();
    onToggleDraw();
  });
  async function fetchLatestAndReload(){
    // In API mode, this triggers the server-side fetch for *all* tickers, then reloads the window.
    if(STATIC_MODE){
      return loadFromAPI();
    }
    if(ui.regen && ui.regen.disabled) return;
    var prev = ui.regen ? ui.regen.textContent : '';
    if(ui.regen){ ui.regen.disabled = true; ui.regen.textContent = 'Fetching…'; }
    try{
      var res = await fetch('/api/fetch-latest', { method:'POST', headers:{'Content-Type':'application/json'} });
      // Ignore response body errors here; chart reload will show empty/error in footer if needed.
      try{ if(res && res.ok) await res.json(); } catch(_e){}
    } catch(_e2){
      // ignore; reload below will reflect current DB state
    } finally {
      if(ui.regen){ ui.regen.disabled = false; ui.regen.textContent = regenButtonLabel(); }
    }
    loadFromAPI();
  }

  ui.regen.addEventListener('click', fetchLatestAndReload);
  // Symbol dropdown interactions
  if(ui.tickerBtn){
    ui.tickerBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      toggleTickerMenu();
    });
  }
  if(ui.tickerMenu){
    ui.tickerMenu.addEventListener('click', function(e){
      var t = e.target;
      if(!t || !t.getAttribute) return;
      var v = t.getAttribute('data-value');
      if(!v) return;
      setTicker(v);
      closeTickerMenu();
      // Rebuild symbol list for this dataset and choose an appropriate default symbol.
      refreshSymbolMenuForTicker();
      var catalog = state._catalog || null;
      var ds = String(getTicker() || 'ES').trim().toUpperCase();
      var curSym = getSymbol();
      var curDs = (catalog && catalog.datasetBySymbol) ? catalog.datasetBySymbol[curSym] : '';
      if(curDs !== ds){
        var defSym = chooseDefaultSymbolForTicker(ds);
        if(defSym){
          ensureSymbolItem(defSym);
          setSymbol(defSym);
        }
      }
      scheduleSaveUiConfig();
      loadFromAPI();
    });
  }
  if(ui.symbolBtn){
    ui.symbolBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      toggleSymbolMenu();
    });
  }
  if(ui.symbolMenu){
    ui.symbolMenu.addEventListener('click', function(e){
      var t = e.target;
      if(!t || !t.getAttribute) return;
      var v = t.getAttribute('data-value');
      if(!v) return;
      setSymbol(v);
      closeSymbolMenu();
      scheduleSaveUiConfig();
      loadFromAPI();
    });
  }

  // tests
  function assert(cond, msg){ if(!cond) throw new Error('Test failed: ' + msg); }

  function applyYScaleBounds(minV, maxV, factor){
    var mid = (minV + maxV) / 2;
    var span = (maxV - minV) * factor;
    return { min: mid - span/2, max: mid + span/2 };
  }

  (function runTests(){
    assert(Array.isArray(SNAP_PRESETS) && SNAP_PRESETS.length > 5, 'snap presets');
    assert(snapToPreset(61) === 60, 'snap 61->60');
    assert(snapToPreset(89) === 60, 'snap 89->60');
    assert(snapCeilToPreset(61) === 300, 'snapCeil 61->300');
    assert(snapCeilToPreset(1) === (STATIC_MODE ? 30 : 60), 'snapCeil clamps min preset');
    assert(snapCeilToPreset(86400) === 86400, 'snapCeil 86400->86400');

    // Minimum bar size is the smallest preset, even if the span/target would imply smaller.
    assert(recommendBarSec(3600*1000, 5000, 800) === (STATIC_MODE ? 30 : 60), 'recommend 1h clamps to min preset');
    // Limit guard: if limit is tiny, bar_s must grow (>= 1h/100 = 36s -> snapCeil to 60s).
    assert(recommendBarSec(3600*1000, 100, 800) >= 60, 'recommend respects max bars');

    var dummy = document.createElement('canvas').getContext('2d');
    var up = [[0,0],[1,0],[2,0]];
    var lo = [[0,1],[1,1],[2,1]];
    fillBetween(dummy, up, lo, 'rgba(255,0,0,0.2)', false);
    fillBetween(dummy, up, lo, 'rgba(0,255,0,0.2)', true);
    strokePolyline(dummy, up, 'rgba(0,0,0,1)', 1, true, [3,4]);

    var threw = false;
    try {
      roundRect(dummy, 10, 10, 100, 40, 12);
      dummy.stroke();
      roundRect(dummy, 10, 10, -50, 20, 12);
      dummy.stroke();
      roundRect(dummy, 10, 10, 20, -10, 12);
      dummy.stroke();
      roundRect(dummy, 10, 10, 0.1, 0.1, 12);
      dummy.stroke();
    } catch(e){
      threw = true;
    }
    assert(!threw, 'roundRect robustness');

    assert(!!document.getElementById('showBands'), 'showBands exists');
    assert(!!document.getElementById('showCandles'), 'showCandles exists');
    assert(!!document.getElementById('showVolume'), 'showVolume exists');
    assert(!!document.getElementById('tickerDD'), 'ticker dropdown exists');
    assert(!!document.getElementById('tickerBtn'), 'ticker dropdown button exists');
    assert(!!document.getElementById('tickerMenu'), 'ticker dropdown menu exists');
    assert(!!document.getElementById('candleStyleDD'), 'candleStyle dropdown exists');
    assert(!!document.getElementById('candleStyleBtn'), 'candleStyle button exists');
    assert(!!document.getElementById('candleStyleMenu'), 'candleStyle menu exists');
    assert(!!document.getElementById('autoW'), 'autoW exists');

    var b0 = applyYScaleBounds(0, 10, 2);
    assert(Math.abs((b0.max - b0.min) - 20) < 1e-9, 'applyYScaleBounds doubles span');
    var b1 = applyYScaleBounds(0, 10, 0.5);
    assert(Math.abs((b1.max - b1.min) - 5) < 1e-9, 'applyYScaleBounds halves span');
  })();

  // boot
  (async function(){
    // Static demo: no API hint.
    // Enable bar size controls; they re-fetch the API with bar_s.
    ui.window.disabled = false;
    // API mode backed by 1-minute store: clamp UI to >= 60s and wire the single action button.
    try{
      if(!STATIC_MODE && ui.window){
        ui.window.min = '60';
        if(Number(ui.window.value) < 60) ui.window.value = '60';
      }
      if(ui.regen) ui.regen.textContent = regenButtonLabel();
    } catch(_e){}

    // 0) Populate ticker + symbol dropdown from the server's discovered datasets.
    try{
      if(ui.symbolLabel) ui.symbolLabel.textContent = 'Loading…';
      if(ui.symbolMenu) ui.symbolMenu.innerHTML = '';
    } catch(_e){}
    var items = await fetchSymbolCatalog();
    state._catalog = buildCatalogIndex(items || []);
    // Populate ticker menu
    if(ui.tickerMenu){
      ui.tickerMenu.innerHTML = '';
      var dss = (state._catalog && state._catalog.datasets) ? state._catalog.datasets : [];
      if(dss && dss.length){
        for(var di=0; di<dss.length; di++) ensureTickerItem(dss[di]);
      } else {
        ['ES','NQ','LE'].forEach(function(d){ ensureTickerItem(d); });
      }
    }
    // Choose ticker: prefer current symbol's dataset if possible, else ES, else first.
    (function(){
      var catalog = state._catalog || null;
      var curSym = getSymbol();
      var ds0 = (catalog && catalog.datasetBySymbol) ? catalog.datasetBySymbol[curSym] : '';
      if(!ds0){
        var dss2 = (catalog && catalog.datasets) ? catalog.datasets : [];
        if(dss2.indexOf('ES') >= 0) ds0 = 'ES';
        else ds0 = (dss2[0] || 'ES');
      }
      ensureTickerItem(ds0);
      setTicker(ds0);
      refreshSymbolMenuForTicker();
      // Ensure symbol is valid for the chosen ticker.
      var syms2 = (catalog && catalog.byDataset) ? catalog.byDataset[ds0] : [];
      if(syms2 && syms2.length){
        if(syms2.indexOf(curSym) < 0){
          var def = chooseDefaultSymbolForTicker(ds0);
          if(def){ ensureSymbolItem(def); setSymbol(def); }
        } else {
          ensureSymbolItem(curSym);
          setSymbol(curSym);
        }
      } else {
        // Fallback if no catalog available.
        if(ds0 === 'ES') ['ES_CONT','ESZ5','ESU5','ESM5'].forEach(function(s){ ensureSymbolItem(s); });
        setSymbol(getSymbol());
      }
    })();

    // 1) Load persisted UI config (if present).
    var cfg = await fetchUiConfig();
    if(cfg && applyUiConfig(cfg)){
      persist.hadConfig = true;
    }

    // 2) Apply URL overrides (so shareable URLs still win).
    (function(){
      // Optional: allow symbol in URL to override config.
      var symQ = getQueryParam('symbol', '');
      if(symQ){
        var s0 = String(symQ).trim();
        // With Symbol dropdown removed, treat the URL symbol as the selected ticker too.
        ensureTickerItem(s0);
        setTicker(s0);
        ensureSymbolItem(s0);
        setSymbol(s0);
      }

      // Auto W:
      // - if explicitly specified (?auto_w=1/0), honor it
      // - otherwise, if we did NOT load a saved config, default to enabled unless bar size is in URL
      var autoQ = getQueryParam('auto_w', '');
      if(ui.autoW){
        if(autoQ !== ''){
          ui.autoW.checked = (String(autoQ) === '1' || String(autoQ).toLowerCase() === 'true');
        } else if(!persist.hadConfig) {
          var hadBar = (getQueryParam('bar_s', '') !== '' || getQueryParam('w', '') !== '');
          ui.autoW.checked = !hadBar;
        }
      }

      // Bar size from URL (?bar_s=60) or legacy (?w=60), else keep existing (config/default).
      var qsBar = getQueryParam('bar_s', '');
      var qsW = getQueryParam('w', '');
      var raw = (qsBar !== '' ? qsBar : qsW);
      var ww = (raw !== '' ? clamp(Number(raw), 30, 86400) : clamp(Number(state.windowSec || ui.window.value), 30, 86400));
      if(!Number.isFinite(ww)) ww = 60;
      ww = snapToPreset(ww);
      state.windowSec = ww;
      ui.window.value = String(ww);
      ui.windowVal.textContent = formatWindow(state.windowSec);

      // Candle style from URL or existing (config/default).
      var csQ = getQueryParam('candle_style', '');
      if(csQ !== '') setCandleStyle(csQ);
      else if(!persist.hadConfig) setCandleStyle('std');
      syncCandleStyleEnabled();

      updateUrlBarSize();
    })();

    // 3) Enable persistence after initial state is coherent.
    persist.enabled = true;
    scheduleSaveUiConfig();

    loadFromAPI();
  })();

  // Live polling:
  // - Prefer incremental updates via /live/since (fast, avoids DBN scan).
  // - Do a full /window sync occasionally as a safety net.
  (function(){
    if(STATIC_MODE) return;
    try{
      if(livePollTimer) clearInterval(livePollTimer);
      livePollTimer = setInterval(function(){
        try{
          if(!state.followLatest) return;
          if(state.dragging || state.yDragging) return;
          if(ui.regen && ui.regen.disabled) return; // request in flight
          pollLiveIncremental();
          var now = Date.now();
          var lastFull = Number(state._lastFullSyncAtMs);
          if(!Number.isFinite(lastFull) || (now - lastFull) > 60_000){
            if(ui.regen && ui.regen.disabled) return; // request in flight
            loadFromAPI();
          }
        } catch(_e){}
      }, 2_000);
    } catch(_e){}
  })();

  // Live status polling (for freshness diagnostics / UI chip hints).
  (function(){
    if(STATIC_MODE) return;
    try{
      if(liveStatusTimer) clearInterval(liveStatusTimer);
      liveStatusTimer = setInterval(async function(){
        try{
          return; // disabled in static demo
          if(!res.ok) return;
          var j = await res.json();
          state._liveStatus = j;
          state._liveStatusAtMs = Date.now();
        } catch(_e){}
      }, 15_000);
    } catch(_e){}
  })();

  // Snapshot folder picker (file:// support).
  (function(){
    var btn = document.getElementById('pickStaticDir');
    if(!btn) return;
    btn.addEventListener('click', async function(){
      try{
        if(!window.showDirectoryPicker){
          alert('Directory picker not available in this browser. Serve this folder over http(s) or use Edge/Chrome.');
          return;
        }
        var h = await window.showDirectoryPicker();
        // Detect whether this is the root (contains catalog.json) or the bars folder.
        _staticDirMode = '';
        _staticRootDirHandle = null;
        _staticBarsDirHandle = null;
        _staticGeneratedCatalog = null;
        try{
          await h.getFileHandle('catalog.json');
          _staticDirMode = 'root';
          _staticRootDirHandle = h;
        } catch(_e){
          // Treat as bars directory and generate a catalog from filenames.
          _staticDirMode = 'bars';
          _staticBarsDirHandle = h;
          _staticGeneratedCatalog = await generateCatalogFromBarsDir(h);
        }
        // Try to load catalog immediately to populate menus.
        var items = await fetchSymbolCatalog();
        state._catalog = buildCatalogIndex(items || []);
        if(ui.tickerMenu){
          ui.tickerMenu.innerHTML = '';
          var dss = (state._catalog && state._catalog.datasets) ? state._catalog.datasets : [];
          if(dss && dss.length){
            for(var di=0; di<dss.length; di++) ensureTickerItem(dss[di]);
          }
        }
        // Re-sync menus + reload.
        refreshSymbolMenuForTicker();
        scheduleSaveUiConfig();
        loadFromAPI();
      } catch(e){
        try{ console.error(e); } catch(_e){}
      }
    });
  })();

  // Single bars-file picker (file:// support).
  (function(){
    var btn = document.getElementById('pickBarsFile');
    if(!btn) return;
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    input.style.display = 'none';
    document.body.appendChild(input);

    btn.addEventListener('click', function(){
      try{ input.value = ''; } catch(_e){}
      input.click();
    });

    input.addEventListener('change', async function(){
      try{
        var f = (input.files && input.files[0]) ? input.files[0] : null;
        if(!f) return;
        var txt = await f.text();
        var j = JSON.parse(txt);
        if(!j || typeof j !== 'object') throw new Error('Invalid JSON');
        if(!Array.isArray(j.t_ms) || !Array.isArray(j.o) || !Array.isArray(j.h) || !Array.isArray(j.l) || !Array.isArray(j.c) || !Array.isArray(j.v)){
          throw new Error('Unexpected JSON shape. Expected arrays: t_ms,o,h,l,c,v');
        }
        var sym = String(j.symbol || '').trim();
        var bs = Math.floor(Number(j.bar_s) || 60);
        if(!sym) sym = String(getSymbol() || 'ES_CONT').trim();
        if(!Number.isFinite(bs) || bs <= 0) bs = Math.floor(Number(state.windowSec) || 60);
        _staticBarsByKey[barsKey(sym, bs)] = j;
        rememberBarsPayload(j);
        // Also synthesize a catalog (single symbol) so menus work.
        _staticGeneratedCatalog = { symbols: [{ dataset: inferDatasetFromSymbol(sym), symbol: sym }], _generated: true };
        _staticDirMode = ''; // file-driven
        _staticRootDirHandle = null;
        _staticBarsDirHandle = null;

        // Update UI state to match the file and reload.
        ensureTickerItem(inferDatasetFromSymbol(sym) || 'ES');
        setTicker(inferDatasetFromSymbol(sym) || 'ES');
        refreshSymbolMenuForTicker();
        ensureSymbolItem(sym);
        setSymbol(sym);
        state.windowSec = snapToPreset(clamp(bs, 30, 86400));
        if(ui.window) ui.window.value = String(state.windowSec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(state.windowSec);
        scheduleSaveUiConfig();
        loadFromAPI();
      } catch(e){
        alert('Failed to load bars file: ' + String(e && e.message ? e.message : e));
      }
    });
  })();

  window.addEventListener('resize', resize);
  requestAnimationFrame(resize);

  </script>
</body>
</html>
