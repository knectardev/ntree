<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connected OCLH Chart (Static JSON)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --grid:#1b2838;
      --text:#d7e0ea;
      --muted:#8aa0b5;
      /* Responsive sidebar width with a desktop minimum. */
      --sidebarW: clamp(525px, 30vw, 525px);
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    /* Full-width, responsive layout: left sidebar placeholder + right chart. */
    .layout{
      display:grid;
      grid-template-columns: var(--sidebarW) minmax(0, 1fr);
      /* Row 1: title. Row 2: size to the chart card so sidebar matches chart height. */
      grid-template-rows: auto auto;
      gap:18px;
      padding:18px;
      /* Full-width layout: remove centered gutters so sidebar reaches the left edge (within padding). */
      max-width:none;
      width:100%;
      margin:0;
      box-sizing:border-box;
      align-items: stretch;
    }
    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; grid-template-rows: auto auto; }
    }
    .pageTop{ grid-column: 1 / -1; }
    .sidebar{
      align-self:stretch;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.07);
      background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      padding:12px;
      min-height: 0;
    }
    .sidebar h2{margin:0 0 8px 0;font-size:13px;font-weight:750;letter-spacing:.2px;color:rgba(215,224,234,.92)}
    .sidebar .hint{margin:0;font-size:12px;color:var(--muted);line-height:1.35}
    .sideCard{
      margin-top:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(8,12,18,.55);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
      padding:10px;
    }
    .sideCardTitle{
      margin:0 0 10px 0;
      font-size:12px;
      font-weight:750;
      letter-spacing:.2px;
      color:rgba(215,224,234,.92);
    }
    /* Collapsible sidebar cards (Practice / Strategy) */
    details.sideCard.sideCard--collapsible > summary.sideCardTitle{
      cursor:pointer;
      user-select:none;
      list-style:none; /* Firefox */
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin:0; /* collapsed: no extra gap */
    }
    details.sideCard.sideCard--collapsible > summary.sideCardTitle::-webkit-details-marker{ display:none; }
    details.sideCard.sideCard--collapsible > summary.sideCardTitle::after{
      content:"▸";
      color:rgba(215,224,234,.55);
      font-weight:800;
      transform: translateY(-1px);
    }
    details.sideCard.sideCard--collapsible[open] > summary.sideCardTitle{
      margin:0 0 10px 0; /* open: restore the usual title spacing */
    }
    details.sideCard.sideCard--collapsible[open] > summary.sideCardTitle::after{ content:"▾"; }
    details.sideCard.sideCard--collapsible > summary.sideCardTitle:focus-visible{
      outline: 2px solid rgba(90,150,255,.65);
      outline-offset: 3px;
      border-radius: 10px;
    }

    /* Reusable sub-grouping container inside sidebar cards (keeps related controls together). */
    .subCard{
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.14);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
      padding:10px;
    }
    .subCardTitle{
      margin:0 0 8px 0;
      font-size:11px;
      font-weight:750;
      letter-spacing:.2px;
      color:rgba(215,224,234,.78);
      display:flex;
      align-items:center;
      gap:8px;
    }

    /* Dial UI (ported from osc demo) */
    .dialRow{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 620px){
      .dialRow{ grid-template-columns: 1fr; }
    }
    .dialCol{
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background:rgba(255,255,255,.02);
    }
    .dialWrap{
      width:100%;
      aspect-ratio:1/1;
      border-radius:999px;
      background:radial-gradient(140px 140px at 35% 30%, rgba(255,255,255,0.08) 0%, rgba(0,0,0,0.10) 55%, rgba(0,0,0,0.18) 100%);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    .dialCanvas{width:100%; height:100%; display:block;}
    .dialValue{font-weight:800; color:rgba(215,224,234,.92);}
    .dialHelp{font-size:11px; color:var(--muted); margin-top:6px; line-height:1.25;}
    .hiddenInput{display:none;}
    .sideList{display:flex;flex-direction:column;gap:10px}
    .chkRow{display:flex;gap:10px;align-items:flex-start}
    .chkRow input[type="checkbox"]{transform: translateY(2px)}
    .chkLbl{display:flex;flex-direction:column;gap:6px;min-width:0}
    .chkName{font-size:12px;color:rgba(215,224,234,.92);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .swatch{
      width:44px;height:3px;border-radius:999px;background:rgba(255,255,255,.25);
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset;
    }
    /* Keep EMAs neutral (reduce color bloat); keep VWAP as the accent. */
    .swatch.ema9{background:rgba(215,224,234,.92)}
    .swatch.ema21{background:rgba(215,224,234,.72)}
    .swatch.ema50{background:rgba(215,224,234,.52)}
    .swatch.vwap{background:rgb(255, 215, 0)}
    .sideDivider{height:1px;background:rgba(255,255,255,.07);margin:10px 0}
    .formGroup{display:flex;flex-direction:column;gap:8px}
    .fieldLabel{font-size:12px;color:rgba(215,224,234,.92);font-weight:650}
    .select{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      color:rgba(215,224,234,.92);
      outline:none;
      font-size:12px;
    }
    .select:focus{border-color:rgba(90,150,255,.65)}
    .btnPrimary{
      cursor:pointer;
      width:100%;
      border-radius:10px;
      padding:10px 12px;
      border:1px solid rgba(90,150,255,.35);
      background:rgba(90,150,255,.18);
      color:rgba(235,245,255,.98);
      font-weight:750;
      font-size:12px;
    }
    .btnPrimary:hover{background:rgba(90,150,255,.24)}
    .main{min-width:0}
    .wrap{max-width:none;margin:0;padding:0}
    .top{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin-bottom:10px}
    h1{font-size:18px;margin:0;font-weight:650;letter-spacing:.2px}
    .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.07);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
    .toolbar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid rgba(255,255,255,.07);background:rgba(15,22,32,.7);backdrop-filter: blur(10px)}
    .left{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:999px}
    .pill label{font-size:12px;color:var(--muted);user-select:none;white-space:nowrap}
    .pill input[type="range"]{width:160px}
    .pill input[type="checkbox"]{transform: translateY(1px)}
    .pill input[type="text"], .pill select{width:92px;padding:6px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.20);color:var(--text);outline:none}
    .pill input[type="text"]:focus, .pill select:focus{border-color:rgba(90,150,255,.65)}
    .pill select{appearance:none}
    /* Hide No-cross option in the toolbar UI (feature remains enabled by default). */
    .pill.pill--nocross{display:none}
    .btn{cursor:pointer;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);color:var(--text);border-radius:12px;padding:8px 10px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.09)}

    /* App nav (shown when hosted via Flask). */
    .appNav{
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 6000;
      display: none; /* enabled by JS only for http(s) */
    }
    .appNav a{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(8,12,18,.78);
      backdrop-filter: blur(10px);
      color: rgba(215,224,234,.92);
      text-decoration:none;
      font-size:12px;
      font-weight:650;
      box-shadow:0 12px 34px rgba(0,0,0,.45);
    }
    .appNav a:hover{background:rgba(255,255,255,.08)}
    
    /* Practice controls (Play / Pause / Reset) */
    .practiceCtrls{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .practiceCtl{
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      flex:1 1 auto;
      min-width:120px;
      border-radius:999px;
      padding:10px 14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:rgba(235,245,255,.98);
      font-weight:720;
      font-size:13px;
      user-select:none;
    }
    .practiceCtl:hover{background:rgba(255,255,255,.09)}
    .practiceCtl--play{
      width:100%;
      flex:1 1 100%;
      border-color:rgba(90,150,255,.35);
      background:rgba(90,150,255,.18);
    }
    .practiceCtl--play:hover{background:rgba(90,150,255,.24)}
    .practiceCtl__label{display:inline-flex;align-items:center}
    .practiceCtl__icon{display:inline-block}
    .practiceCtl__icon--play{
      width:0;height:0;
      border-left:12px solid rgba(34,197,94,.95);
      border-top:7px solid transparent;
      border-bottom:7px solid transparent;
      transform: translateY(1px);
    }
    .practiceCtl__icon--pause{
      width:18px;height:14px;
      display:inline-flex;
      gap:4px;
      align-items:stretch;
    }
    .practiceCtl__icon--pause::before,
    .practiceCtl__icon--pause::after{
      content:'';
      display:block;
      width:5px;
      border-radius:2px;
      background:rgba(250,204,21,.95);
    }
    .practiceCtl__icon--reset{
      width:12px;height:12px;
      border-radius:999px;
      background:rgba(239,68,68,.95);
      box-shadow:0 0 0 3px rgba(239,68,68,.20);
    }
    .practiceSpeedWrap input[type="range"]{
      appearance:none;
      height:4px;
      border-radius:999px;
      background:rgba(255,255,255,.16);
      outline:none;
    }
    .practiceSpeedWrap input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:14px;height:14px;
      border-radius:999px;
      background:rgba(236,72,153,.95);
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 6px 16px rgba(0,0,0,.35);
    }
    .practiceSpeedWrap input[type="range"]::-moz-range-thumb{
      width:14px;height:14px;
      border-radius:999px;
      background:rgba(236,72,153,.95);
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 6px 16px rgba(0,0,0,.35);
    }

    /* Modal (history) */
    .modalOverlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.62);
      backdrop-filter: blur(8px);
      z-index:5000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .modal{
      width:min(1100px, calc(100vw - 24px));
      max-height: min(720px, calc(100vh - 24px));
      background:rgba(10,14,20,.96);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      box-shadow:0 22px 70px rgba(0,0,0,.55);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 14px;
      background:rgba(15,22,32,.70);
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .modalTitle{font-size:14px;font-weight:750;color:rgba(235,245,255,.98)}
    .modalHeaderLeft{display:flex;align-items:center;gap:10px;min-width:0}
    .historyToggles{display:flex;gap:8px;align-items:center}
    .btnToggleOn{background:rgba(90,150,255,.22); border-color:rgba(90,150,255,.45)}
    .cardList{display:flex;flex-direction:column;gap:12px}
    .sessCard{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(8,12,18,.55);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
      overflow:hidden;
    }
    .sessCardHd{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      padding:12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .sessTitle{font-weight:850;color:rgba(235,245,255,.98)}
    .sessSub{margin-top:4px;color:rgba(215,224,234,.70);font-size:12px}
    .pnlBig{font-weight:900;font-size:16px;white-space:nowrap}
    .pnlPos{color:rgba(80,220,140,.95)}
    .pnlNeg{color:rgba(255,110,110,.95)}
    .pnlFlat{color:rgba(215,224,234,.78)}
    .sessBd{padding:10px 12px 12px 12px}
    .miniRow{display:flex;flex-wrap:wrap;gap:10px;align-items:center;color:rgba(215,224,234,.80);font-size:12px}
    .miniK{color:rgba(215,224,234,.60)}
    .badgePill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:3px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:750;
      border:1px solid rgba(255,255,255,.14);
      color:rgba(215,224,234,.88);
      background:rgba(255,255,255,.05);
      white-space:nowrap;
    }
    .badgeGood{border-color:rgba(80,220,140,.40); color:rgba(80,220,140,.92); background:rgba(80,220,140,.10)}
    .badgeWarn{border-color:rgba(255,200,90,.45); color:rgba(255,200,90,.95); background:rgba(255,200,90,.10)}
    .badgeBad{border-color:rgba(255,110,110,.45); color:rgba(255,110,110,.95); background:rgba(255,110,110,.10)}
    .badgeNeutral{border-color:rgba(215,224,234,.22); color:rgba(215,224,234,.78); background:rgba(215,224,234,.06)}
    .strip{margin-top:10px;display:flex;gap:6px;flex-wrap:wrap;align-items:center}
    .segPill{
      height:10px;
      width:34px;
      border-radius:999px;
      background:rgba(215,224,234,.22);
      border:1px solid rgba(255,255,255,.10);
    }
    .segPos{background:rgba(80,220,140,.30); border-color:rgba(80,220,140,.35)}
    .segNeg{background:rgba(255,110,110,.30); border-color:rgba(255,110,110,.35)}
    .segNeu{background:rgba(215,224,234,.10); border-color:rgba(215,224,234,.14)}
    .sessFt{padding:10px 12px;border-top:1px solid rgba(255,255,255,.06);display:flex;justify-content:space-between;gap:10px;align-items:center}
    .sessHint{color:rgba(215,224,234,.60);font-size:12px}
    .modalBody{padding:12px 14px; overflow:auto}
    .tableWrap{overflow:auto; border:1px solid rgba(255,255,255,.08); border-radius:14px; background:rgba(0,0,0,.18)}
    table.histTable{border-collapse:separate;border-spacing:0; width:100%; min-width:780px; font-size:12px; color:rgba(215,224,234,.92)}
    table.histTable th, table.histTable td{padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.06); border-right:1px solid rgba(255,255,255,.06); vertical-align:top}
    table.histTable th{position:sticky; top:0; background:rgba(12,18,26,.96); z-index:2; font-weight:750}
    table.histTable th:first-child, table.histTable td:first-child{position:sticky; left:0; background:rgba(12,18,26,.96); z-index:3; font-weight:700}
    table.histTable tr:last-child td{border-bottom:none}
    table.histTable th:last-child, table.histTable td:last-child{border-right:none}
    .tradeCell{display:flex;flex-direction:column;gap:4px}
    .tradePnlUp{color:rgba(80,220,140,.95); font-weight:750}
    .tradePnlDn{color:rgba(255,110,110,.95); font-weight:750}
    .tradeMeta{color:rgba(215,224,234,.70)}
    canvas{display:block;width:100%;height:710px}
    .footer{display:flex;justify-content:space-between;gap:10px;align-items:center;padding:10px 12px;border-top:1px solid rgba(255,255,255,.07);color:var(--muted);font-size:12px;min-height:40px}
    .k{color:var(--text)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

    /* Footer bar-size control (bottom-left, like trading charts) */
    .footerLeft{display:flex;align-items:center;gap:10px;min-width:0}
    .pill.pill--barSize{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08)}
    .pill.pill--barSize input[type="hidden"]{display:none}
    .pill.pill--barSize .barRadios{gap:8px;flex-wrap:wrap}
    /* Footer session shading toggles (center) */
    .footerMid{display:flex;align-items:center;justify-content:center;gap:10px;flex:1;min-width:0}
    .sessionChecks{display:flex;align-items:center;justify-content:center;gap:14px;flex-wrap:wrap;min-width:0}
    .sessionChecks label{display:inline-flex;align-items:center;gap:8px;color:rgba(215,224,234,.92);user-select:none;white-space:nowrap}
    .sessionChecks .meta{color:var(--muted)}

    /* Footer scale radios (bottom-right) */
    .footerRight{display:flex;align-items:center;justify-content:flex-end;gap:10px;min-width:0}
    .scaleRadios{display:flex;align-items:center;justify-content:flex-end;gap:10px;flex-wrap:wrap}
    .scaleOpt{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      color:rgba(215,224,234,.92);
      font-size:12px;
      user-select:none;
      cursor:pointer;
    }
    .scaleOpt input{margin:0}
    .scaleOpt.isDisabled{
      opacity: .45;
      cursor: not-allowed;
      filter: grayscale(40%);
    }
    .scaleOpt.isDisabled input{pointer-events:none}
    .scaleOpt.isHidden{display:none}

    /* Custom dropdown (replaces native <select> so colors are consistent in dark theme) */
    .dd{position:relative}
    .ddBtn{
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
      color:var(--text);
      outline:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
    }
    .ddBtn:focus{border-color:rgba(90,150,255,.65)}
    .ddBtn:disabled{opacity:.55; cursor:not-allowed}
    .ddChevron{opacity:.8;font-size:10px;transform: translateY(-1px)}
    .ddMenu{
      position:absolute;
      top:calc(100% + 6px);
      left:0;
      min-width:84px;
      z-index:50;
      padding:6px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(8,12,18,.98);
      box-shadow:0 18px 50px rgba(0,0,0,.55);
      display:none;
    }
    .dd.open .ddMenu{display:block}
    .ddItem{
      cursor:pointer;
      user-select:none;
      padding:7px 10px;
      border-radius:10px;
      font-size:12px;
      color:rgba(215,224,234,.92);
      white-space:nowrap;
    }
    .ddItem:hover{background:rgba(255,255,255,.07)}
    .ddItem.sel{background:rgba(90,150,255,.18); color:rgba(235,245,255,.98)}

    /* Top-right status chip */
    .statusChip{
      position:fixed;
      top:12px;
      right:14px;
      z-index:1000;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(8,12,18,.78);
      backdrop-filter: blur(10px);
      box-shadow:0 12px 34px rgba(0,0,0,.45);
      font-size:12px;
      color:rgba(215,224,234,.92);
      user-select:none;
      pointer-events:none;
    }
    .statusDot{
      width:8px;
      height:8px;
      border-radius:50%;
      background:rgba(140,150,165,.8);
      box-shadow:0 0 0 2px rgba(255,255,255,.06) inset;
    }
    .statusDot.ok{ background:rgba(80,220,140,.9); }
    .statusDot.live{ background:rgba(90,150,255,.92); }
    .statusDot.warn{ background:rgba(255,200,90,.95); }
    .statusDot.err{ background:rgba(255,110,110,.92); }
    .statusMono{ font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; }
  </style>
  <style>
    /* Static demo tweaks */
    /* When embedded/served by Flask as an API-backed band chart, we flip body->.api in JS. */
    body.api #pickStaticDir{display:none !important;}
    body.api #pickBarsFile{display:none !important;}
  </style>
</head>
<body>
  <div class="appNav" id="appNav">
    <a href="/" title="Back to Dashboard">Dashboard</a>
  </div>
  <div class="statusChip" id="updateChip" aria-live="polite">
    <span class="statusDot" id="updateDot"></span>
    <span id="updateText" class="statusMono">Last update: —</span>
  </div>
  <!-- History modal -->
  <div class="modalOverlay" id="historyModal" role="dialog" aria-modal="true" aria-label="Session history" style="display:none;">
    <div class="modal">
      <div class="modalHeader">
        <div class="modalHeaderLeft">
          <div class="modalTitle">Session History</div>
          <div class="historyToggles" aria-label="History view">
            <button class="btn" type="button" id="historyViewCardsBtn" title="Session cards (glance view)">Cards</button>
            <button class="btn" type="button" id="historyViewLedgerBtn" title="Ledger view (FIFO lots)">Ledger</button>
            <button class="btn" type="button" id="historyViewMatrixBtn" title="Matrix summary view">Matrix</button>
          </div>
        </div>
        <div style="display:flex;gap:10px;align-items:center;">
          <button class="btn" type="button" id="historyRefreshBtn">Refresh</button>
          <button class="btn" type="button" id="historyCloseBtn">Close</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="hint" id="historyModalStatus" style="margin-bottom:10px;"></div>
        <div class="tableWrap" id="historyTableWrap"></div>
      </div>
    </div>
  </div>
  <div class="layout">
    <div class="pageTop top">
      <h1>.</h1>
    </div>
    <aside class="sidebar" aria-label="Indicator controls">
      <!-- Indicator controls -->
      <details class="sideCard sideCard--collapsible" aria-label="Indicator toggles">
        <summary class="sideCardTitle">Indicators</summary>
        <div class="sideCardBody">
        <p class="hint" style="margin: 0 0 10px 0;">Placeholder panel — indicator controls will live here.</p>
        <div class="sideList">
          <label class="chkRow">
            <input id="indEma9" type="checkbox" checked />
            <span class="chkLbl">
              <span class="chkName">EMA 9</span>
              <span class="swatch ema9" aria-hidden="true"></span>
            </span>
          </label>

          <label class="chkRow">
            <input id="indEma21" type="checkbox" checked />
            <span class="chkLbl">
              <span class="chkName">EMA 21</span>
              <span class="swatch ema21" aria-hidden="true"></span>
            </span>
          </label>

          <label class="chkRow">
            <input id="indEma50" type="checkbox" />
            <span class="chkLbl">
              <span class="chkName">EMA 50</span>
              <span class="swatch ema50" aria-hidden="true"></span>
            </span>
          </label>

          <label class="chkRow">
            <input id="indVwap" type="checkbox" checked />
            <span class="chkLbl">
              <span class="chkName">VWAP</span>
              <span class="swatch vwap" aria-hidden="true"></span>
            </span>
          </label>
        </div>
        </div>
      </details>

      <!-- Candlestick bias overlay is intentionally hidden/disabled for now. -->
      <details class="sideCard sideCard--collapsible" aria-label="Practice mode">
        <summary class="sideCardTitle">Practice</summary>
        <div class="sideCardBody">
        <p class="hint" style="margin: 0 0 10px 0;">
          Start a replay “practice field” session (manual play).
        </p>
        <div class="practiceCtrls">
          <!-- Idle state: show only Play -->
          <button class="practiceCtl practiceCtl--play" type="button" id="practiceBtn" title="Play replay">
            <span class="practiceCtl__label">Play</span>
            <span class="practiceCtl__icon practiceCtl__icon--play" aria-hidden="true"></span>
          </button>
          <!-- Active state: show Pause + Reset -->
          <button class="practiceCtl practiceCtl--pause" type="button" id="practicePauseBtn" title="Pause replay" style="display:none;">
            <span class="practiceCtl__label">Pause</span>
            <span class="practiceCtl__icon practiceCtl__icon--pause" aria-hidden="true"></span>
          </button>
          <button class="practiceCtl practiceCtl--reset" type="button" id="practiceResetBtn" title="Reset replay" style="display:none;">
            <span class="practiceCtl__label">Reset</span>
            <span class="practiceCtl__icon practiceCtl__icon--reset" aria-hidden="true"></span>
          </button>
        </div>
        <div class="hint practiceSpeedWrap" style="margin-top: 12px;">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
            <span>Speed</span>
            <span class="mono" id="practiceSpeedLabel">60</span>
          </div>
          <input id="practiceSpeed" type="range" min="30" max="100" step="1" value="60" style="width:100%;margin-top:8px;" />
          <div style="display:flex;align-items:center;justify-content:space-between;margin-top:6px;">
            <span>Slow (30)</span>
            <span>Fast (100)</span>
          </div>
        </div>
        <div class="sideDivider"></div>
        <div class="formGroup" aria-label="Trade controls">
          <label class="fieldLabel" for="practiceQty">Order size</label>
          <div style="display:flex;flex-direction:column;gap:8px;">
            <input id="practiceQty" type="range" min="0" max="5" step="1" value="1"
                   list="practiceQtyMarks"
                   style="width:100%; accent-color: rgba(90,150,255,.92);" />
            <datalist id="practiceQtyMarks">
              <option value="0" label="1"></option>
              <option value="1" label="5"></option>
              <option value="2" label="10"></option>
              <option value="3" label="25"></option>
              <option value="4" label="50"></option>
              <option value="5" label="100"></option>
            </datalist>
            <div style="display:flex;justify-content:space-between;color:rgba(215,224,234,.60);font-size:11px;">
              <span>1</span><span>5</span><span>10</span><span>25</span><span>50</span><span>100</span>
            </div>
            <div class="hint" id="practiceQtyLabel" style="margin-top:-2px;"></div>
          </div>
          <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;">
            <button class="btn" type="button" id="practiceLongBtn" title="Enter long (market)">
              Long
            </button>
            <button class="btn" type="button" id="practiceShortBtn" title="Enter short (market)">
              Short
            </button>
            <button class="btn" type="button" id="practiceFlattenBtn" title="Exit / flatten (market)">
              Flatten
            </button>
          </div>
        </div>
        <!-- Practice debug readouts are intentionally hidden for now (needs design pass). -->
        <div class="hint" id="practiceScore" style="display:none; margin-top: 10px; white-space: pre-line;"></div>
        <div class="hint" id="practiceStatus" style="display:none; margin-top: 10px;"></div>
        <div class="sideDivider"></div>
        <div class="formGroup" aria-label="Session history">
          <button class="btn" type="button" id="practiceHistoryBtn" title="View session history">
            History
          </button>
          <div class="hint" id="practiceHistoryStatus" style="margin-top: 6px;"></div>
        </div>
        </div>
      </details>

      <details class="sideCard sideCard--collapsible" aria-label="Strategy controls">
        <summary class="sideCardTitle">Strategy</summary>
        <div class="sideCardBody">
          <div class="formGroup">
            <label class="fieldLabel" for="strategySelect">Strategy</label>
            <select class="select" id="strategySelect" disabled>
              <option selected>None</option>
            </select>

            <label class="fieldLabel" for="btConfigSelect">Backtest config</label>
            <select class="select" id="btConfigSelect" disabled>
              <option selected>Default (risk 0.5%, RR 2.0, fee 0)</option>
            </select>

            <button class="btnPrimary" type="button" disabled>Run Backtest</button>
          </div>
        </div>
      </details>

      <details class="sideCard sideCard--collapsible" aria-label="Continuous detrend + oscillation scan">
        <summary class="sideCardTitle">Continuous detrend + oscillation scan</summary>
        <div class="sideCardBody">
          <div class="subCard" aria-label="Scan display toggles">
            <div class="subCardTitle">Display toggles</div>
            <div class="sideList">
              <label class="chkRow" title="Show detrended overlay">
                <input id="toggleDetrend" type="checkbox" checked />
                <span class="chkLbl">
                  <span class="chkName">Show detrended overlay</span>
                </span>
              </label>

              <label class="chkRow" title="Show cycle turning points">
                <input id="toggleTurns" type="checkbox" />
                <span class="chkLbl">
                  <span class="chkName">Show cycle turning points</span>
                </span>
              </label>

              <label class="chkRow" title="Show best-fit wave">
                <input id="toggleSineFit" type="checkbox" checked />
                <span class="chkLbl">
                  <span class="chkName">Show best-fit wave</span>
                </span>
              </label>

              <label class="chkRow" title="Show local match strength">
                <input id="toggleLocalMatch" type="checkbox" checked />
                <span class="chkLbl">
                  <span class="chkName">Show local match strength</span>
                </span>
              </label>
            </div>
          </div>

          <div class="subCard" aria-label="Scan settings" style="margin-top:10px;">
            <div class="subCardTitle">Scan settings</div>
            <div class="dialRow">
              <div class="dialCol">
                <label>
                  Smoothing strength
                </label>
                <div class="dialWrap">
                  <canvas class="dialCanvas" id="detrendDial" width="220" height="220"></canvas>
                </div>
                <input id="detrendHours" class="hiddenInput" type="number" min="0.25" step="0.25" value="2.0" />
                <div class="dialHelp">How aggressively we ignore slow drift before scanning for rhythms.</div>
              </div>

              <div class="dialCol">
                <label>
                  Lookback window
                </label>
                <div class="dialWrap">
                  <canvas class="dialCanvas" id="scanDial" width="220" height="220"></canvas>
                </div>
                <input id="scanWindow" class="hiddenInput" type="number" min="120" step="30" value="780" />
                <div class="dialHelp">How far back we look to score which rhythm repeats best.</div>
              </div>
            </div>
          </div>
        </div>
      </details>
    </aside>
    <main class="main">
      <div class="wrap">
        <div class="card">
          <div class="toolbar">
            <div class="left">
              <div class="pill">
                <label>Ticker</label>
                <div class="dd" id="tickerDD">
                  <button class="ddBtn mono" id="tickerBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
                    <span id="tickerLabel" class="mono">ES</span>
                    <span class="ddChevron">▾</span>
                  </button>
                  <div class="ddMenu" id="tickerMenu" role="listbox" aria-label="Ticker"></div>
                </div>
              </div>

          <div class="pill">
            <label><input id="showCandles" type="checkbox" /> Candles</label>
            <div class="dd" id="candleStyleDD">
              <button class="ddBtn" id="candleStyleBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
                <span id="candleStyleLabel">Standard</span>
                <span class="ddChevron">▾</span>
              </button>
              <div class="ddMenu" id="candleStyleMenu" role="listbox" aria-label="Candle style">
                <div class="ddItem" role="option" data-value="std">Standard</div>
                <div class="ddItem" role="option" data-value="ha">Heikin Ashi</div>
              </div>
            </div>
          </div>
          <div class="pill"><label><input id="showBands" type="checkbox" checked /> Bands</label></div>

          <div class="pill pill--nocross"><label><input id="nocross" type="checkbox" checked /> No-cross</label></div>
          <div class="pill"><label><input id="fills" type="checkbox" checked /> Fill bands</label></div>
          <div class="pill"><label><input id="smooth" type="checkbox" checked /> Smooth</label></div>
          <div class="pill"><label><input id="outer" type="checkbox" checked /> High/Low bands (or wicks)</label></div>
          <div class="pill"><label><input id="avgline" type="checkbox" checked /> Avg line</label></div>
        </div>
        <div class="right">
          <button class="btn" id="pickStaticDir" title="Pick a folder containing catalog.json and bars/*.json (works on file:// in Chromium browsers).">Pick snapshot folder</button>
          <button class="btn" id="pickBarsFile" title="Pick a single bars JSON file (works on file://).">Pick bars file</button>
          <button class="btn" id="regen">Load snapshot</button>
        </div>
          </div>

          <canvas id="c"></canvas>

      <div class="footer" aria-label="Footer (reserved for future controls)">
        <div class="footerLeft">
          <div class="pill pill--barSize" id="barSizeFooter">
            <label for="window">Bar size (W)</label>
            <!-- Keep a hidden value input so existing code can continue reading ui.window.value -->
            <input id="window" type="hidden" value="60" />
            <div class="scaleRadios barRadios" role="radiogroup" aria-label="Bar size (W)">
              <label class="scaleOpt"><input type="radio" name="windowPreset" value="60" checked /> 1m</label>
              <label class="scaleOpt"><input type="radio" name="windowPreset" value="300" /> 5m</label>
              <label class="scaleOpt"><input type="radio" name="windowPreset" value="1800" /> 30m</label>
              <label class="scaleOpt"><input type="radio" name="windowPreset" value="3600" /> 1h</label>
              <label class="scaleOpt"><input type="radio" name="windowPreset" value="14400" /> 4h</label>
              <label class="scaleOpt"><input type="radio" name="windowPreset" value="86400" /> 1d</label>
            </div>
            <span id="windowVal" class="k mono">60s</span>
            <label title="Auto-select bar size to keep the number of candles reasonable for the current zoom/span. Turn off to manually pick bar size.">
              <input id="autoW" type="checkbox" checked /> Auto
            </label>
          </div>
        </div>
        <div class="footerMid" aria-label="Market session shading toggles">
          <div class="sessionChecks" id="sessionChecks">
            <label title="Bars in window: pre-market">
              <input id="sessPreMarket" type="checkbox" checked /> Pre-Market:
              <span class="meta mono">4AM - 9:30AM</span>
              <span class="meta mono">(<span id="sessCountPre">—</span>)</span>
            </label>
            <label title="Bars in window: after-hours">
              <input id="sessAfterHours" type="checkbox" checked /> After-Hours:
              <span class="meta mono">4PM - 8PM</span>
              <span class="meta mono">(<span id="sessCountAfter">—</span>)</span>
            </label>
            <label title="Bars in window: closed (often 0 for equities)">
              <input id="sessClosed" type="checkbox" checked /> Closed:
              <span class="meta mono">8PM - 4AM</span>
              <span class="meta mono">(<span id="sessCountClosed">—</span>)</span>
            </label>
          </div>
        </div>
        <div class="footerRight" aria-label="Time scale">
          <div class="scaleRadios" role="radiogroup" aria-label="Scale">
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="1d" checked /> 1D</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="5d" /> 5D</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="1m" /> 1M</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="3m" /> 3M</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="6m" /> 6M</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="1y" /> 1Y</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="3y" /> 3Y</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="5y" /> 5Y</label>
            <label class="scaleOpt"><input type="radio" name="spanPreset" value="all" /> ALL</label>
          </div>
        </div>
      </div>
        </div>
      </div>
    </main>
  </div>

  <script>
  'use strict';

  // helpers
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a, b, t){ return a + (b - a) * t; }

  function getQueryParam(key, fallback){
    var qs = window.location.search || '';
    var re = new RegExp('[?&]' + key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '=([^&]*)');
    var m = re.exec(qs);
    if(!m) return fallback;
    return decodeURIComponent(m[1].replace(/\+/g, ' '));
  }

  function truthyQueryParam(key){
    try{
      var v = String(getQueryParam(key, '') || '').trim().toLowerCase();
      if(!v) return false;
      return (v === '1' || v === 'true' || v === 'yes' || v === 'y' || v === 'on');
    } catch(_e){
      return false;
    }
  }

  function regenButtonLabel(){
    // Single action button label.
    return STATIC_MODE ? 'Load snapshot' : 'Fetch Latest Data';
  }

    function getOverlaySettings(){
    return {
      ema9: !!(ui.indEma9 && ui.indEma9.checked),
      ema21: !!(ui.indEma21 && ui.indEma21.checked),
      ema50: !!(ui.indEma50 && ui.indEma50.checked),
      vwap: !!(ui.indVwap && ui.indVwap.checked),
        // candlestick bias intentionally disabled/hidden
        candleBias: false
    };
  }

  function anyOverlayEnabled(s){
    if(!s) return false;
    return !!(s.ema9 || s.ema21 || s.ema50 || s.vwap);
  }

  // Overlay cache keyed by (symbol, bar_s, firstT, lastT, seriesKey)
  var overlayCache = Object.create(null);

  function cacheGet(key){ return overlayCache[key] || null; }
  function cacheSet(key, val){ overlayCache[key] = val; return val; }

  function emaFromClose(t_ms, close, period){
    var n = Math.min(Array.isArray(t_ms) ? t_ms.length : 0, Array.isArray(close) ? close.length : 0);
    if(n <= 0) return null;
    var p = Math.max(1, Math.floor(Number(period) || 1));
    var k = 2 / (p + 1);
    var y = new Array(n);
    var ema = Number(close[0]);
    if(!Number.isFinite(ema)) ema = 0;
    y[0] = ema;
    for(var i=1;i<n;i++){
      var c = Number(close[i]);
      if(!Number.isFinite(c)) c = ema;
      ema = c * k + ema * (1 - k);
      y[i] = ema;
    }
    return { t_ms: t_ms.slice(0, n), y: y, key: 'ema_' + p, label: 'EMA ' + p };
  }

  // Efficient ET part extraction (for session-reset VWAP).
  var _etPartsFmt = null;
  function etParts(ms){
    if(!_etPartsFmt){
      _etPartsFmt = new Intl.DateTimeFormat('en-US', {
        timeZone: DISPLAY_TZ,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
    }
    var parts = _etPartsFmt.formatToParts(new Date(ms));
    var y=0,m=0,d=0,hh=0,mm=0;
    for(var i=0;i<parts.length;i++){
      var p = parts[i];
      if(p.type === 'year') y = parseInt(p.value, 10);
      else if(p.type === 'month') m = parseInt(p.value, 10);
      else if(p.type === 'day') d = parseInt(p.value, 10);
      else if(p.type === 'hour') hh = parseInt(p.value, 10);
      else if(p.type === 'minute') mm = parseInt(p.value, 10);
    }
    var dayKey = String(y).padStart(4,'0') + String(m).padStart(2,'0') + String(d).padStart(2,'0');
    var mins = hh * 60 + mm;
    return { y:y, m:m, d:d, hh:hh, mm:mm, dayKey: dayKey, mins: mins };
  }

  function findUtcMsForEtLocal(y, m, d, hh, mm){
    // Brute-force within +/- 12h of an EST guess; called rarely (per fetch) so it's fine.
    var guess = Date.UTC(y, m-1, d, hh + 5, mm, 0, 0);
    for(var delta=-720; delta<=720; delta++){
      var ms = guess + delta * 60_000;
      var p = etParts(ms);
      if(p.y === y && p.m === m && p.d === d && p.hh === hh && p.mm === mm) return ms;
    }
    return guess;
  }

  function sessionStartMsForEtDay(anyMs){
    var p = etParts(anyMs);
    if(!p || !p.y) return NaN;
    return findUtcMsForEtLocal(p.y, p.m, p.d, 9, 30);
  }

  // Market session vertical shading (ET schedule)
  var MARKET_HOURS_COLORS = {
    // Keep regular-hours overlay faint so grid lines remain visible
    regular: 'rgba(0, 0, 0, 0.9)',
    pre_market: 'rgba(0, 0, 0, 0.6)',
    after_hours: 'rgba(0, 0, 0, 0.3)',
    closed: 'rgba(149, 165, 166, 0.10)'
  };

  function sessionTypeForMsEt(ms){
    // Returns one of: 'regular' | 'pre_market' | 'after_hours' | 'closed'
    var p = etParts(ms);
    if(!p || !Number.isFinite(p.mins)) return 'closed';
    var mins = p.mins;
    var preStart = 4*60;          // 04:00
    var rthStart = 9*60 + 30;     // 09:30
    var rthEnd = 16*60;           // 16:00
    var ahEnd = 20*60;            // 20:00
    if(mins >= preStart && mins < rthStart) return 'pre_market';
    if(mins >= rthStart && mins < rthEnd) return 'regular';
    if(mins >= rthEnd && mins < ahEnd) return 'after_hours';
    return 'closed';
  }

  function computeSessionTypesForData(data){
    var n = Array.isArray(data) ? data.length : 0;
    var out = new Array(n);
    for(var i=0;i<n;i++){
      var d = data[i];
      var tm = d ? Number(d.t) : NaN;
      out[i] = Number.isFinite(tm) ? sessionTypeForMsEt(tm) : 'closed';
    }
    return out;
  }

  function drawSessionShading(plot, start, end, barsVisible){
    try{
      if(!plot || plot.w <= 1 || plot.h <= 1) return;
      if(!Array.isArray(state.data) || !state.data.length) return;

      // Practice / replay mode: keep the chart background uniform black.
      // The play controls already communicate the mode; session shading can read like a "gray overlay".
      try{
        if(state && state.replay && state.replay.active){
          ctx.save();
          ctx.fillStyle = MARKET_HOURS_COLORS.regular || 'rgba(0, 0, 0, 0.9)';
          ctx.fillRect(plot.x, plot.y, plot.w, plot.h);
          ctx.restore();
          return;
        }
      } catch(_eReplayBg){}

      var types = state._sessionType;
      if(!Array.isArray(types) || types.length !== state.data.length){
        // Lazy repair (should normally be set on load/merge).
        state._sessionType = computeSessionTypesForData(state.data);
        types = state._sessionType;
      }

      var showPre = ui.sessPreMarket ? !!ui.sessPreMarket.checked : true;
      var showAfter = ui.sessAfterHours ? !!ui.sessAfterHours.checked : true;
      var showClosed = ui.sessClosed ? !!ui.sessClosed.checked : true;

      function enabledForType(t){
        if(t === 'pre_market') return showPre;
        if(t === 'after_hours') return showAfter;
        if(t === 'closed') return showClosed;
        return true; // regular always on
      }

      function paintSeg(type, i0, i1){
        if(!enabledForType(type)) return;
        var x0 = xForIndex(i0, plot, barsVisible);
        var x1 = xForIndex(i1 + 1, plot, barsVisible);
        if(!Number.isFinite(x0) || !Number.isFinite(x1)) return;
        // Clamp to plot bounds
        var left = Math.max(plot.x, Math.min(x0, x1));
        var right = Math.min(plot.x + plot.w, Math.max(x0, x1));
        if(right <= left) return;
        ctx.save();
        ctx.fillStyle = MARKET_HOURS_COLORS[type] || MARKET_HOURS_COLORS.closed;
        ctx.fillRect(left, plot.y, right - left, plot.h);
        ctx.restore();
      }

      var curType = null;
      var segStart = start;
      for(var i=start; i<=end; i++){
        var t = types[i] || 'closed';
        if(curType === null){ curType = t; segStart = i; continue; }
        if(t !== curType){
          paintSeg(curType, segStart, i-1);
          curType = t;
          segStart = i;
        }
      }
      if(curType !== null) paintSeg(curType, segStart, end);

      // Replay "future padding": extend the last visible session shading into the empty
      // projection region so the right-side background matches the left/past background.
      // This does NOT create candles; it only colors the plot background.
      try{
        var padBars = Math.max(0, Math.floor(Number(futurePadBars()) || 0));
        if(padBars > 0){
          // Always use the "regular" (black) shade for the projection area.
          // Otherwise, if the last visible bar is a 'closed' session, the padding can look gray,
          // which reads like a mode indicator. Practice controls already make mode obvious.
          paintSeg('regular', end + 1, end + padBars);
        }
      } catch(_ePad){}
    } catch(_e){
      // Never let shading break the chart.
    }
  }

  function getSessionFilterFlags(){
    return {
      pre: ui.sessPreMarket ? !!ui.sessPreMarket.checked : true,
      after: ui.sessAfterHours ? !!ui.sessAfterHours.checked : true,
      closed: ui.sessClosed ? !!ui.sessClosed.checked : true
    };
  }

  function sessionTypeAllowed(type, flags){
    // Regular is always included; the toggles control extended/closed sessions.
    if(type === 'pre_market') return !!(flags && flags.pre);
    if(type === 'after_hours') return !!(flags && flags.after);
    if(type === 'closed') return !!(flags && flags.closed);
    return true;
  }

  function barsToArrays(data){
    var n = Array.isArray(data) ? data.length : 0;
    var t_ms = new Array(n);
    var o = new Array(n);
    var h = new Array(n);
    var l = new Array(n);
    var c = new Array(n);
    var v = new Array(n);
    for(var i=0;i<n;i++){
      var d = data[i];
      t_ms[i] = d ? Number(d.t) : NaN;
      o[i] = d ? Number(d.o) : NaN;
      h[i] = d ? Number(d.h) : NaN;
      l[i] = d ? Number(d.l) : NaN;
      c[i] = d ? Number(d.c) : NaN;
      v[i] = d ? Number(d.v) : NaN;
    }
    return { t_ms: t_ms, o: o, h: h, l: l, c: c, v: v };
  }

  function overlaysFromReplayState(overlaysObj, settings, allowedTms){
    // Convert server-provided replay overlays to the local overlay-series format:
    // [{t_ms:[], y:[], key,label,color,width}]
    var out = [];
    if(!overlaysObj || !settings || !allowedTms) return out;

    function buildSeries(points, key, label, color, width){
      if(!Array.isArray(points) || !points.length) return null;
      var t_ms = [];
      var y = [];
      for(var i=0;i<points.length;i++){
        var p = points[i];
        if(!p) continue;
        var tm = parseIsoToMs(p.ts);
        if(!Number.isFinite(tm)) continue;
        if(!allowedTms.has(tm)) continue;
        t_ms.push(tm);
        var v = (p.v === null || p.v === undefined) ? NaN : Number(p.v);
        y.push(Number.isFinite(v) ? v : NaN);
      }
      return { t_ms: t_ms, y: y, key: key, label: label, color: color, width: width };
    }

    try{
      var ema = overlaysObj.ema || {};
      if(settings.ema9){
        var s9 = buildSeries(ema["9"], "ema_9", "EMA 9", "rgba(215,224,234,0.92)", 1.25);
        if(s9) out.push(s9);
      }
      if(settings.ema21){
        var s21 = buildSeries(ema["21"], "ema_21", "EMA 21", "rgba(215,224,234,0.72)", 1.25);
        if(s21) out.push(s21);
      }
      if(settings.ema50){
        var s50 = buildSeries(ema["50"], "ema_50", "EMA 50", "rgba(215,224,234,0.52)", 1.25);
        if(s50) out.push(s50);
      }
      if(settings.vwap){
        var vw = buildSeries(overlaysObj.vwap, "vwap_session", "VWAP", "rgb(255, 215, 0)", 1.55);
        if(vw) out.push(vw);
      }
    } catch(_e){}
    return out;
  }

  function replayOverlaysAvailable(overlaysObj){
    // Replay backend may return `overlays: {}` (empty) even though UI supports local EMA/VWAP.
    // Only treat replay overlays as usable if they contain actual series points.
    try{
      if(!overlaysObj || typeof overlaysObj !== 'object') return false;
      if(Array.isArray(overlaysObj.vwap) && overlaysObj.vwap.length) return true;
      var ema = overlaysObj.ema;
      if(ema && typeof ema === 'object'){
        // Any EMA period with points counts.
        var keys = Object.keys(ema);
        for(var i=0;i<keys.length;i++){
          var k = keys[i];
          var arr = ema[k];
          if(Array.isArray(arr) && arr.length) return true;
        }
      }
      return false;
    } catch(_e){
      return false;
    }
  }

  function captureViewAnchor(){
    // Snapshot a time anchor near the center of the current view so filtering doesn't "jump" wildly.
    try{
      var anchorZoom = Number(state.xZoom);
      if(!Number.isFinite(anchorZoom) || anchorZoom <= 0) anchorZoom = 1;
      var anchorT = NaN;
      if(!state.followLatest && Array.isArray(state.data) && state.data.length){
        var n0 = state.data.length;
        var barsVis0 = Math.min(n0, Math.max(8, Math.floor(n0 / anchorZoom)));
        var off0 = Number(state.xOffset);
        if(!Number.isFinite(off0)) off0 = 0;
        var centerIdx = Math.floor(off0 + barsVis0 * 0.5);
        centerIdx = clamp(centerIdx, 0, n0 - 1);
        anchorT = Number(state.data[centerIdx].t);
      }
      return { t: anchorT, zoom: anchorZoom };
    } catch(_e){
      return { t: NaN, zoom: Number(state.xZoom) || 1 };
    }
  }

  function applySessionFilter(opts){
    // TradingView-style: toggles remove the actual bars (candles/volume/indicators), not just shading.
    var o = opts || {};
    var base = (Array.isArray(state.dataFull) && state.dataFull.length) ? state.dataFull : state.data;
    if(!Array.isArray(base)) base = [];

    var anchor = o.anchor || captureViewAnchor();
    var flags = getSessionFilterFlags();

    var filtered = [];
    for(var i=0;i<base.length;i++){
      var d = base[i];
      if(!d) continue;
      var tm = Number(d.t);
      var st = Number.isFinite(tm) ? sessionTypeForMsEt(tm) : 'closed';
      if(sessionTypeAllowed(st, flags)) filtered.push(d);
    }

    // If the chosen session filters yield no bars, auto-recover to "show all sessions"
    // to avoid an empty/blank chart (common source of "crash" reports when zooming).
    if(!filtered.length && base.length){
      try{
        if(ui.sessPreMarket) ui.sessPreMarket.checked = true;
        if(ui.sessAfterHours) ui.sessAfterHours.checked = true;
        if(ui.sessClosed) ui.sessClosed.checked = true;
      } catch(_e0){}
      filtered = base.slice();
      flags = getSessionFilterFlags();
    }

    state.data = filtered;
    state._sessionType = computeSessionTypesForData(filtered);
    // Heikin-Ashi is only needed when Candles are shown AND HA mode is selected.
    // Avoid recomputing HA every time replay advances if we're not rendering HA candles.
    try{
      var needHa = !!(ui && ui.showCandles && ui.showCandles.checked && state && state.candleStyle === 'ha');
      state.ha = needHa ? computeHeikinAshi(filtered) : [];
    } catch(_eHa){
      state.ha = [];
    }

    // Overlays:
    // - In replay mode, prefer server-provided overlays only if they actually contain data.
    //   (Backend may emit `overlays: {}`; in that case we compute locally so EMA/VWAP stays visible.)
    // - Otherwise, compute locally from the loaded payload.
    try{
      var os = getOverlaySettings();
      if(os && anyOverlayEnabled(os) && filtered.length){
        if(
          state && state.replay && state.replay.active &&
          state.replay.lastState && replayOverlaysAvailable(state.replay.lastState.overlays)
        ){
          var allowed = new Set();
          for(var ii=0; ii<filtered.length; ii++){
            var d2 = filtered[ii];
            if(d2 && Number.isFinite(Number(d2.t))) allowed.add(Number(d2.t));
          }
          state.overlays = overlaysFromReplayState(state.replay.lastState.overlays, os, allowed);
        } else {
          var arrs = barsToArrays(filtered);
          state.overlays = computeOverlays(
            arrs,
            os,
            { symbol: String(getSymbol() || ''), bar_s: Math.floor(Number(state.windowSec) || 60) }
          );
        }
      } else {
        state.overlays = [];
      }
    } catch(_e2){
      state.overlays = [];
    }

    // Keep view policy consistent with loads: followLatest stays right-aligned, otherwise re-center on anchor time.
    try{
      if(!Number.isFinite(state.xZoom) || state.xZoom <= 0) state.xZoom = 1;
      if(state.followLatest){
        rightAlignXView();
      } else if(Number.isFinite(anchor && anchor.t) && state.data.length){
        state.xZoom = Number(anchor.zoom) || state.xZoom;
        var n1 = state.data.length;
        var barsVis1 = computeVisibleBars(n1, state.xZoom).barsVisibleData;
        var idx1 = findIndexByTimeMs(state.data, anchor.t);
        state.xOffset = idx1 - barsVis1 * 0.5;
      }
    } catch(_e3){}

    // Clamp xOffset to new bounds and clear hover (indices changed).
    try{
      state.hoverIdx = -1;
      var n2 = state.data.length;
      if(n2){
        var barsVisibleData = computeVisibleBars(n2, state.xZoom).barsVisibleData;
        var maxOff = Math.max(0, n2 - barsVisibleData);
        state.xOffset = clamp(Number(state.xOffset) || 0, 0, maxOff);
      } else {
        state.xOffset = 0;
      }
    } catch(_e4){}

    // Update counts from the unfiltered window so users can tell when a session has 0 bars.
    updateSessionCountsUi();

    if(!o.skipDraw) draw();
    if(!o.skipSave) scheduleSaveUiConfig();
  }

  function updateSessionCountsUi(){
    try{
      var base = (Array.isArray(state.dataFull) && state.dataFull.length) ? state.dataFull : state.data;
      if(!Array.isArray(base) || !base.length) return;
      var pre = 0, after = 0, closed = 0, reg = 0;
      for(var i=0;i<base.length;i++){
        var d = base[i];
        if(!d) continue;
        var tm = Number(d.t);
        var st = Number.isFinite(tm) ? sessionTypeForMsEt(tm) : 'closed';
        if(st === 'pre_market') pre++;
        else if(st === 'after_hours') after++;
        else if(st === 'closed') closed++;
        else reg++;
      }
      var elPre = document.getElementById('sessCountPre');
      var elAfter = document.getElementById('sessCountAfter');
      var elClosed = document.getElementById('sessCountClosed');
      if(elPre) elPre.textContent = String(pre);
      if(elAfter) elAfter.textContent = String(after);
      if(elClosed) elClosed.textContent = String(closed);
    } catch(_e){}
  }

  function vwapSession(bars){
    // bars: {t_ms,h,l,c,v}
    var t_ms = bars.t_ms, h = bars.h, l = bars.l, c = bars.c, v = bars.v;
    var n = Math.min(t_ms.length, h.length, l.length, c.length, v.length);
    if(n <= 0) return null;
    var y = new Array(n);
    var cumPV = 0;
    var cumV = 0;
    var prevDay = '';
    var prevMins = -1;
    var openMins = 9*60 + 30;
    var closeMins = 16*60;
    var lastRegVwap = NaN;
    for(var i=0;i<n;i++){
      var tm = Number(t_ms[i]);
      if(!Number.isFinite(tm)) { y[i] = NaN; continue; }
      var p = etParts(tm);
      var reset = false;
      if(i === 0) reset = true;
      else if(p.dayKey !== prevDay) reset = true;
      else if(prevMins < openMins && p.mins >= openMins) reset = true;
      if(reset){ cumPV = 0; cumV = 0; lastRegVwap = NaN; }

      // Anchor VWAP to 09:30 ET:
      // - Before 09:30: no VWAP (don't accumulate premarket prints)
      // - Regular session: accumulate
      // - After 16:00: hold last regular VWAP flat
      if(p.mins < openMins){
        y[i] = NaN;
        prevDay = p.dayKey;
        prevMins = p.mins;
        continue;
      }
      if(p.mins >= closeMins){
        y[i] = Number.isFinite(lastRegVwap) ? lastRegVwap : NaN;
        prevDay = p.dayKey;
        prevMins = p.mins;
        continue;
      }
      var tp = (Number(h[i]) + Number(l[i]) + Number(c[i])) / 3;
      if(!Number.isFinite(tp)) tp = Number(c[i]);
      var vv = Number(v[i]);
      if(!Number.isFinite(vv) || vv < 0) vv = 0;
      cumPV += tp * vv;
      cumV += vv;
      y[i] = (cumV > 0) ? (cumPV / cumV) : tp;
      lastRegVwap = y[i];
      prevDay = p.dayKey;
      prevMins = p.mins;
    }
    return { t_ms: t_ms.slice(0, n), y: y, key: 'vwap_session', label: 'VWAP' };
  }

  function computeOverlays(bars, settings, meta){
    var out = [];
    if(!bars || !Array.isArray(bars.t_ms) || !bars.t_ms.length) return out;
    if(!settings || !anyOverlayEnabled(settings)) return out;
    var sym = meta && meta.symbol ? String(meta.symbol) : '';
    var barS = meta && meta.bar_s ? String(Math.floor(meta.bar_s)) : '';
    var firstT = Number(bars.t_ms[0]);
    var lastT = Number(bars.t_ms[bars.t_ms.length - 1]);
    // Include length so cached overlays can't be incorrectly reused for filtered windows that share
    // the same [firstT,lastT] but contain fewer bars (e.g. when extended hours are hidden).
    var n0 = Math.floor(Number(bars.t_ms.length) || 0);
    var baseKey = sym + '|' + barS + '|' + String(firstT) + '|' + String(lastT) + '|' + String(n0) + '|';

    function getOrCompute(seriesKey, computeFn){
      var k = baseKey + seriesKey;
      var cached = cacheGet(k);
      if(cached) return cached;
      var val = computeFn();
      if(val) cacheSet(k, val);
      return val;
    }

    if(settings.ema9){
      var s9 = getOrCompute('ema_9', function(){ return emaFromClose(bars.t_ms, bars.c, 9); });
      if(s9){ s9.color = 'rgba(215,224,234,0.92)'; s9.width = 1.25; out.push(s9); }
    }
    if(settings.ema21){
      var s21 = getOrCompute('ema_21', function(){ return emaFromClose(bars.t_ms, bars.c, 21); });
      if(s21){ s21.color = 'rgba(215,224,234,0.72)'; s21.width = 1.25; out.push(s21); }
    }
    if(settings.ema50){
      var s50 = getOrCompute('ema_50', function(){ return emaFromClose(bars.t_ms, bars.c, 50); });
      if(s50){ s50.color = 'rgba(215,224,234,0.52)'; s50.width = 1.25; out.push(s50); }
    }
    if(settings.vwap){
      var vw = getOrCompute('vwap_session', function(){ return vwapSession(bars); });
      if(vw){ vw.color = 'rgb(255, 215, 0)'; vw.width = 1.55; out.push(vw); }
    }
    return out;
  }

  // Mode selection:
  // - static: load from ./static/*.json or file:// pickers
  // - api: fetch from same-origin (or ?api_base=...) /window endpoint
  //
  // UX: when hosted over http(s) by the Flask app, default to API mode.
  // When opened via file://, default to static mode.
  var _defaultMode = (String(window.location && window.location.protocol || '') === 'file:') ? 'static' : 'api';
  var MODE = getQueryParam('mode', _defaultMode);
  // Static-only mode: no server calls.
  var STATIC_MODE = (String(MODE || '').toLowerCase() !== 'api');
  // When in api mode, the chart calls: buildUrl(API_BASE, '/window', ...)
  // Use same-origin by default; override with ?api_base=http://127.0.0.1:5000 if needed.
  var API_BASE = getQueryParam('api_base', '');
  // Single-symbol convenience: when ?single=1&symbol=SPY, build a catalog from the symbol.
  var SINGLE_MODE = (getQueryParam('single', '') !== '');
  try{
    if(document && document.body){
      document.body.classList.remove('static','api');
      document.body.classList.add(STATIC_MODE ? 'static' : 'api');
    }
  } catch(_e){}

  // Show app navigation only when hosted via Flask/http(s).
  try{
    var nav = document.getElementById('appNav');
    if(nav){
      var proto = String(window.location && window.location.protocol || '');
      // NOTE: CSS default is display:none; so we must explicitly set a visible display value here.
      nav.style.display = (proto === 'http:' || proto === 'https:') ? 'block' : 'none';
    }
  } catch(_eNav){}

  function buildUrl(base, path, params){
    var b = String(base || '').replace(/\/+$/,'');
    var p = String(path || '');
    var q = [];
    for(var k in (params || {})){
      if(!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if(v === undefined || v === null || v === '') continue;
      q.push(encodeURIComponent(k) + '=' + encodeURIComponent(String(v)));
    }
    return b + p + (q.length ? ('?' + q.join('&')) : '');
  }

  // When served over http(s), we can fetch relative JSON files from here.
  var STATIC_BASE = getQueryParam('static_base', './static');
  // When opened via file://, use Directory Picker (Chromium) to read local files.
  // Folder selection modes:
  // - root: selected folder contains catalog.json and (optionally) bars/
  // - bars: selected folder is the bars/ folder itself
  var _staticDirMode = ''; // 'root' | 'bars' | ''
  var _staticRootDirHandle = null;
  var _staticBarsDirHandle = null;
  var _staticGeneratedCatalog = null; // { symbols:[{dataset,symbol}], _generated:true }
  var _staticBarsByKey = {}; // key: `${symbol}_${bar_s}` => barsPayload
  var _staticBaseBySymbol = {}; // symbol => smallest-bar_s barsPayload (best for aggregation)

  function joinPath(a, b){
    var aa = String(a || '').replace(/\/+$/,'');
    var bb = String(b || '').replace(/^\/+/,'');
    return aa + '/' + bb;
  }

  async function readTextFromDirHandle(dirHandle, relPath){
    if(!dirHandle) throw new Error('No directory handle selected');
    var parts = String(relPath || '').split('/').filter(function(x){ return !!x; });
    var cur = dirHandle;
    for(var i=0;i<parts.length;i++){
      var name = parts[i];
      var isLast = (i === parts.length - 1);
      if(isLast){
        var fh = await cur.getFileHandle(name);
        var f = await fh.getFile();
        return await f.text();
      }
      cur = await cur.getDirectoryHandle(name);
    }
    throw new Error('Invalid relPath: ' + relPath);
  }

  function inferDatasetFromSymbol(sym){
    var s = String(sym || '').trim().toUpperCase();
    if(!s) return '';
    // Prefer prefix before _CONT if present.
    var m0 = /^([A-Z0-9]+)_CONT$/.exec(s);
    if(m0 && m0[1]) return m0[1];
    // Otherwise take leading letters (ESZ5 -> ES, NQH6 -> NQ).
    var m1 = /^([A-Z]{1,6})/.exec(s);
    if(m1 && m1[1]) return m1[1];
    return '';
  }

  function barsKey(symbol, bar_s){
    var sym = String(symbol || '').trim();
    var bs = Math.floor(Number(bar_s) || 0);
    return sym + '_' + bs;
  }

  function rememberBarsPayload(j){
    try{
      if(!j || typeof j !== 'object') return;
      var sym = String(j.symbol || '').trim();
      var bs = Math.floor(Number(j.bar_s) || 0);
      if(!sym || !Number.isFinite(bs) || bs <= 0) return;
      var k = barsKey(sym, bs);
      _staticBarsByKey[k] = j;
      var cur = _staticBaseBySymbol[sym] || null;
      var curBs = cur ? Math.floor(Number(cur.bar_s) || 0) : 0;
      if(!cur || !Number.isFinite(curBs) || curBs <= 0 || bs < curBs){
        _staticBaseBySymbol[sym] = j;
      }
    } catch(_e){}
  }

  function aggregateBarsPayload(basePayload, targetBarS){
    // Aggregate OHLCV from a smaller bar size into a larger one.
    // We align buckets relative to the first timestamp to keep the chart stable.
    if(!basePayload || typeof basePayload !== 'object') throw new Error('No base payload to aggregate');
    var sym = String(basePayload.symbol || '').trim();
    var baseS = Math.floor(Number(basePayload.bar_s) || 0);
    var tgtS = Math.floor(Number(targetBarS) || 0);
    if(!sym) throw new Error('Base payload missing symbol');
    if(!Number.isFinite(baseS) || baseS <= 0) throw new Error('Base payload missing bar_s');
    if(!Number.isFinite(tgtS) || tgtS <= 0) throw new Error('Invalid target bar_s');
    if(tgtS < baseS) throw new Error('Cannot downsample below base bar_s (' + baseS + 's)');

    var t = basePayload.t_ms, o = basePayload.o, h = basePayload.h, l = basePayload.l, c = basePayload.c, v = basePayload.v;
    if(!Array.isArray(t) || !Array.isArray(o) || !Array.isArray(h) || !Array.isArray(l) || !Array.isArray(c) || !Array.isArray(v)){
      throw new Error('Base payload missing arrays t_ms,o,h,l,c,v');
    }
    var n = t.length;
    if(!n) throw new Error('Base payload has no data');
    if(o.length !== n || h.length !== n || l.length !== n || c.length !== n || v.length !== n){
      throw new Error('Base payload has mismatched array lengths');
    }
    var t0 = Number(t[0]);
    if(!Number.isFinite(t0)) throw new Error('Base payload t_ms[0] not finite');
    var bucketMs = tgtS * 1000;

    var outT = [];
    var outO = [];
    var outH = [];
    var outL = [];
    var outC = [];
    var outV = [];

    var curBucket = null;
    var bo = NaN, bh = -Infinity, bl = Infinity, bc = NaN, bv = 0;
    var bt = NaN;

    function flush(){
      if(curBucket === null) return;
      outT.push(bt);
      outO.push(bo);
      outH.push(bh);
      outL.push(bl);
      outC.push(bc);
      outV.push(bv);
    }

    for(var i=0;i<n;i++){
      var ti = Number(t[i]);
      if(!Number.isFinite(ti)) continue;
      var b = Math.floor((ti - t0) / bucketMs);
      if(curBucket === null){
        curBucket = b;
        bt = t0 + b * bucketMs;
        bo = Number(o[i]);
        bh = Number(h[i]);
        bl = Number(l[i]);
        bc = Number(c[i]);
        bv = Number(v[i]);
        continue;
      }
      if(b !== curBucket){
        flush();
        curBucket = b;
        bt = t0 + b * bucketMs;
        bo = Number(o[i]);
        bh = Number(h[i]);
        bl = Number(l[i]);
        bc = Number(c[i]);
        bv = Number(v[i]);
        continue;
      }
      // same bucket
      var hi = Number(h[i]); if(Number.isFinite(hi)) bh = Math.max(bh, hi);
      var li = Number(l[i]); if(Number.isFinite(li)) bl = Math.min(bl, li);
      bc = Number(c[i]);
      var vi = Number(v[i]); if(Number.isFinite(vi)) bv += vi;
    }
    flush();

    var out = {
      symbol: sym,
      bar_s: tgtS,
      dataset_start: basePayload.dataset_start || null,
      dataset_end: basePayload.dataset_end || null,
      start: basePayload.start || null,
      end: basePayload.end || null,
      t_ms: outT,
      o: outO,
      h: outH,
      l: outL,
      c: outC,
      v: outV,
      _derived_from_bar_s: baseS
    };
    // If start/end not present, derive from timestamps.
    try{
      if(outT.length){
        if(!out.start) out.start = new Date(outT[0]).toISOString().replace('.000Z','Z');
        if(!out.end) out.end = new Date(outT[outT.length-1]).toISOString().replace('.000Z','Z');
      }
    } catch(_e){}
    return out;
  }

  async function generateCatalogFromBarsDir(dirHandle){
    // Build a minimal catalog from filenames like <symbol>_<bar_s>.json.
    var symbols = [];
    var seen = {};
    try{
      for await (var entry of dirHandle.values()){
        try{
          if(!entry || entry.kind !== 'file') continue;
          var name = String(entry.name || '');
          var m = /^(.+)_([0-9]+)\.json$/i.exec(name);
          if(!m) continue;
          var sym = String(m[1] || '').trim();
          if(!sym) continue;
          if(seen[sym]) continue;
          seen[sym] = true;
          symbols.push({ dataset: inferDatasetFromSymbol(sym), symbol: sym });
        } catch(_e){}
      }
    } catch(_e){}
    // Ensure stable order.
    symbols.sort(function(a,b){ return String(a.symbol||'').localeCompare(String(b.symbol||'')); });
    return { symbols: symbols, _generated: true };
  }

  async function readJsonFromStatic(relPath){
    // Prefer dirHandle when present (file:// safe), else fetch from STATIC_BASE.
    var p = String(relPath || '').replace(/^\/+/,'');
    // In-memory override (file picker)
    if(/^bars\//.test(p)){
      var m = /^bars\/(.+)_([0-9]+)\.json$/.exec(p);
      if(m){
        var k = barsKey(m[1], m[2]);
        if(_staticBarsByKey && _staticBarsByKey[k]) return _staticBarsByKey[k];
      }
    }
    if(p === 'catalog.json' && _staticGeneratedCatalog) return _staticGeneratedCatalog;
    if(_staticDirMode === 'root' && _staticRootDirHandle){
      var txt0 = await readTextFromDirHandle(_staticRootDirHandle, p);
      return JSON.parse(txt0);
    }
    if(_staticDirMode === 'bars' && _staticBarsDirHandle){
      if(p === 'catalog.json'){
        // No catalog.json in bars-only mode; return generated.
        var gen = await generateCatalogFromBarsDir(_staticBarsDirHandle);
        _staticGeneratedCatalog = gen;
        return gen;
      }
      // Map bars/<file> to <file> in selected bars directory.
      var p2 = p;
      if(/^bars\//.test(p2)) p2 = p2.replace(/^bars\//,'');
      var txt1 = await readTextFromDirHandle(_staticBarsDirHandle, p2);
      return JSON.parse(txt1);
    }
    var url = joinPath(STATIC_BASE, p);
    var res = await fetch(url, { method:'GET', cache:'no-store' });
    if(!res.ok) throw new Error('HTTP ' + res.status + ' for ' + url);
    return await res.json();
  }

  async function loadStaticCatalog(){
    // Expected: { symbols: [{dataset,symbol}, ...] } or a plain array of {dataset,symbol}.
    var j = await readJsonFromStatic('catalog.json');
    var arr = [];
    if(Array.isArray(j)) arr = j;
    else if(j && Array.isArray(j.symbols)) arr = j.symbols;
    var out = [];
    for(var i=0;i<arr.length;i++){
      var item = arr[i];
      if(typeof item === 'string'){
        var sym = String(item || '').trim();
        if(!sym) continue;
        out.push({ symbol: sym, dataset: '', synthetic: false });
        continue;
      }
      if(item && typeof item === 'object' && typeof item.symbol === 'string'){
        out.push({
          symbol: String(item.symbol || '').trim(),
          dataset: String(item.dataset || '').trim(),
          synthetic: !!item.synthetic
        });
      }
    }
    return out;
  }

  async function loadStaticBars(symbol, bar_s){
    var sym = String(symbol || '').trim();
    var bs = Math.floor(Number(bar_s) || 60);
    if(!sym) throw new Error('Missing symbol');
    if(!Number.isFinite(bs) || bs <= 0) throw new Error('Invalid bar_s');
    var k = barsKey(sym, bs);
    if(_staticBarsByKey && _staticBarsByKey[k]) return _staticBarsByKey[k];
    var name = 'bars/' + sym + '_' + bs + '.json';
    var j = await readJsonFromStatic(name);
    rememberBarsPayload(j);
    return j;
  }

  // UI config persistence (static mode): localStorage instead of server.
  var UI_CFG_KEY = 'char_ui_config_v1';

  function coerceBool(v, fallback){
    if(v === true || v === false) return v;
    if(v === 1 || v === 0) return !!v;
    var s = (v === null || v === undefined) ? '' : String(v).toLowerCase();
    if(s === 'true' || s === '1') return true;
    if(s === 'false' || s === '0') return false;
    return !!fallback;
  }

  function coerceInt(v, fallback){
    var n = Number(v);
    if(!Number.isFinite(n)) return Number(fallback);
    return Math.floor(n);
  }

  var persist = {
    enabled: false,
    applying: false,
    hadConfig: false,
    saveTimer: null
  };

  async function fetchUiConfig(){
    try{
      var raw = localStorage.getItem(UI_CFG_KEY);
      if(!raw) return null;
      var j = JSON.parse(raw);
      if(!j || typeof j !== 'object') return null;
      return j;
    } catch(_e){
      return null;
    }
  }

  function getTicker(){
    var t = String(state.ticker || '').trim();
    if(t) return t;
    if(ui.tickerLabel){
      var tt = String(ui.tickerLabel.textContent || '').trim();
      if(tt) return tt;
    }
    return 'ES';
  }

  function getSymbol(){
    var s = String(state.symbol || '').trim();
    if(s) return s;
    if(ui.symbolLabel){
      var t = String(ui.symbolLabel.textContent || '').trim();
      if(t) return t;
    }
    return 'ESZ5';
  }

  function closeTickerMenu(){
    if(!ui.tickerDD) return;
    ui.tickerDD.classList.remove('open');
    if(ui.tickerBtn) ui.tickerBtn.setAttribute('aria-expanded','false');
  }

  function toggleTickerMenu(){
    if(!ui.tickerDD || !ui.tickerBtn) return;
    var open = ui.tickerDD.classList.toggle('open');
    ui.tickerBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }

  function setTicker(ticker){
    var v = String(ticker || '').trim().toUpperCase();
    if(!v) v = 'ES';
    state.ticker = v;
    if(ui.tickerLabel) ui.tickerLabel.textContent = v;
    if(ui.tickerMenu){
      var items = ui.tickerMenu.querySelectorAll('.ddItem');
      for(var i=0;i<items.length;i++){
        var it = items[i];
        var val = it.getAttribute('data-value');
        if(val === v) it.classList.add('sel');
        else it.classList.remove('sel');
      }
    }
  }

  function ensureTickerItem(ticker){
    if(!ui.tickerMenu) return;
    var v = String(ticker || '').trim().toUpperCase();
    if(!v) return;
    var items = ui.tickerMenu.querySelectorAll('.ddItem');
    for(var i=0;i<items.length;i++){
      if(items[i].getAttribute('data-value') === v) return;
    }
    var div = document.createElement('div');
    div.className = 'ddItem mono';
    div.setAttribute('role','option');
    div.setAttribute('data-value', v);
    div.textContent = v;
    ui.tickerMenu.appendChild(div);
  }

  function closeSymbolMenu(){
    if(!ui.symbolDD) return;
    ui.symbolDD.classList.remove('open');
    if(ui.symbolBtn) ui.symbolBtn.setAttribute('aria-expanded','false');
  }

  function toggleSymbolMenu(){
    if(!ui.symbolDD || !ui.symbolBtn) return;
    var open = ui.symbolDD.classList.toggle('open');
    ui.symbolBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }

  function setSymbol(sym){
    var v = String(sym || '').trim();
    if(!v) v = 'ESZ5';
    state.symbol = v;
    if(ui.symbolLabel) ui.symbolLabel.textContent = v;
    if(ui.symbolMenu){
      var items = ui.symbolMenu.querySelectorAll('.ddItem');
      for(var i=0;i<items.length;i++){
        var it = items[i];
        var val = it.getAttribute('data-value');
        if(val === v) it.classList.add('sel');
        else it.classList.remove('sel');
      }
    }
  }

  function symbolDisplayText(sym){
    var s = String(sym || '').trim();
    if(!s) return '';
    // Generic continuous labels: <ROOT>_CONT or <ROOT>1!
    if(/^[A-Z0-9]+_CONT$/.test(s)){
      var root = s.replace(/_CONT$/,'');
      return s + ' (Continuous ' + root + ' \u2013 calendar roll)';
    }
    if(/^[A-Z0-9]+1!$/.test(s)){
      var root2 = s.replace(/1!$/,'');
      return s + ' (Continuous ' + root2 + ' \u2013 calendar roll)';
    }
    // Legacy explicit labels (kept for a nicer first impression on ES).
    if(s === 'ESU5') return 'ESU5 (Sep 2025 \u2013 single contract)';
    if(s === 'ESZ5') return 'ESZ5 (Dec 2025 \u2013 single contract)';
    return s;
  }

  function ensureSymbolItem(sym){
    if(!ui.symbolMenu) return;
    var v = String(sym || '').trim();
    if(!v) return;
    var items = ui.symbolMenu.querySelectorAll('.ddItem');
    for(var i=0;i<items.length;i++){
      if(items[i].getAttribute('data-value') === v) return;
    }
    var div = document.createElement('div');
    div.className = 'ddItem mono';
    div.setAttribute('role','option');
    div.setAttribute('data-value', v);
    div.textContent = symbolDisplayText(v);
    ui.symbolMenu.appendChild(div);
  }

  async function fetchSymbolCatalog(){
    try{
      if(STATIC_MODE){
        return await loadStaticCatalog();
      }
      // API mode: if we're in single mode, synthesize a 1-item catalog.
      var symQ = String(getQueryParam('symbol', '') || '').trim();
      if(SINGLE_MODE && symQ){
        return [{ symbol: symQ, dataset: (inferDatasetFromSymbol(symQ) || symQ), synthetic: false }];
      }
      // Optional: if you later add an endpoint that returns catalog items, this will use it.
      // Expected: [{dataset,symbol}, ...] or {symbols:[...]}
      try{
        var url = buildUrl(API_BASE, '/api/symbols', {});
        var res = await fetch(url, { method:'GET', cache:'no-store' });
        if(res && res.ok){
          var j = await res.json();
          if(Array.isArray(j)) return j;
          if(j && Array.isArray(j.symbols)) return j.symbols;
        }
      } catch(_e2){}
      if(symQ) return [{ symbol: symQ, dataset: (inferDatasetFromSymbol(symQ) || symQ), synthetic: false }];
      return [];
    } catch(_e){
      return [];
    }
  }

  async function fetchMetaForSymbol(symbol){
    try{
      // In static mode, dataset bounds come from the bars file payload.
      return null;
    } catch(_e){
      return null;
    }
  }

  function buildCatalogIndex(items){
    // Returns { datasets:[], byDataset:{DS:[symbols...]}, datasetBySymbol:{sym:DS} }
    var byDataset = {};
    var datasetBySymbol = {};
    for(var i=0;i<items.length;i++){
      var it = items[i];
      if(!it) continue;
      var sym = String(it.symbol || '').trim();
      if(!sym) continue;
      var ds = String(it.dataset || '').trim().toUpperCase();
      // Fallback: infer ES by known synthetic/contract patterns if dataset missing.
      if(!ds){
        if(sym === 'ES_CONT' || sym === 'ES1!' || /^ES[A-Z]\\d$/.test(sym)) ds = 'ES';
      }
      if(!ds) continue;
      if(!byDataset[ds]) byDataset[ds] = [];
      byDataset[ds].push(sym);
      datasetBySymbol[sym] = ds;
    }
    var datasets = Object.keys(byDataset).sort();
    for(var k=0;k<datasets.length;k++){
      var d = datasets[k];
      // Unique + stable order.
      var seen = {};
      var dedup = [];
      var arr = byDataset[d] || [];
      for(var j=0;j<arr.length;j++){
        var s2 = String(arr[j] || '').trim();
        if(!s2 || seen[s2]) continue;
        seen[s2] = true;
        dedup.push(s2);
      }
      // Prefer ES_CONT at top for ES.
      if(d === 'ES'){
        dedup.sort();
        if(dedup.indexOf('ES_CONT') >= 0){
          dedup = ['ES_CONT'].concat(dedup.filter(function(x){ return x !== 'ES_CONT'; }));
        }
      } else {
        dedup.sort();
      }
      byDataset[d] = dedup;
    }
    return { datasets: datasets, byDataset: byDataset, datasetBySymbol: datasetBySymbol };
  }

  function refreshSymbolMenuForTicker(){
    if(!ui.symbolMenu) return;
    var ds = String(getTicker() || 'ES').trim().toUpperCase();
    var catalog = state._catalog || null;
    var syms = (catalog && catalog.byDataset && catalog.byDataset[ds]) ? catalog.byDataset[ds] : [];
    ui.symbolMenu.innerHTML = '';
    for(var i=0;i<syms.length;i++) ensureSymbolItem(syms[i]);
  }

  function chooseDefaultSymbolForTicker(ds){
    var d = String(ds || '').trim().toUpperCase();
    var catalog = state._catalog || null;
    var syms = (catalog && catalog.byDataset && catalog.byDataset[d]) ? catalog.byDataset[d] : [];
    if(!syms || !syms.length) return (d === 'ES' ? 'ES_CONT' : '');
    if(d === 'ES' && syms.indexOf('ES_CONT') >= 0) return 'ES_CONT';
    return String(syms[0] || '').trim();
  }

  function applyUiConfig(cfg){
    if(!cfg || typeof cfg !== 'object') return false;
    persist.applying = true;
    try{
      if(typeof cfg.ticker === 'string' && cfg.ticker.trim()){
        ensureTickerItem(cfg.ticker.trim());
        setTicker(cfg.ticker.trim());
        refreshSymbolMenuForTicker();
      }
      if(typeof cfg.symbol === 'string' && cfg.symbol.trim()){
        ensureSymbolItem(cfg.symbol.trim());
        setSymbol(cfg.symbol.trim());
      }

      // Always-on options (removed from UI): ignore persisted values.
      if(ui.showBands && cfg.showBands !== undefined) ui.showBands.checked = coerceBool(cfg.showBands, ui.showBands.checked);
      if(ui.showCandles && cfg.showCandles !== undefined) ui.showCandles.checked = coerceBool(cfg.showCandles, ui.showCandles.checked);
      if(ui.nocross && cfg.nocross !== undefined) ui.nocross.checked = coerceBool(cfg.nocross, ui.nocross.checked);
      if(ui.fills && cfg.fills !== undefined) ui.fills.checked = coerceBool(cfg.fills, ui.fills.checked);
      if(ui.smooth && cfg.smooth !== undefined) ui.smooth.checked = coerceBool(cfg.smooth, ui.smooth.checked);
      if(ui.outer && cfg.outer !== undefined) ui.outer.checked = coerceBool(cfg.outer, ui.outer.checked);
      if(ui.avgline && cfg.avgline !== undefined) ui.avgline.checked = coerceBool(cfg.avgline, ui.avgline.checked);
      // Session shading toggles (footer)
      if(ui.sessPreMarket && cfg.sess_pre_market !== undefined) ui.sessPreMarket.checked = coerceBool(cfg.sess_pre_market, ui.sessPreMarket.checked);
      if(ui.sessAfterHours && cfg.sess_after_hours !== undefined) ui.sessAfterHours.checked = coerceBool(cfg.sess_after_hours, ui.sessAfterHours.checked);
      if(ui.sessClosed && cfg.sess_closed !== undefined) ui.sessClosed.checked = coerceBool(cfg.sess_closed, ui.sessClosed.checked);
      // Overlays (EMA/VWAP)
      if(ui.indEma9 && cfg.ind_ema9 !== undefined) ui.indEma9.checked = coerceBool(cfg.ind_ema9, ui.indEma9.checked);
      if(ui.indEma21 && cfg.ind_ema21 !== undefined) ui.indEma21.checked = coerceBool(cfg.ind_ema21, ui.indEma21.checked);
      if(ui.indEma50 && cfg.ind_ema50 !== undefined) ui.indEma50.checked = coerceBool(cfg.ind_ema50, ui.indEma50.checked);
      if(ui.indVwap && cfg.ind_vwap !== undefined) ui.indVwap.checked = coerceBool(cfg.ind_vwap, ui.indVwap.checked);
      // Candle bias UI is intentionally removed.

      if(cfg.bar_s !== undefined){
        var ww = clamp(coerceInt(cfg.bar_s, 60), 60, 86400);
        ww = snapToPreset(ww);
        state.windowSec = ww;
        if(ui.window) ui.window.value = String(ww);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(ww);
        syncBarPresetUi();
      }

      // Scale preset (requested window span).
      // Kept intentionally simple: store as a small key ('1d','5d','1m','3m').
      if(typeof cfg.span === 'string' && cfg.span.trim()){
        setSpanPreset(cfg.span.trim(), { skipLoad: true, skipSave: true, skipUrl: true });
      }

      if(typeof cfg.candleStyle === 'string' && cfg.candleStyle){
        setCandleStyle(cfg.candleStyle);
      }

      syncCandleStyleEnabled();
      enforceAlwaysOnOptions();
      return true;
    } catch(_e){
      return false;
    } finally {
      persist.applying = false;
    }
  }

  function collectUiConfig(){
    return {
      version: 1,
      // saved_at is set server-side too, but keeping it here is handy for debugging.
      saved_at: new Date().toISOString().replace('.000Z','Z'),
      ticker: getTicker(),
      symbol: getSymbol(),
      bar_s: Math.floor(Number(state.windowSec) || 60),
      span: String(state.spanPreset || '1d'),
      auto_w: !!(ui.autoW && ui.autoW.checked),
      showBands: !!(ui.showBands && ui.showBands.checked),
      showCandles: !!(ui.showCandles && ui.showCandles.checked),
      candleStyle: String(state.candleStyle || 'std'),
      showVolume: !!(ui.showVolume && ui.showVolume.checked),
      grid: !!(ui.grid && ui.grid.checked),
      scale: !!(ui.scale && ui.scale.checked),
      nocross: !!(ui.nocross && ui.nocross.checked),
      fills: !!(ui.fills && ui.fills.checked),
      smooth: !!(ui.smooth && ui.smooth.checked),
      outer: !!(ui.outer && ui.outer.checked),
      avgline: !!(ui.avgline && ui.avgline.checked),
      sess_pre_market: !!(ui.sessPreMarket && ui.sessPreMarket.checked),
      sess_after_hours: !!(ui.sessAfterHours && ui.sessAfterHours.checked),
      sess_closed: !!(ui.sessClosed && ui.sessClosed.checked),
      ind_ema9: !!(ui.indEma9 && ui.indEma9.checked),
      ind_ema21: !!(ui.indEma21 && ui.indEma21.checked),
      ind_ema50: !!(ui.indEma50 && ui.indEma50.checked),
      ind_vwap: !!(ui.indVwap && ui.indVwap.checked),
      ind_candle_bias: false
    };
  }

  function scheduleSaveUiConfig(){
    if(!persist.enabled || persist.applying) return;
    if(persist.saveTimer) clearTimeout(persist.saveTimer);
    persist.saveTimer = setTimeout(function(){
      try{
        localStorage.setItem(UI_CFG_KEY, JSON.stringify(collectUiConfig()));
      } catch(_e){}
    }, 250);
  }

  // Robust rounded-rect path: never passes a negative radius to arcTo.
  function roundRect(ctx, x, y, w, h, r){
    if(!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return;
    if(w < 0){ x += w; w = -w; }
    if(h < 0){ y += h; h = -h; }
    if(w <= 0 || h <= 0) return;
    var rr = Math.max(0, Math.min(Number.isFinite(r) ? r : 0, w/2, h/2));
    ctx.beginPath();
    if(rr === 0){ ctx.rect(x, y, w, h); return; }
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // Stroke a polyline with gap support. smooth=true uses quadratic smoothing via midpoints.
  function strokePolyline(ctx, pts, style, width, smooth, dash){
    if(!pts || pts.length < 2) return;
    ctx.save();
    ctx.strokeStyle = style;
    ctx.lineWidth = width;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    if(Array.isArray(dash)) ctx.setLineDash(dash);

    var seg = [];

    function strokeSeg(segPts){
      if(segPts.length < 2) return;
      ctx.beginPath();
      if(!smooth || segPts.length < 3){
        ctx.moveTo(segPts[0][0], segPts[0][1]);
        for(var i=1;i<segPts.length;i++) ctx.lineTo(segPts[i][0], segPts[i][1]);
        ctx.stroke();
        return;
      }
      ctx.moveTo(segPts[0][0], segPts[0][1]);
      for(var j=1;j<segPts.length-1;j++){
        var p1 = segPts[j];
        var p2 = segPts[j+1];
        var mx = (p1[0] + p2[0]) / 2;
        var my = (p1[1] + p2[1]) / 2;
        ctx.quadraticCurveTo(p1[0], p1[1], mx, my);
      }
      var pn1 = segPts[segPts.length-2];
      var pn = segPts[segPts.length-1];
      ctx.quadraticCurveTo(pn1[0], pn1[1], pn[0], pn[1]);
      ctx.stroke();
    }

    for(var k=0;k<pts.length;k++){
      var p = pts[k];
      var px = p[0];
      var py = p[1];
      if(!Number.isFinite(px) || !Number.isFinite(py)){
        strokeSeg(seg);
        seg = [];
        continue;
      }
      seg.push([px,py]);
    }
    strokeSeg(seg);

    ctx.restore();
  }

  // Fill between two polylines with gap support.
  function fillBetween(ctx, upperPts, lowerPts, fillStyle, smooth){
    var n = Math.min(upperPts.length, lowerPts.length);
    if(n < 2) return;

    ctx.save();
    ctx.fillStyle = fillStyle;

    var segUpper = [];
    var segLower = [];

    function appendSmoothLineTo(pts){
      for(var i=1;i<pts.length-1;i++){
        var p1 = pts[i];
        var p2 = pts[i+1];
        var mx = (p1[0] + p2[0]) / 2;
        var my = (p1[1] + p2[1]) / 2;
        ctx.quadraticCurveTo(p1[0], p1[1], mx, my);
      }
      var pn1 = pts[pts.length-2];
      var pn = pts[pts.length-1];
      ctx.quadraticCurveTo(pn1[0], pn1[1], pn[0], pn[1]);
    }

    function flush(){
      if(segUpper.length < 2 || segLower.length < 2){ segUpper = []; segLower = []; return; }
      ctx.beginPath();
      ctx.moveTo(segUpper[0][0], segUpper[0][1]);
      if(!smooth || segUpper.length < 3){
        for(var i=1;i<segUpper.length;i++) ctx.lineTo(segUpper[i][0], segUpper[i][1]);
      } else {
        appendSmoothLineTo(segUpper);
      }
      var rev = segLower.slice().reverse();
      ctx.lineTo(rev[0][0], rev[0][1]);
      if(!smooth || rev.length < 3){
        for(var j=1;j<rev.length;j++) ctx.lineTo(rev[j][0], rev[j][1]);
      } else {
        appendSmoothLineTo(rev);
      }
      ctx.closePath();
      ctx.fill();
      segUpper = []; segLower = [];
    }

    for(var k=0;k<n;k++){
      var ux = upperPts[k][0], uy = upperPts[k][1];
      var lx = lowerPts[k][0], ly = lowerPts[k][1];
      var ok = Number.isFinite(ux) && Number.isFinite(uy) && Number.isFinite(lx) && Number.isFinite(ly);
      if(!ok){ flush(); continue; }
      segUpper.push([ux,uy]);
      segLower.push([lx,ly]);
    }
    flush();

    ctx.restore();
  }

  function orderSig(d){
    var arr = [
      ['l', d.l],
      ['o', d.o],
      ['c', d.c],
      ['h', d.h]
    ].sort(function(a,b){ return a[1]-b[1]; });
    return arr.map(function(x){ return x[0]; }).join('');
  }

  function formatWindow(sec){
    if(sec >= 3600 && sec % 3600 === 0) return (sec/3600) + 'h';
    if(sec >= 3600){
      var hh = Math.floor(sec/3600);
      var rem = sec % 3600;
      if(rem % 60 === 0) return hh + 'h' + (rem/60) + 'm';
      var mm = Math.floor(rem/60);
      var ss = rem % 60;
      return hh + 'h' + mm + 'm' + ss + 's';
    }
    if(sec < 60) return sec + 's';
    if(sec % 60 === 0) return (sec/60) + 'm';
    var m = Math.floor(sec/60);
    var s = sec % 60;
    return m + 'm' + s + 's';
  }

  // Display contract:
  // - This app runs on 1-minute Alpaca bars; minimum resolution is 60s.
  // Keep this list ordered ascending.
  var SNAP_PRESETS = [60, 300, 1800, 3600, 14400, 86400];

  // Auto W targets roughly this many candles on screen.
  // Clamp is applied at call-sites to keep behavior stable if this value changes.
  var AUTO_W_TARGET_BARS = 400; // target ~300–500 candles visible

  // Default initial window when URL doesn't specify start/end and full history isn't requested.
  // This avoids "full-history bootstrap" which forces coarse bars + slow loads.
  var DEFAULT_INIT_SPAN_MS = 24 * 60 * 60 * 1000; // 24h (increase to 7d if you prefer)

  function parseIsoToMs(s){
    // Accept ISO strings with Z or offsets. If timezone-less, interpret as UTC.
    var str = String(s || '').trim();
    if(!str) return NaN;
    var ms = Date.parse(str);
    if(Number.isFinite(ms)) return ms;
    // If missing timezone, Date.parse can be inconsistent across environments; treat as UTC.
    if(!/[zZ]|[+\-]\d\d:\d\d$/.test(str)) ms = Date.parse(str + 'Z');
    return ms;
  }

  function snapToPreset(sec){
    var best = SNAP_PRESETS[0];
    var bestD = Math.abs(sec - best);
    for(var i=0;i<SNAP_PRESETS.length;i++){
      var p = SNAP_PRESETS[i];
      var d = Math.abs(sec - p);
      if(d < bestD){ bestD = d; best = p; }
    }
    return best;
  }

  function syncBarPresetUi(){
    try{
      var cur = snapToPreset(clamp(Number(state.windowSec || (ui.window ? ui.window.value : 60) || 60), 60, 86400));
      var els = document.querySelectorAll('input[type="radio"][name="windowPreset"]');
      for(var i=0;i<els.length;i++){
        var el = els[i];
        if(!el) continue;
        el.checked = (Number(el.value) === cur);
      }
    } catch(_e){}
  }

  function snapCeilToPreset(sec){
    var s = Math.max(60, Math.floor(Number(sec) || 60));
    for(var i=0;i<SNAP_PRESETS.length;i++){
      if(SNAP_PRESETS[i] >= s) return SNAP_PRESETS[i];
    }
    return SNAP_PRESETS[SNAP_PRESETS.length-1];
  }

  function recommendBarSec(spanMs, limit, targetBars){
    var span = Number(spanMs);
    if(!Number.isFinite(span) || span <= 0) return 60;
    var spanSec = Math.max(1, Math.floor(span / 1000));
    var tgt = Math.max(50, Math.floor(Number(targetBars) || 800));
    var lim = Math.floor(Number(limit) || 0);
    var minForLimit = (lim > 0) ? Math.max(1, Math.ceil(spanSec / lim)) : 1;
    var raw = Math.max(1, Math.floor(spanSec / tgt), minForLimit);
    return clamp(snapCeilToPreset(raw), 60, 86400);
  }

  function getVisibleSpanMs(requestSpanMs){
    // Visible time span is driven by zoom: visibleSpan = requestSpan / xZoom.
    var span = Number(requestSpanMs);
    if(!Number.isFinite(span) || span <= 0) return NaN;
    var z = Number(state.xZoom);
    if(!Number.isFinite(z) || z <= 0) z = 1;
    return span / z;
  }

  function recommendBarSecForVisibleSpan(visibleSpanMs, effMaxBars){
    var target = clamp(Math.floor(Number(AUTO_W_TARGET_BARS) || 400), 150, 800);
    return recommendBarSec(visibleSpanMs, effMaxBars, target);
  }

  // chart state
  var canvas = document.getElementById('c');
  var ctx = canvas.getContext('2d');

  var ui = {
    tickerDD: document.getElementById('tickerDD'),
    tickerBtn: document.getElementById('tickerBtn'),
    tickerMenu: document.getElementById('tickerMenu'),
    tickerLabel: document.getElementById('tickerLabel'),
    // Sidebar indicator toggles
    indEma9: document.getElementById('indEma9'),
    indEma21: document.getElementById('indEma21'),
    indEma50: document.getElementById('indEma50'),
    indVwap: document.getElementById('indVwap'),
    indCandleBias: null,
    practiceBtn: document.getElementById('practiceBtn'),
    practicePauseBtn: document.getElementById('practicePauseBtn'),
    practiceResetBtn: document.getElementById('practiceResetBtn'),
    practiceSpeed: document.getElementById('practiceSpeed'),
    practiceSpeedLabel: document.getElementById('practiceSpeedLabel'),
    practiceStatus: document.getElementById('practiceStatus'),
    practiceScore: document.getElementById('practiceScore'),
    practiceQty: document.getElementById('practiceQty'),
    practiceQtyLabel: document.getElementById('practiceQtyLabel'),
    practiceLongBtn: document.getElementById('practiceLongBtn'),
    practiceShortBtn: document.getElementById('practiceShortBtn'),
    practiceFlattenBtn: document.getElementById('practiceFlattenBtn'),
    practiceHistoryBtn: document.getElementById('practiceHistoryBtn'),
    practiceHistoryStatus: document.getElementById('practiceHistoryStatus'),
    historyModal: document.getElementById('historyModal'),
    historyCloseBtn: document.getElementById('historyCloseBtn'),
    historyRefreshBtn: document.getElementById('historyRefreshBtn'),
    historyModalStatus: document.getElementById('historyModalStatus'),
    historyTableWrap: document.getElementById('historyTableWrap'),
    historyViewCardsBtn: document.getElementById('historyViewCardsBtn'),
    historyViewLedgerBtn: document.getElementById('historyViewLedgerBtn'),
    historyViewMatrixBtn: document.getElementById('historyViewMatrixBtn'),
    window: document.getElementById('window'),
    // Some checkboxes may be removed from the UI; we keep "virtual" controls so existing
    // logic can continue to read ui.*.checked.
    autoW: document.getElementById('autoW'),
    grid: document.getElementById('grid'),
    scale: document.getElementById('scale'),
    nocross: document.getElementById('nocross'),
    fills: document.getElementById('fills'),
    smooth: document.getElementById('smooth'),
    outer: document.getElementById('outer'),
    avgline: document.getElementById('avgline'),
    showBands: document.getElementById('showBands'),
    showCandles: document.getElementById('showCandles'),
    showVolume: document.getElementById('showVolume'),
    candleStyleDD: document.getElementById('candleStyleDD'),
    candleStyleBtn: document.getElementById('candleStyleBtn'),
    candleStyleMenu: document.getElementById('candleStyleMenu'),
    candleStyleLabel: document.getElementById('candleStyleLabel'),
    windowVal: document.getElementById('windowVal'),
    regen: document.getElementById('regen'),
    // Footer session toggles
    sessPreMarket: document.getElementById('sessPreMarket'),
    sessAfterHours: document.getElementById('sessAfterHours'),
    sessClosed: document.getElementById('sessClosed')
  };

  function makeAlwaysOnCheckbox(){
    // Minimal interface used by the app: `.checked` and `.addEventListener`.
    // We keep these as virtual controls so we can remove checkboxes from the UI
    // while preserving existing code paths.
    return {
      checked: true,
      disabled: true,
      addEventListener: function(){ /* no-op */ }
    };
  }

  function enforceAlwaysOnOptions(){
    if(ui.showVolume) ui.showVolume.checked = true;
    if(ui.grid) ui.grid.checked = true;
    if(ui.scale) ui.scale.checked = true;
  }

  // Ensure virtual always-on controls exist even though their checkboxes may be removed from the UI.
  // Auto W is user-controllable; the others are forced on.
  if(!ui.autoW) ui.autoW = makeAlwaysOnCheckbox();
  if(!ui.showVolume) ui.showVolume = makeAlwaysOnCheckbox();
  if(!ui.grid) ui.grid = makeAlwaysOnCheckbox();
  if(!ui.scale) ui.scale = makeAlwaysOnCheckbox();
  enforceAlwaysOnOptions();

  // Scale preset (requested window span) helpers.
  var SPAN_PRESETS = {
    '1d': 24 * 60 * 60 * 1000,
    '5d': 5 * 24 * 60 * 60 * 1000,
    '1m': 30 * 24 * 60 * 60 * 1000,
    '3m': 90 * 24 * 60 * 60 * 1000,
    // Longer presets (future-proof). These are approximations; exact calendar months/years
    // vary, but this is sufficient for bucket sizing + navigation UX.
    '6m': 180 * 24 * 60 * 60 * 1000,
    '1y': 365 * 24 * 60 * 60 * 1000,
    '3y': 3 * 365 * 24 * 60 * 60 * 1000,
    '5y': 5 * 365 * 24 * 60 * 60 * 1000,
    // Special: "show everything available" (resolved against dataset bounds when known).
    'all': Number.POSITIVE_INFINITY
  };
  var SPAN_PRESET_ORDER = ['1d','5d','1m','3m','6m','1y','3y','5y','all'];

  function normalizeSpanPreset(v){
    var k = String(v || '').trim().toLowerCase();
    if(SPAN_PRESETS[k]) return k;
    return '1d';
  }

  function inferSpanPresetFromSpanMs(spanMs){
    // "Reverse bracketing" (round-up / ceiling):
    // - If span is between 5D and 1M, select 1M (even if not exact).
    // - This matches the user expectation that the selector reflects the nearest *bucket above*.
    var s = Number(spanMs);
    if(!Number.isFinite(s) || s <= 0) return '1d';
    // If span effectively covers the full dataset history, call it "ALL".
    // (This keeps the selector truthful when we auto-expand to full history.)
    try{
      var ds0 = Number(state && state.datasetStartMs);
      var de0 = Number(state && state.datasetEndMs);
      var deMax = Number(state && state.datasetMaxEndMs);
      var endForHistory = (Number.isFinite(deMax) && Number.isFinite(ds0) && deMax > ds0) ? deMax : de0;
      if(Number.isFinite(ds0) && Number.isFinite(endForHistory) && endForHistory > ds0){
        var datasetSpan = endForHistory - ds0;
        var slack = 6 * 60 * 60 * 1000; // 6h
        if(s + slack >= datasetSpan) return 'all';
      }
    } catch(_e){}
    var items = [];
    for(var ii=0; ii<SPAN_PRESET_ORDER.length; ii++){
      var kk = SPAN_PRESET_ORDER[ii];
      var mm = Number(SPAN_PRESETS[kk]);
      if(Number.isFinite(mm) && mm > 0) items.push({ k: kk, ms: mm });
    }
    items.sort(function(a,b){ return a.ms - b.ms; });
    if(!items.length) return '1d';
    for(var i=0;i<items.length;i++){
      if(s <= items[i].ms) return items[i].k;
    }
    return items[items.length-1].k;
  }

  function updateSpanPresetAvailability(){
    // Disable presets that exceed available dataset history.
    // This is both UX (avoid "clickable but no data") and an implicit hint about history limits.
    try{
      var ds0 = Number(state && state.datasetStartMs);
      var de0 = Number(state && state.datasetEndMs);
      var deMax = Number(state && state.datasetMaxEndMs);
      // In replay mode, datasetEndMs is intentionally clamped to the current cursor to keep the chart future-blind.
      // Use datasetMaxEndMs (full history end) for availability so clicking Play doesn't force a smaller span preset.
      var endForHistory = (Number.isFinite(deMax) && Number.isFinite(ds0) && deMax > ds0) ? deMax : de0;
      if(!Number.isFinite(ds0) || !Number.isFinite(endForHistory) || endForHistory <= ds0) return;
      var datasetSpan = endForHistory - ds0;
      // Tolerance for "almost exactly N days" datasets (weekends, partial sessions, etc.)
      var slack = 6 * 60 * 60 * 1000; // 6h
      var keys = SPAN_PRESET_ORDER.slice();
      var enabled = {};
      for(var i=0;i<keys.length;i++){
        var k = keys[i];
        var need = Number(SPAN_PRESETS[k]) || 0;
        var ok = (k === 'all') ? true : ((need <= 0) ? true : ((datasetSpan + slack) >= need));
        // Replay: we set a default span preset on start, but do NOT hard-lock the UI.
        enabled[k] = !!ok;
        // Update DOM controls if present.
        var input = document.querySelector('input[type="radio"][name="spanPreset"][value="' + k + '"]');
        if(input){
          input.disabled = !ok;
          var lab = input.closest ? input.closest('label') : null;
          if(lab){
            if(!ok) lab.classList.add('isDisabled');
            else lab.classList.remove('isDisabled');
            // Hide non-applicable options entirely (instead of showing disabled/grayed out).
            if(k !== 'all'){
              if(!ok) lab.classList.add('isHidden');
              else lab.classList.remove('isHidden');
            } else {
              // ALL is always applicable.
              lab.classList.remove('isHidden');
            }
            lab.setAttribute('aria-disabled', (!ok) ? 'true' : 'false');
          }
        }
      }
      // Keep a copy for other logic (e.g. reverse-bracketing) to consult.
      state._spanPresetEnabled = enabled;

      // If current preset is no longer available, fall back to the largest available.
      var cur = normalizeSpanPreset(state.spanPreset || '1d');
      if(!enabled[cur]){
        var pick = null;
        for(var j=keys.length-1; j>=0; j--){
          if(enabled[keys[j]]){ pick = keys[j]; break; }
        }
        if(!pick) pick = '1d';
        // Only update indicator + persistence here; do not force a refetch loop.
        state.spanPreset = pick;
        state.viewSpanMs = Number(SPAN_PRESETS[pick]) || DEFAULT_INIT_SPAN_MS;
        syncSpanPresetUi();
        updateUrlBarSize();
        scheduleSaveUiConfig();
      } else {
        // Keep UI consistent (e.g. after first bounds arrive).
        syncSpanPresetUi();
      }
    } catch(_e){}
  }

  function currentEffectiveVisibleSpanMs(){
    // Effective visible span is driven by zoom: visibleSpan = requestedSpan / xZoom.
    // This matches user expectation when zooming in/out: the selector should reflect what you see.
    try{
      if(!Number.isFinite(state.viewSpanMs) || state.viewSpanMs <= 0) return NaN;
      return getVisibleSpanMs(state.viewSpanMs);
    } catch(_e){
      return NaN;
    }
  }

  function syncSpanPresetFromNavigation(opts){
    // Keep the active radio (and optionally persistence) in sync with how the user has navigated.
    // IMPORTANT: this does NOT change the span; it only updates the indicator + persistence.
    var o = opts || {};
    var span = currentEffectiveVisibleSpanMs();
    if(!Number.isFinite(span) || span <= 0) return;
    // Choose the "rounded up" preset, but never choose a disabled preset.
    var inferred = inferSpanPresetFromSpanMs(span);
    try{
      var enabledMap = (state && state._spanPresetEnabled) ? state._spanPresetEnabled : null;
      function isEnabled(k){
        if(enabledMap && enabledMap[k] !== undefined) return !!enabledMap[k];
        var el = document.querySelector('input[type="radio"][name="spanPreset"][value="' + k + '"]');
        return el ? !el.disabled : true;
      }
      if(!isEnabled(inferred)){
        // Find the smallest enabled preset >= current span (round-up among enabled),
        // else fall back to the largest enabled.
        var items2 = [];
        for(var ii=0; ii<SPAN_PRESET_ORDER.length; ii++){
          var kk = SPAN_PRESET_ORDER[ii];
          var mm = Number(SPAN_PRESETS[kk]);
          if(Number.isFinite(mm) && mm > 0) items2.push({ k: kk, ms: mm });
        }
        items2.sort(function(a,b){ return a.ms - b.ms; });
        var pick = null;
        for(var j=0;j<items2.length;j++){
          if(span <= items2[j].ms && isEnabled(items2[j].k)){ pick = items2[j].k; break; }
        }
        if(!pick){
          for(var r=items2.length-1; r>=0; r--){
            if(isEnabled(items2[r].k)){ pick = items2[r].k; break; }
          }
        }
        if(pick) inferred = pick;
      }
    } catch(_e){}
    if(inferred !== state.spanPreset){
      state.spanPreset = inferred;
      syncSpanPresetUi();
      if(!o.skipUrl) updateUrlBarSize();
      if(!o.skipSave) scheduleSaveUiConfig();
    } else {
      // Still ensure UI reflects current state (e.g. after DOM reloads).
      syncSpanPresetUi();
    }
  }

  function syncSpanPresetUi(){
    try{
      var k = normalizeSpanPreset(state && state.spanPreset ? state.spanPreset : '1d');
      var els = document.querySelectorAll('input[type="radio"][name="spanPreset"]');
      for(var i=0;i<els.length;i++){
        var el = els[i];
        if(!el) continue;
        el.checked = (String(el.value || '').toLowerCase() === k);
      }
    } catch(_e){}
  }

  function setSpanPreset(v, opts){
    var o = opts || {};
    var key = normalizeSpanPreset(v);
    // Replay: do NOT hard-lock span preset while active; allow user changes.
    // If dataset bounds are known and this preset is not available, fall back to the largest available.
    try{
      updateSpanPresetAvailability();
      var el = document.querySelector('input[type="radio"][name="spanPreset"][value="' + key + '"]');
      if(el && el.disabled){
        // pick the largest enabled
        var keys = SPAN_PRESET_ORDER.slice();
        for(var i=keys.length-1;i>=0;i--){
          var k2 = keys[i];
          var el2 = document.querySelector('input[type="radio"][name="spanPreset"][value="' + k2 + '"]');
          if(el2 && !el2.disabled){ key = k2; break; }
        }
      }
    } catch(_e){}
    state.spanPreset = key;
    if(key === 'all'){
      // Resolve to the currently known full dataset span; if unknown, fall back to a small default
      // and we'll expand after bounds are learned from the first response.
      var ds0 = Number(state && state.datasetStartMs);
      var de0 = Number(state && state.datasetEndMs);
      var deMax = Number(state && state.datasetMaxEndMs);
      var endForHistory = (Number.isFinite(deMax) && Number.isFinite(ds0) && deMax > ds0) ? deMax : de0;
      if(Number.isFinite(ds0) && Number.isFinite(endForHistory) && endForHistory > ds0){
        state.viewSpanMs = endForHistory - ds0;
      } else {
        state.viewSpanMs = DEFAULT_INIT_SPAN_MS;
      }
    } else {
      state.viewSpanMs = Number(SPAN_PRESETS[key]) || DEFAULT_INIT_SPAN_MS;
    }
    // Picking a preset should show (roughly) that preset span immediately.
    state.xZoom = 1;
    // Preset selection implies "show me the latest N"; keep following latest.
    state.followLatest = true;
    if(Number.isFinite(state.datasetEndMs)) state.viewEndMs = state.datasetEndMs;
    syncSpanPresetUi();
    updateSpanPresetAvailability();
    if(!o.skipUrl) updateUrlBarSize();
    if(!o.skipSave) scheduleSaveUiConfig();
    if(!o.skipLoad && !STATIC_MODE) loadFromAPI();
  }

  var state = {
    // dataFull is the unfiltered window returned by the loader.
    // data is the currently displayed view after applying session filters (TradingView-style).
    dataFull: [],
    data: [],
    ha: [],
    overlaysFull: [], // [{t_ms,y,key,label,color,width}] aligned with dataFull
    overlays: [],     // [{t_ms,y,key,label,color,width}] aligned with data (filtered)
    candleStyle: 'std', // 'std' | 'ha'
    xOffset: 0,
    xZoom: 1,
    dragging: false,
    dragX0: 0,
    dragY0: 0,
    xOffset0: 0,
    yPan: 0,      // price-space vertical pan offset (added to yMin/yMax)
    yPan0: 0,
    lastDragDx: 0,
    yDragging: false,
    yScale0: 1,
    yScaleFactor: 1,
    hoverIdx: -1,
    hoverX: NaN,
    hoverY: NaN,
    symbol: 'ESZ5',
    windowSec: 60,
    // Navigation anchor: requested window span (not the full dataset span).
    viewSpanMs: NaN,
    viewEndMs: NaN,
    spanPreset: '1d',
    followLatest: true,
    datasetStartMs: NaN,
    datasetEndMs: NaN,
    // Full dataset end (used for span preset availability). In replay mode we keep datasetEndMs future-blind.
    datasetMaxEndMs: NaN,
    _bootstrappedInitialWindow: false,
    _lastYSpan: NaN,
    _lastPlotH: NaN,
    _loadedBarS: NaN,
    _vwapTrimStartMs: NaN,
    // Render cache: we keep a cached "base layer" bitmap so hover/crosshair updates don't
    // need to recompute/redraw the entire chart.
    _render: {
      baseCanvas: null,      // offscreen canvas holding base layer
      baseKey: '',
      baseW: 0,
      baseH: 0,
      pendingReason: '',
      rafDrawId: null
    },

    // Replay (practice-field) mode state
    replay: {
      active: false,
      sessionId: '',
      playing: false,
      timer: null,
      lastState: null,
      // Replay loop internals (avoid overlapping async steps).
      _loopToken: 0,
      _inFlight: false,
      // Buffered playback (frontend clock): we prefetch batches from the server and
      // consume them locally at an even cadence to avoid network jitter.
      _queue: [],
      _prefetchInFlight: false,
      _rafId: null,
      _rafLastTs: 0,
      _rafAcc: 0,
      _needsDraw: false,
      _lastUiUpdateAt: 0,
      // Replay render fast-path stats (debugging stutter):
      // - hits: append-only path used
      // - misses: full rebuild path used
      // - lastMode: 'fast' | 'full'
      _fastStats: { hits: 0, misses: 0, lastMode: '' },
      _stepFailCount: 0,
      // Optional perf/debug overlay (enabled via ?replay_debug=1)
      _debug: {
        enabled: false,
        targetMs: NaN,
        behindMs: NaN,
        lastStepMs: NaN,
        lastFetchMs: NaN,
        lastRenderMs: NaN,
        lastDrawMs: NaN,
        lastTickAt: NaN,
        // rolling stats (last N samples)
        _N: 60,
        _fetch: [],
        _render: [],
        _draw: [],
        _step: [],
        _behind: [],
        _gap: [], // time between step starts (wall clock)
        maxFetchMs: NaN,
        maxRenderMs: NaN,
        maxDrawMs: NaN,
        maxStepMs: NaN,
        maxBehindMs: NaN,
        maxGapMs: NaN,
        // replay clock tracking
        lastDispEnd: '',
        lastDispEndAt: NaN,
        // Per-step samples (for variability inspection / export)
        // Each: {seq, started_at_ms, finished_at_ms, bpm, target_ms, behind_ms, fetch_ms, render_ms, draw_ms, step_ms, disp_end}
        seq: 0,
        maxSamples: 400,
        samples: [],
        _lastStepStartAtMs: NaN
      }
    }
  };

  // Enable replay debug overlay via URL param (kept off by default).
  try{
    if(state && state.replay && state.replay._debug){
      state.replay._debug.enabled = truthyQueryParam('replay_debug');
    }
  } catch(_eDbgInit){}

  // Debug export helpers (available in devtools console when ?replay_debug=1):
  // - window.replayDebugSamples(): returns array of sample objects
  // - window.dumpReplayDebugCsv(): prints CSV to console (copy/paste into spreadsheet)
  try{
    window.replayDebugSamples = function(){
      try{
        var d = state && state.replay && state.replay._debug ? state.replay._debug : null;
        if(!d || !Array.isArray(d.samples)) return [];
        return d.samples.slice();
      } catch(_e){
        return [];
      }
    };
    window.dumpReplayDebugCsv = function(){
      try{
        var rows = window.replayDebugSamples();
        var header = [
          'seq','started_at_ms','finished_at_ms','bpm','target_ms','behind_ms','gap_ms',
          'fetch_ms','render_ms','draw_ms','step_ms','data_len','last_bar_t_ms','disp_end'
        ];
        var out = [header.join(',')];
        for(var i=0;i<rows.length;i++){
          var r = rows[i] || {};
          function esc(s){
            var x = String(s ?? '');
            if(x.indexOf('"') !== -1) x = x.replace(/"/g,'""');
            if(/[",\n]/.test(x)) x = '"' + x + '"';
            return x;
          }
          var line = [
            r.seq, r.started_at_ms, r.finished_at_ms, r.bpm, r.target_ms, r.behind_ms, r.gap_ms,
            r.fetch_ms, r.render_ms, r.draw_ms, r.step_ms, r.data_len, r.last_bar_t_ms, esc(r.disp_end || '')
          ].map(function(v){ return (v === undefined || v === null) ? '' : String(v); }).join(',');
          out.push(line);
        }
        var csv = out.join('\n');
        console.log(csv);
        return csv;
      } catch(e){
        console.error(e);
        return '';
      }
    };
  } catch(_eDbgFns){}

  // Live mode is disabled in this app integration (use "Fetch Latest Data" instead).
  var LIVE_POLL_MS = 10_000;
  var livePollTimer = null;
  var liveStatusTimer = null;
  state._liveStatus = null; // { enabled, connected, last_ts_event: {sym: iso}, ... }
  state._liveStatusAtMs = NaN;
  state._lastFullSyncAtMs = NaN;

  function closeCandleStyleMenu(){
    if(!ui.candleStyleDD) return;
    ui.candleStyleDD.classList.remove('open');
    if(ui.candleStyleBtn) ui.candleStyleBtn.setAttribute('aria-expanded','false');
  }

  function toggleCandleStyleMenu(){
    if(!ui.candleStyleDD || !ui.candleStyleBtn || ui.candleStyleBtn.disabled) return;
    var open = ui.candleStyleDD.classList.toggle('open');
    ui.candleStyleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
  }

  function setCandleStyle(v){
    var key = String(v || 'std');
    if(key !== 'std' && key !== 'ha') key = 'std';
    state.candleStyle = key;
    if(ui.candleStyleLabel) ui.candleStyleLabel.textContent = (key === 'ha') ? 'Heikin Ashi' : 'Standard';
    if(ui.candleStyleMenu){
      var items = ui.candleStyleMenu.querySelectorAll('.ddItem');
      for(var i=0;i<items.length;i++){
        var it = items[i];
        var val = it.getAttribute('data-value');
        if(val === key) it.classList.add('sel');
        else it.classList.remove('sel');
      }
    }
  }

  function syncCandleStyleEnabled(){
    var enabled = !!(ui.showCandles && ui.showCandles.checked);
    if(ui.candleStyleBtn) ui.candleStyleBtn.disabled = !enabled;
    if(!enabled) closeCandleStyleMenu();
  }

  function msToIsoZ(ms){
    // API accepts Z or offsets; keep URLs compact using ISO Z.
    return new Date(ms).toISOString().replace('.000Z','Z');
  }

  function resize(){
    var dpr = Math.max(1, window.devicePixelRatio || 1);
    var r = canvas.getBoundingClientRect();
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }

  function requestDraw(reason){
    // Coalesce multiple draw requests into a single RAF tick.
    try{
      if(!state || !state._render) return draw();
      state._render.pendingReason = String(reason || '');
      if(state._render.rafDrawId) return;
      state._render.rafDrawId = requestAnimationFrame(function(){
        try{
          state._render.rafDrawId = null;
          draw();
        } catch(_e){
          state._render.rafDrawId = null;
        }
      });
    } catch(_e){
      draw();
    }
  }

  function computeYBounds(){
    // Auto-scale Y should reflect the currently visible X window, so the price action
    // uses as much vertical space as possible in the current view.
    //
    // This is also what the Y-axis double-click ("auto-fit") expects: reset to a
    // tight-but-not-clipped range for the visible bars.
    if(!state.data.length) return {min:0,max:1};

    var n = state.data.length;
    var xZoom = Number(state.xZoom);
    if(!Number.isFinite(xZoom) || xZoom <= 0) xZoom = 1;

    var barsVisible = Math.min(n, Math.max(8, Math.floor(n / xZoom)));

    // Keep behavior consistent with draw(): if xOffset is unset/0 on first load,
    // right-align the view.
    var xOffset = Number(state.xOffset);
    if(!Number.isFinite(xOffset) || xOffset === 0){
      xOffset = Math.max(0, n - barsVisible);
    }
    xOffset = clamp(xOffset, 0, Math.max(0, n - barsVisible));

    var start = Math.floor(xOffset);
    var end = Math.min(n - 1, start + barsVisible + 1);

    // If candles are shown and Heikin Ashi is active, fit to HA highs/lows to match
    // the displayed candles; otherwise fit to raw highs/lows.
    var useHa = false;
    if(ui && ui.showCandles && ui.showCandles.checked && state.candleStyle === 'ha'){
      if(Array.isArray(state.ha) && state.ha.length === state.data.length) useHa = true;
    }
    var arr = useHa ? state.ha : state.data;

    var min = Infinity, max = -Infinity;
    for(var i=start; i<=end; i++){
      var d = arr[i];
      if(!d) continue;
      var lo = Number(d.l);
      var hi = Number(d.h);
      if(!Number.isFinite(lo) || !Number.isFinite(hi)) continue;
      if(lo < min) min = lo;
      if(hi > max) max = hi;
    }

    if(!Number.isFinite(min) || !Number.isFinite(max) || max <= min){
      // Fallback to something sane (should be rare).
      min = 0; max = 1;
    }

    // Small padding to prevent wick/body clipping while keeping the chart "maxed" vertically.
    var span = (max - min);
    var pad = span * 0.02;
    if(!Number.isFinite(pad) || pad <= 0) pad = 1;
    return { min: min - pad, max: max + pad };
  }
    
  function yAxisAutoFit(){
    state.yScaleFactor = 1;
    state.yPan = 0;
    ui.scale.checked = true;
    draw();
  }

  function drawGrid(pricePlot, opts){
    // If opts aren't provided (e.g. no-data state), fall back to a simple evenly-spaced grid.
    var x = pricePlot.x, y = pricePlot.y, w = pricePlot.w, h = pricePlot.h;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;

    // Canvas stroke crispness:
    // A 1px vertical line looks "thicker" if it lands between pixels (antialiasing).
    // Snap X to half-pixel so all vertical grid lines render with a consistent thin weight.
    function _crispX(px){
      return Math.round(px) + 0.5;
    }

    var haveOpts = !!(opts && Number.isFinite(opts.yMin) && Number.isFinite(opts.yMax));
    if(!haveOpts){
      var rows = 6;
      for(var i=0;i<=rows;i++){
        var yy0 = y + (h/rows)*i;
        ctx.beginPath();
        ctx.moveTo(x, yy0);
        ctx.lineTo(x+w, yy0);
        ctx.stroke();
      }
      var cols = 10;
      for(var j=0;j<=cols;j++){
        var xx0 = _crispX(x + (w/cols)*j);
        ctx.beginPath();
        ctx.moveTo(xx0, y);
        ctx.lineTo(xx0, y+h);
        ctx.stroke();
      }
      ctx.restore();
      return;
    }

    // Horizontal grid lines: align to Y-axis price ticks.
    var yMin = Number(opts.yMin), yMax = Number(opts.yMax);
    var yTicksInfo = computePriceTicks(yMin, yMax, pricePlot.h, 58);
    var yTicks = yTicksInfo && yTicksInfo.ticks ? yTicksInfo.ticks : [];
    for(var yi=0; yi<yTicks.length; yi++){
      var p = yTicks[yi];
      var yy = yForPrice(p, pricePlot, yMin, yMax);
      if(!Number.isFinite(yy)) continue;
      ctx.beginPath();
      ctx.moveTo(x, yy);
      ctx.lineTo(x+w, yy);
      ctx.stroke();
    }

    // Vertical grid lines: align to X-axis time/date ticks (same step selection as axis labels).
    var start = opts.start, end = opts.end, barsVisible = opts.barsVisible, plot = opts.plot;
    var data = (state && Array.isArray(state.data)) ? state.data : null;
    if(data && Number.isFinite(start) && Number.isFinite(end) && Number.isFinite(barsVisible) && plot && plot.w > 4){
      // Extend vertical grid lines to the full plot height (including volume pane) so they reach
      // the bottom edge of the container. Stay inside the clip inset (see clipInset=1).
      var vTop = plot.y + 1;
      var vBottom = plot.y + plot.h - 1;
      var t0 = Number(data[start] && data[start].t);
      var t1 = Number(data[end] && data[end].t);
      var tInfo = computeTimeTicksBySpan(t0, t1, plot.w, 140);
      if(tInfo){
        for(var tm = tInfo.first; tm <= tInfo.t1; tm += tInfo.stepMs){
          var idx = findIndexByTimeMs(data, tm);
          if(idx < start) idx = start;
          if(idx > end) idx = end;
          var xx = _crispX(xForIndex(idx + 0.5, plot, barsVisible));
          if(!Number.isFinite(xx)) continue;
          if(xx < x - 2 || xx > x + w + 2) continue;
          ctx.beginPath();
          ctx.moveTo(xx, vTop);
          ctx.lineTo(xx, vBottom);
          ctx.stroke();
        }
      }
    }

    ctx.restore();
  }

  function xForIndex(i, plot, barsVisible){
    var t = (i - state.xOffset) / barsVisible;
    return plot.x + t * plot.w;
  }

  function yForPrice(p, plot, yMin, yMax){
    var t = (p - yMin) / (yMax - yMin);
    return plot.y + plot.h * (1 - t);
  }

  function niceStep(step){
    // "Nice number" tick step: 1, 2, 5 * 10^n
    var s = Math.abs(Number(step));
    if(!Number.isFinite(s) || s <= 0) return 1;
    var exp = Math.floor(Math.log10(s));
    var f = s / Math.pow(10, exp);
    var nf;
    if(f <= 1) nf = 1;
    else if(f <= 2) nf = 2;
    else if(f <= 5) nf = 5;
    else nf = 10;
    return nf * Math.pow(10, exp);
  }

  function decimalsForStep(step){
    var s = Math.abs(Number(step));
    if(!Number.isFinite(s) || s <= 0) return 2;
    if(s >= 1) return 2;
    // Enough precision to show distinct ticks; cap to keep labels sane.
    var d = Math.ceil(-Math.log10(s)) + 1;
    return clamp(d, 2, 6);
  }

  function computePriceTicks(yMin, yMax, plotH, minPxPerTick){
    var a = Number(yMin), b = Number(yMax);
    if(!Number.isFinite(a) || !Number.isFinite(b) || b <= a) return [];
    var h = Number(plotH);
    if(!Number.isFinite(h) || h <= 0) h = 500;
    var minPx = Number(minPxPerTick);
    if(!Number.isFinite(minPx) || minPx < 20) minPx = 58;

    var targetTicks = clamp(Math.floor(h / minPx), 3, 12);
    var raw = (b - a) / targetTicks;
    var step = niceStep(raw);
    if(!Number.isFinite(step) || step <= 0) step = raw;

    // Expand to nice boundaries so ticks align to round prices.
    var lo = Math.floor(a / step) * step;
    var hi = Math.ceil(b / step) * step;
    // Guard against floating drift.
    var eps = step * 1e-9;

    var out = [];
    for(var v = lo; v <= hi + eps; v += step){
      // Avoid -0.00
      var vv = (Math.abs(v) < eps) ? 0 : v;
      out.push(vv);
      if(out.length > 200) break;
    }
    // Keep only ticks that land within the visible range (with small epsilon).
    var out2 = [];
    for(var i=0;i<out.length;i++){
      var t = out[i];
      if(t >= a - eps && t <= b + eps) out2.push(t);
    }
    return { ticks: out2, step: step };
  }

  function chooseTimeStepMs(spanMs, plotW, minPxPerTick){
    // Pick a tick step so labels don't overlap.
    // NOTE: This is intentionally "pixel-aware": we estimate how many ticks we can fit
    // based on the plot width, then choose the nearest step >= target.
    var span = Number(spanMs);
    if(!Number.isFinite(span) || span <= 0) return 60 * 1000;
    var plotWidth = Number(plotW);
    var minPx = Number(minPxPerTick);
    if(!Number.isFinite(plotWidth) || plotWidth <= 0) plotWidth = 900;
    if(!Number.isFinite(minPx) || minPx <= 10) minPx = 140;

    var maxTicks = Math.max(2, Math.floor(plotWidth / minPx));
    var target = Math.max(1, Math.floor(span / maxTicks)); // ms per tick

    var steps = [
      1000, 2000, 5000, 10_000, 15_000, 30_000,
      60_000, 2*60_000, 5*60_000, 10*60_000, 15*60_000, 30*60_000,
      60*60_000, 2*60*60_000, 4*60*60_000, 6*60*60_000, 12*60*60_000,
      24*60*60_000, 2*24*60*60_000, 7*24*60*60_000, 14*24*60*60_000, 30*24*60*60_000
    ];
    for(var i=0;i<steps.length;i++){
      if(steps[i] >= target) return steps[i];
    }
    return steps[steps.length-1];
  }

  function chooseMonthStep(monthCount, plotW, minPxPerTick){
    // Choose a month stride so labels don't overlap when zoomed out.
    var m = Math.max(0, Math.floor(Number(monthCount) || 0));
    if(m <= 0) return 1;
    var plotWidth = Number(plotW);
    var minPx = Number(minPxPerTick);
    if(!Number.isFinite(plotWidth) || plotWidth <= 0) plotWidth = 900;
    if(!Number.isFinite(minPx) || minPx <= 10) minPx = 140;
    var maxTicks = Math.max(2, Math.floor(plotWidth / minPx));
    var target = Math.max(1, Math.ceil(m / maxTicks));
    var steps = [1, 2, 3, 6, 12];
    for(var i=0;i<steps.length;i++){
      if(steps[i] >= target) return steps[i];
    }
    return steps[steps.length-1];
  }

  function computeTimeTicksBySpan(t0, t1, plotW, minPxPerTick){
    var a = Number(t0), b = Number(t1);
    if(!Number.isFinite(a) || !Number.isFinite(b) || b <= a) return null;
    var spanMs = b - a;
    var stepMs = chooseTimeStepMs(spanMs, plotW, minPxPerTick);
    var first = Math.floor(a / stepMs) * stepMs;
    if(first < a) first += stepMs;
    return { stepMs: stepMs, first: first, t0: a, t1: b };
  }

  // Display timezone: NYSE / Eastern Time (handles EST/EDT automatically).
  var DISPLAY_TZ = 'America/New_York';

  function fmtEt(ms, opts){
    try{
      var d = new Date(ms);
      if(!Number.isFinite(d.getTime())) return '';
      return new Intl.DateTimeFormat('en-US', Object.assign({
        timeZone: DISPLAY_TZ
      }, (opts || {}))).format(d);
    } catch(_e){
      // Fallback: local time
      var dd = new Date(ms);
      return (Number.isFinite(dd.getTime()) ? dd.toLocaleString() : '');
    }
  }

  function formatTimeLabelUtc(ms, stepMs){
    // (Name kept for minimal diff) Render in ET, 12-hour time.
    if(stepMs < 60_000) return fmtEt(ms, { hour:'numeric', minute:'2-digit', second:'2-digit', hour12:true });
    if(stepMs < 24*60*60_000) return fmtEt(ms, { hour:'numeric', minute:'2-digit', hour12:true });
    return fmtEt(ms, { year:'numeric', month:'2-digit', day:'2-digit' });
  }

  function formatDayLabelPartsUtc(ms, prevMs){
    // (Name kept for minimal diff) Returns {top,bottom} in ET: top=month at transitions, bottom=day number.
    var day = fmtEt(ms, { day:'numeric' });
    var top = '';
    var mon = fmtEt(ms, { month:'short' });
    var ym = fmtEt(ms, { year:'numeric', month:'2-digit' });
    var prevYm = (prevMs === null || prevMs === undefined) ? '' : fmtEt(prevMs, { year:'numeric', month:'2-digit' });
    if(!prevYm || prevYm !== ym) top = mon;
    // also show month on the 1st
    var dayNum = parseInt(String(day), 10);
    if(dayNum === 1) top = mon;
    return { top: top, bottom: String(day) };
  }

  function formatTooltipTimeUtc(ms){
    // (Name kept for minimal diff) Tooltip/crosshair time in ET, non-military, with TZ abbreviation.
    return fmtEt(ms, { year:'numeric', month:'2-digit', day:'2-digit', hour:'numeric', minute:'2-digit', hour12:true, timeZoneName:'short' });
  }

  function formatAxisTimeUtc(ms, stepMs){
    // (Name kept for minimal diff) Compact axis label in ET.
    // If we're zoomed out to multi-week+ spans, day-of-month is noisy; show month+year.
    if(Number(stepMs) >= 14*24*60*60_000) return fmtEt(ms, { month:'short', year:'numeric' });
    if(Number(stepMs) >= 24*60*60_000) return fmtEt(ms, { month:'short', day:'numeric' });
    return fmtEt(ms, { hour:'numeric', minute:'2-digit', hour12:true });
  }

  function formatVolume(v){
    var x = Number(v);
    if(!Number.isFinite(x)) return '';
    var ax = Math.abs(x);
    if(ax >= 1e9) return (x/1e9).toFixed(2).replace(/\.00$/,'') + 'B';
    if(ax >= 1e6) return (x/1e6).toFixed(2).replace(/\.00$/,'') + 'M';
    if(ax >= 1e3) return (x/1e3).toFixed(1).replace(/\.0$/,'') + 'K';
    return String(Math.round(x));
  }

  function computeHeikinAshi(bars){
    // Returns an array of {o,h,l,c} (same length as bars).
    // HA is sequential:
    // haClose = (o + h + l + c)/4
    // haOpen  = (prevHaOpen + prevHaClose)/2, seed: (o0 + c0)/2
    // haHigh  = max(h, haOpen, haClose)
    // haLow   = min(l, haOpen, haClose)
    if(!Array.isArray(bars) || !bars.length) return [];
    var out = new Array(bars.length);
    var prevOpen = NaN;
    var prevClose = NaN;
    for(var i=0;i<bars.length;i++){
      var b = bars[i];
      if(!b){
        out[i] = { o: NaN, h: NaN, l: NaN, c: NaN };
        continue;
      }
      var o = Number(b.o), h = Number(b.h), l = Number(b.l), c = Number(b.c);
      var haClose = (o + h + l + c) / 4;
      var haOpen = (i === 0 || !Number.isFinite(prevOpen) || !Number.isFinite(prevClose)) ? ((o + c) / 2) : ((prevOpen + prevClose) / 2);
      var haHigh = Math.max(h, haOpen, haClose);
      var haLow = Math.min(l, haOpen, haClose);
      out[i] = { o: haOpen, h: haHigh, l: haLow, c: haClose };
      prevOpen = haOpen;
      prevClose = haClose;
    }
    return out;
  }

  function findIndexByTimeMs(data, tMs){
    // data must be sorted by .t ascending.
    var lo = 0, hi = data.length - 1;
    while(lo <= hi){
      var mid = (lo + hi) >> 1;
      var v = data[mid].t;
      if(v < tMs) lo = mid + 1;
      else if(v > tMs) hi = mid - 1;
      else return mid;
    }
    return clamp(lo, 0, data.length - 1);
  }

  function rightAlignXView(){
    // Default trading-chart convention: start with "current" (right edge) in view.
    // This is the programmatic equivalent of panning all the way to the right.
    var n = (state && Array.isArray(state.data)) ? state.data.length : 0;
    if(!n) return;
    var z = Number(state.xZoom);
    if(!Number.isFinite(z) || z <= 0) z = 1;
    // IMPORTANT:
    // - barsVisibleData determines how many real bars we can pan over (xOffset clamp).
    // - Rendering may use additional "future" padding bars (replay UX) via barsVisibleScale,
    //   but we never allow xOffset to scroll into non-existent bars.
    var barsVisibleData = Math.min(n, Math.max(8, Math.floor(n / z)));
    state.xOffset = Math.max(0, n - barsVisibleData);
  }

  function futurePadBars(){
    // Practice / replay UX: reserve a small empty "future" region to the right so the
    // user can visually project trade placement without showing future candles.
    // Measured in "bar widths" (slots), not pixels.
    try{
      return (state && state.replay && state.replay.active) ? 5 : 0;
    } catch(_e){
      return 0;
    }
  }

  function computeVisibleBars(n, zoom){
    var nn = Math.max(0, Math.floor(Number(n) || 0));
    var z = Number(zoom);
    if(!Number.isFinite(z) || z <= 0) z = 1;
    // "Data bars" controls offsets/bounds.
    var barsVisibleData = Math.min(nn, Math.max(8, Math.floor(nn / z)));
    // "Scale bars" controls horizontal mapping (slot count across the plot).
    var pad = Math.max(0, Math.floor(Number(futurePadBars()) || 0));
    var barsVisibleScale = Math.max(1, Math.floor(barsVisibleData + pad));
    return { barsVisibleData: barsVisibleData, barsVisibleScale: barsVisibleScale, padBars: pad };
  }

  async function loadFromAPI(force){
    if(STATIC_MODE){
      return await loadFromStatic(force);
    }
    // When practicing (replay mode), the authoritative data source is /replay/*.
    // Avoid background /window fetches overwriting replay state.
    if(state && state.replay && state.replay.active){
      return;
    }
    // Prevent overlapping requests from live polling / repeated UI events.
    // We still allow internal "one-hop" recursion (Auto W refinement) via force=true.
    if(!force && ui.regen && ui.regen.disabled) return;
    // Prevent out-of-order fetches (e.g. rapid slider drags) from overwriting newer data.
    state._reqSeq = (state._reqSeq || 0) + 1;
    var myReq = state._reqSeq;

    var symbol = String(getSymbol() || 'ESZ5').trim();
    if(!symbol) symbol = 'ESZ5';

    // Optional pass-through query params, if your backend supports them.
    var start = getQueryParam('start', '');
    var end = getQueryParam('end', '');
    var maxBarsQ = getQueryParam('max_bars', '');
    var limit = getQueryParam('limit', ''); // back-compat
    var explicitWindow = !!(start && end);
    var derivedWindow = false;
    var hadReqWindow = false;
    var reqStartMs = NaN;
    var reqEndMs = NaN;
    // If we start with unknown bounds, the server will default to "last hour ending at dataset end".
    // After the first response we can learn dataset_end and then request our preferred default window.
    var postBootstrapInitialWindow = false;

    // Cap the payload by default. If `max_bars` is set, use it; else fall back to legacy `limit`.
    // Auto W will increase bar_s to keep the returned bar count within this budget.
    var effMaxBars = (maxBarsQ !== '' ? maxBarsQ : (limit !== '' ? limit : '5000'));

    // If caller didn't specify a start/end in the URL, drive the request from the app's view anchors:
    //   - state.viewEndMs: right edge of requested window
    //   - state.viewSpanMs: requested window span (not the full dataset)
    //
    // When following latest, intentionally omit `end` so the backend can extend the window using live data.
    // When NOT following latest (manual browsing), send explicit end so panning/zooming is stable.
    if(!start && !end){
      if(Number.isFinite(state.datasetStartMs) && Number.isFinite(state.datasetEndMs)){
        var dsStart = Number(state.datasetStartMs);
        var dsEnd = Number(state.datasetEndMs);

        // Initialize anchors if unset.
        if(!Number.isFinite(state.viewEndMs)) state.viewEndMs = dsEnd;
        if(!Number.isFinite(state.viewSpanMs) || state.viewSpanMs <= 0){
          state.viewSpanMs = DEFAULT_INIT_SPAN_MS;
        }

        // Clamp anchors to dataset bounds.
        var spanMs0 = clamp(Number(state.viewSpanMs), 60*1000, Math.max(60*1000, dsEnd - dsStart));
        var endMs0 = clamp(Number(state.viewEndMs), dsStart + spanMs0, dsEnd);
        var startMs0 = Math.max(dsStart, endMs0 - spanMs0);

        state.viewSpanMs = spanMs0;
        state.viewEndMs = endMs0;
        syncSpanPresetFromNavigation();

        start = msToIsoZ(startMs0);
        // omit end only in followLatest mode so server can extend window with live
        end = state.followLatest ? '' : msToIsoZ(endMs0);

        derivedWindow = true;
        reqStartMs = startMs0;
        reqEndMs = endMs0;
      }
    } else {
    // URL-driven explicit window disables followLatest.
      state.followLatest = false;
      if(start && end){
        reqStartMs = parseIsoToMs(start);
        reqEndMs = parseIsoToMs(end);
      }
    }
    hadReqWindow = !!(explicitWindow || derivedWindow);

    // Auto bar sizing: choose bar_s using the *visible* span implied by zoom (not the full dataset span).
    // Target ~300–500 candles on screen (clamped 150–800).
    // If start/end aren't provided, we'll optionally do a one-time post-adjust using the server window labels.
    var autoW = (ui.autoW ? !!ui.autoW.checked : false);
    if(autoW && start && end){
      var sMs = parseIsoToMs(start);
      var eMs = parseIsoToMs(end);
      if(Number.isFinite(sMs) && Number.isFinite(eMs) && eMs > sMs){
        var visSpanMsA = getVisibleSpanMs(eMs - sMs);
        var rec = recommendBarSecForVisibleSpan(visSpanMsA, effMaxBars);
        state.windowSec = rec;
        if(ui.window) ui.window.value = String(rec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec);
        syncBarPresetUi();
        updateUrlBarSize();
      }
    } else if(autoW && Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0){
      // Prefer the currently requested span (derived window or previously set viewSpanMs).
      var visSpanMsB = getVisibleSpanMs(state.viewSpanMs);
      if(Number.isFinite(visSpanMsB) && visSpanMsB > 0){
        var rec2 = recommendBarSecForVisibleSpan(visSpanMsB, effMaxBars);
        state.windowSec = rec2;
        if(ui.window) ui.window.value = String(rec2);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec2);
        syncBarPresetUi();
        updateUrlBarSize();
      }
    }

    // Bar size: UI drives bar_s; always normalize to preset increments (snapped state).
    var bar_s = clamp(Number(state.windowSec || ui.window.value || 60), 30, 86400);
    if(!Number.isFinite(bar_s)) bar_s = 60;
    bar_s = snapToPreset(bar_s);
    state.windowSec = bar_s;
    if(ui.window) ui.window.value = String(bar_s);
    if(ui.windowVal) ui.windowVal.textContent = formatWindow(bar_s);
    syncBarPresetUi();

    // If the full-history span would exceed the max bars budget, bump bar_s up to the smallest
    // preset that fits within effMaxBars (even if Auto W is off).
    (function enforceMaxBars(){
      try{
        var cap = Math.max(1, Math.floor(Number(effMaxBars) || 1));
        var spanMs = NaN;
        if(start && end){
          var ssMs2 = parseIsoToMs(start);
          var eeMs2 = parseIsoToMs(end);
          if(Number.isFinite(ssMs2) && Number.isFinite(eeMs2) && eeMs2 > ssMs2) spanMs = eeMs2 - ssMs2;
        } else if(Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0){
          spanMs = Number(state.viewSpanMs);
        }
        if(!Number.isFinite(spanMs) || spanMs <= 0) return;
        var visSpanMs = getVisibleSpanMs(spanMs);
        if(!Number.isFinite(visSpanMs) || visSpanMs <= 0) return;
        var visSec = Math.max(1, Math.floor(visSpanMs / 1000));
        var need = Math.ceil(visSec / Math.max(1, Math.floor(bar_s)));
        if(Number.isFinite(need) && need > cap){
          var minBar = snapCeilToPreset(Math.ceil(visSec / cap));
          minBar = clamp(minBar, 60, 86400);
          if(minBar !== bar_s){
            bar_s = minBar;
            state.windowSec = bar_s;
            if(ui.window) ui.window.value = String(bar_s);
            if(ui.windowVal) ui.windowVal.textContent = formatWindow(bar_s);
            syncBarPresetUi();
            updateUrlBarSize();
          }
        }
      } catch(_e){}
    })();

    // VWAP correctness: if VWAP overlay is enabled and we have a concrete start time,
    // preload bars back to the session open (RTH 09:30 ET) so the first bar's VWAP isn't "mid-session wrong".
    // We'll trim back to the requested start after computing overlays.
    var overlaySettings0 = getOverlaySettings();
    var vwapTrimStartMs = NaN;
    if(overlaySettings0 && overlaySettings0.vwap && start){
      try{
        var origStartMs0 = parseIsoToMs(start);
        if(Number.isFinite(origStartMs0)){
          var sess0 = sessionStartMsForEtDay(origStartMs0);
          if(Number.isFinite(sess0) && sess0 < origStartMs0){
            vwapTrimStartMs = origStartMs0;
            start = msToIsoZ(sess0);
          }
        }
      } catch(_e){}
    }

    var url = buildUrl(API_BASE, '/window', {
      symbol: symbol,
      start: start,
      end: end,
      max_bars: effMaxBars,
      // send legacy `limit` too for older servers
      limit: effMaxBars,
      bar_s: Math.floor(bar_s)
    });
    if(ui.reqInfo) ui.reqInfo.textContent = 'bar_s=' + Math.floor(bar_s) + ' (loading…)';

    var prevText = ui.regen ? ui.regen.textContent : '';
    if(ui.regen){ ui.regen.disabled = true; ui.regen.textContent = 'Loading…'; }

    // Update the "last update" chip (top-right) on success/error.
    function setUpdateChip(status, text){
      try{
        var dot = document.getElementById('updateDot');
        var el = document.getElementById('updateText');
        if(dot){
          dot.classList.remove('ok','live','warn','err');
          if(status === 'ok') dot.classList.add('ok');
          else if(status === 'live') dot.classList.add('live');
          else if(status === 'warn') dot.classList.add('warn');
          else if(status === 'err') dot.classList.add('err');
        }
        if(el) el.textContent = String(text || '');
      } catch(_e){}
    }

    try{
      // Client-side request timing (high-level): headers, download, parse.
      var t0 = (window.performance && performance.now) ? performance.now() : Date.now();
      var res = await fetch(url, { method: 'GET', cache: 'no-store' });
      var t1 = (window.performance && performance.now) ? performance.now() : Date.now();
      if(!res.ok) throw new Error('HTTP ' + res.status + ' from ' + url);
      var txt = await res.text();
      var t2 = (window.performance && performance.now) ? performance.now() : Date.now();
      var j = JSON.parse(txt);
      var t3 = (window.performance && performance.now) ? performance.now() : Date.now();
      if(myReq !== state._reqSeq) return; // stale response

      // Capture dataset bounds (if present) for navigation clamping.
      if(j && j.dataset_start){
        var ds = parseIsoToMs(j.dataset_start);
        if(Number.isFinite(ds)) state.datasetStartMs = ds;
      }
      if(j && j.dataset_end){
        var de = parseIsoToMs(j.dataset_end);
        if(Number.isFinite(de)) state.datasetEndMs = de;
      }
      updateSpanPresetAvailability();
      state._lastFullSyncAtMs = Date.now();

      // Cold-load UX:
      // - Always render the first response (server default is "last hour ending at dataset end")
      // - Then (once bounds are known) do ONE follow-up fetch for the preferred default window
      //   ending at dataset end. Never auto-bootstrap to full-history.
      if(!explicitWindow && !derivedWindow && !start && !end && Number.isFinite(state.datasetStartMs) && Number.isFinite(state.datasetEndMs)){
        if(!state._bootstrappedInitialWindow){
          state._bootstrappedInitialWindow = true;
          state.viewEndMs = state.datasetEndMs;
          // Respect any pre-selected preset; otherwise fall back to the default.
          var pref = (Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0) ? Number(state.viewSpanMs) : DEFAULT_INIT_SPAN_MS;
          state.viewSpanMs = clamp(pref, 60*1000, Math.max(60*1000, state.datasetEndMs - state.datasetStartMs));
          syncSpanPresetFromNavigation();
          postBootstrapInitialWindow = true;
        }
      }

      // Track navigation anchors from what we *asked* for (preferred) or, if absent, what we got.
      if((explicitWindow || derivedWindow) && Number.isFinite(reqEndMs) && Number.isFinite(reqStartMs) && reqEndMs > reqStartMs){
        state.viewEndMs = reqEndMs;
        state.viewSpanMs = reqEndMs - reqStartMs;
        syncSpanPresetFromNavigation();
      } else if(!hadReqWindow && j && j.start && j.end){
        // Discovery only: set end anchor so subsequent requests can be anchored consistently.
        var we2 = parseIsoToMs(j.end);
        if(Number.isFinite(we2)) state.viewEndMs = we2;
      }
      if(state.followLatest && Number.isFinite(state.datasetEndMs)) state.viewEndMs = state.datasetEndMs;

      // If start/end weren't specified, use the server-reported window once to pick a better bar size.
      // Guard against infinite loops by only auto-adjusting if bar_s actually changes.
      if(autoW && (!start || !end) && j && j.start && j.end){
        var js = parseIsoToMs(j.start);
        var je = parseIsoToMs(j.end);
        if(Number.isFinite(js) && Number.isFinite(je) && je > js){
          var visSpanMsC = getVisibleSpanMs(je - js);
          var rec2 = recommendBarSecForVisibleSpan(visSpanMsC, (effMaxBars || j.max_bars || j.limit || ''));
          if(Math.floor(rec2) !== Math.floor(bar_s)){
            state.windowSec = rec2;
            if(ui.window) ui.window.value = String(rec2);
            if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec2);
            syncBarPresetUi();
            updateUrlBarSize();
            // Re-fetch with the refined bar size (one hop). Bump reqSeq via recursion; current response is discarded.
            loadFromAPI(true);
            return;
          }
        }
      }

      var t = j.t_ms, o = j.o, h = j.h, l = j.l, c = j.c, v = j.v;
      // Treat server bar_s as authoritative (server may normalize non-multiple-of-30).
      // Also reset Y pan/zoom on bar size changes so the chart visibly re-scales as expected.
      var serverBar = (j && j.bar_s !== undefined && j.bar_s !== null) ? Number(j.bar_s) : NaN;
      var effBar = Number.isFinite(serverBar) ? Math.floor(serverBar) : Math.floor(bar_s);
      if(Number.isFinite(effBar) && effBar > 0){
        if(!Number.isFinite(state._loadedBarS) || Math.floor(state._loadedBarS) !== effBar){
          state._loadedBarS = effBar;
          // Keep X behavior consistent: data loads always right-align and reset zoom.
          // (Already done below.) For Y, reset pan/zoom so auto-scale feels responsive to bar changes.
          state.yPan = 0;
          state.yScaleFactor = 1;
        }
        // Keep UI + URL consistent with what the server actually served.
        state.windowSec = clamp(effBar, 60, 86400);
        if(ui.window) ui.window.value = String(state.windowSec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(state.windowSec);
        syncBarPresetUi();
        updateUrlBarSize();
      }

      // If the dataset contains more history than the current window, and the full history
      // would still fit within the max bars budget at the current bar size, auto-expand
      // the requested window to include the full dataset.
      //
      // This fixes the common "I imported multiple years but only 1Y is visible" issue for
      // coarse bars (e.g. 1D equities) where fetching everything is still cheap.
      try{
        var spanQ0 = String(getQueryParam('span', '') || '').trim().toLowerCase();
        var cap0 = Math.max(1, Math.floor(Number(effMaxBars || j.max_bars || j.limit || 0) || 1));
        var dsA = Number(state && state.datasetStartMs);
        var deA = Number(state && state.datasetEndMs);
        if(!explicitWindow && Number.isFinite(dsA) && Number.isFinite(deA) && deA > dsA){
          var fullSpanMs = deA - dsA;
          var secPerBar = Math.max(1, Math.floor(Number(effBar) || Math.floor(state.windowSec) || 60));
          var approxBars = Math.ceil(fullSpanMs / (secPerBar * 1000));
          var wantsAll = (String(state && state.spanPreset || '').toLowerCase() === 'all') || (spanQ0 === 'all') || (spanQ0 === '1y');
          var curSpan0 = Number(state && state.viewSpanMs);
          if(wantsAll && !state._autoExpandedFullHistoryOnce && Number.isFinite(approxBars) && approxBars <= cap0){
            if(!Number.isFinite(curSpan0) || curSpan0 < fullSpanMs - 60*1000){
              state._autoExpandedFullHistoryOnce = true;
              state.spanPreset = 'all';
              state.viewSpanMs = fullSpanMs;
              state.viewEndMs = deA;
              state.followLatest = true;
              state.xZoom = 1;
              syncSpanPresetUi();
              updateSpanPresetAvailability();
              updateUrlBarSize();
              loadFromAPI(true);
              return;
            }
          }
        }
      } catch(_eAutoAll){}

      if(!Array.isArray(t) || !Array.isArray(o) || !Array.isArray(h) || !Array.isArray(l) || !Array.isArray(c) || !Array.isArray(v)){
        throw new Error('Unexpected JSON shape. Expected arrays: t_ms,o,h,l,c,v');
      }
      var n = t.length;
      if(o.length !== n || h.length !== n || l.length !== n || c.length !== n || v.length !== n){
        throw new Error('Mismatched array lengths in payload');
      }

      // Compute overlays against the full payload (including any VWAP preload),
      // then trim to the requested viewport start.
      var overlaysFull = [];
      try{
        if(overlaySettings0 && anyOverlayEnabled(overlaySettings0)){
          overlaysFull = computeOverlays(
            { t_ms: t, o: o, h: h, l: l, c: c, v: v },
            overlaySettings0,
            { symbol: symbol, bar_s: effBar }
          );
        }
      } catch(_e){}

      var trimIdx = 0;
      if(Number.isFinite(vwapTrimStartMs) && vwapTrimStartMs > 0){
        while(trimIdx < n && Number(t[trimIdx]) < vwapTrimStartMs) trimIdx++;
      }
      if(trimIdx > 0 && trimIdx < n){
        t = t.slice(trimIdx); o = o.slice(trimIdx); h = h.slice(trimIdx); l = l.slice(trimIdx); c = c.slice(trimIdx); v = v.slice(trimIdx);
        n = t.length;
        // Trim overlays to match.
        try{
          for(var si=0; si<overlaysFull.length; si++){
            var s = overlaysFull[si];
            if(!s || !Array.isArray(s.y) || !Array.isArray(s.t_ms)) continue;
            s.t_ms = s.t_ms.slice(trimIdx);
            s.y = s.y.slice(trimIdx);
          }
        } catch(_e2){}
      }

      var out = new Array(n);
      for(var i=0;i<n;i++){
        out[i] = {
          t: Number(t[i]),
          o: Number(o[i]),
          h: Number(h[i]),
          l: Number(l[i]),
          c: Number(c[i]),
          v: Number(v[i]),
          bid: NaN,
          ask: NaN
        };
      }

      // Preserve the user's view when NOT following latest:
      // snapshot a time anchor near the center of the current view, then re-center on it after refresh.
      var anchorT = NaN;
      var anchorZoom = Number(state.xZoom);
      if(!Number.isFinite(anchorZoom) || anchorZoom <= 0) anchorZoom = 1;
      if(!state.followLatest && Array.isArray(state.data) && state.data.length){
        try{
          var n0 = state.data.length;
          var barsVis0 = computeVisibleBars(n0, anchorZoom).barsVisibleData;
          var off0 = Number(state.xOffset);
          if(!Number.isFinite(off0)) off0 = 0;
          var centerIdx = Math.floor(off0 + barsVis0 * 0.5);
          centerIdx = clamp(centerIdx, 0, n0 - 1);
          anchorT = Number(state.data[centerIdx].t);
        } catch(_e){}
      }

      // Store unfiltered window, then apply TradingView-style session filtering to build state.data.
      state.dataFull = out;
      state.overlaysFull = overlaysFull || [];
      state.data = out;
      state._sessionType = computeSessionTypesForData(out);
      // Compute HA only if HA candles are actually selected (avoid heavy work on every refresh).
      try{
        var needHa0 = !!(ui && ui.showCandles && ui.showCandles.checked && state && state.candleStyle === 'ha');
        state.ha = needHa0 ? computeHeikinAshi(out) : [];
      } catch(_eHa0){
        state.ha = [];
      }
      state.overlays = overlaysFull || [];
      applySessionFilter({ anchor: { t: anchorT, zoom: anchorZoom }, skipSave: true, skipDraw: true });
      updateSessionCountsUi();
      // X view policy:
      // - If following latest: keep right-aligned but do NOT reset zoom.
      // - If not following latest: keep your pan/zoom centered on the previous time anchor.
      if(!Number.isFinite(state.xZoom) || state.xZoom <= 0) state.xZoom = 1;
      if(state.followLatest){
        rightAlignXView();
      } else if(Number.isFinite(anchorT) && state.data.length){
        state.xZoom = anchorZoom;
        var n1 = state.data.length;
        var barsVis1 = computeVisibleBars(n1, state.xZoom).barsVisibleData;
        var idx1 = findIndexByTimeMs(state.data, anchorT);
        state.xOffset = idx1 - barsVis1 * 0.5;
      }
      state.hoverIdx = -1;
      draw();
      // Now that we have *something* rendered, upgrade to the preferred initial window.
      // This keeps cold-load fast and avoids the long "Loading..." stall.
      if(postBootstrapInitialWindow){
        if(windowTimer) clearTimeout(windowTimer);
        windowTimer = setTimeout(function(){ loadFromAPI(); }, 30);
      }
      if(ui.reqInfo){
        var s = 'bars=' + n + ' · bar_s=' + Math.floor(bar_s);
        if(j && j.truncated) s += ' · truncated';
        if(j && j.live_merged) s += ' · live';
        try{
          var fetchMs = Math.max(0, (t1 - t0));
          var dlMs = Math.max(0, (t2 - t1));
          var parseMs = Math.max(0, (t3 - t2));
          s += ' · net=' + Math.round(fetchMs) + 'ms';
          s += ' · dl=' + Math.round(dlMs) + 'ms';
          s += ' · parse=' + Math.round(parseMs) + 'ms';
        } catch(_e){}
        if(Number.isFinite(serverBar)){
          if(Math.floor(serverBar) !== Math.floor(bar_s)) s += ' (server=' + Math.floor(serverBar) + ')';
        } else if(Math.floor(bar_s) !== 1) {
          // Helpful hint: older servers ignore bar_s and won't include it in the payload.
          s += ' (server missing bar_s; restart api_server or use ?api=...)';
        }
        ui.reqInfo.textContent = s;
      }

      // Chip: show fetch time AND data freshness (end timestamp + age).
      (function(){
        var now = new Date();
        var hh = String(now.getHours()).padStart(2,'0');
        var mm = String(now.getMinutes()).padStart(2,'0');
        var ss = String(now.getSeconds()).padStart(2,'0');
        var mode = (j && j.live_merged) ? 'LIVE' : 'HIST';

        // Prefer dataset_end if present; otherwise use the last bar time from the payload.
        var dataEndMs = NaN;
        if(j && j.dataset_end) dataEndMs = parseIsoToMs(j.dataset_end);
        if(!Number.isFinite(dataEndMs) && Array.isArray(t) && t.length) dataEndMs = Number(t[t.length - 1]);
        if(!Number.isFinite(dataEndMs) && j && j.end) dataEndMs = parseIsoToMs(j.end);

        var ageSec = Number.isFinite(dataEndMs) ? Math.max(0, Math.floor((Date.now() - dataEndMs) / 1000)) : NaN;
        var ageTxt = Number.isFinite(ageSec) ? (ageSec >= 3600 ? (Math.floor(ageSec/3600) + 'h') : (ageSec >= 60 ? (Math.floor(ageSec/60) + 'm') : (ageSec + 's'))) : '—';
        var dataTxt = Number.isFinite(dataEndMs) ? formatTooltipTimeUtc(dataEndMs) : '—';

        // If following latest but data is old, warn. (Futures can be closed; still useful signal.)
        var stale = Number.isFinite(ageSec) && ageSec > 120 && state.followLatest;
        var status = (j && j.live_merged) ? 'live' : (stale ? 'warn' : 'ok');

        // Optional ingest freshness hint (from /live/status), if available.
        var ingestTxt = '';
        try{
          var ls = state._liveStatus || null;
          if(ls && ls.enabled){
            var lastMap = ls.last_ts_event || {};
            var sym = String(getSymbol() || '');
            // Prefer exact symbol; fallback to first/only symbol if present.
            var iso = lastMap[sym];
            if(!iso){
              var keys = Object.keys(lastMap || {});
              if(keys && keys.length === 1) iso = lastMap[keys[0]];
            }
            var ms = iso ? parseIsoToMs(iso) : NaN;
            var a2 = Number.isFinite(ms) ? Math.max(0, Math.floor((Date.now() - ms)/1000)) : NaN;
            var a2Txt = Number.isFinite(a2) ? (a2 >= 3600 ? (Math.floor(a2/3600) + 'h') : (a2 >= 60 ? (Math.floor(a2/60) + 'm') : (a2 + 's'))) : '—';
            ingestTxt = ' · ingest: ' + a2Txt + ' ago';
          }
        } catch(_e){}

        setUpdateChip(status, 'Fetched: ' + hh + ':' + mm + ':' + ss + ' · ' + mode + ' · data: ' + dataTxt + ' (' + ageTxt + ' ago)' + ingestTxt);
      })();
    } catch(e){
      console.error(e);
      state.data = [];
      draw();
      var msg = String(e && e.message ? e.message : e);
      if(ui.reqInfo) ui.reqInfo.textContent = 'bar_s=' + Math.floor(bar_s) + ' (error: ' + msg + ')';
      (function(){
        var now = new Date();
        var hh = String(now.getHours()).padStart(2,'0');
        var mm = String(now.getMinutes()).padStart(2,'0');
        var ss = String(now.getSeconds()).padStart(2,'0');
        setUpdateChip('err', 'Last update: ' + hh + ':' + mm + ':' + ss + ' · ERROR');
      })();
      // Avoid blocking alerts for transient reload/network blips; rely on footer + console.
      // Common during uvicorn --reload restarts.
    } finally {
      if(ui.regen){ ui.regen.disabled = false; ui.regen.textContent = regenButtonLabel(); }
    }
  }

  async function loadFromStatic(force){
    // Keep UI behavior similar to API version, but load from ./static/bars/<symbol>_<bar_s>.json
    if(!force && ui.regen && ui.regen.disabled) return;
    state._reqSeq = (state._reqSeq || 0) + 1;
    var myReq = state._reqSeq;

    var symbol = String(getSymbol() || '').trim();
    if(!symbol) symbol = 'ES_CONT';

    // Bar size
    var bar_s = clamp(Number(state.windowSec || (ui.window ? ui.window.value : 60) || 60), 30, 86400);
    if(!Number.isFinite(bar_s)) bar_s = 60;
    bar_s = snapToPreset(bar_s);
    state.windowSec = bar_s;
    if(ui.window) ui.window.value = String(bar_s);
    if(ui.windowVal) ui.windowVal.textContent = formatWindow(bar_s);
    syncBarPresetUi();
    if(ui.reqInfo) ui.reqInfo.textContent = 'bar_s=' + Math.floor(bar_s) + ' (loading…)';

    var prevText = ui.regen ? ui.regen.textContent : '';
    if(ui.regen){ ui.regen.disabled = true; ui.regen.textContent = 'Loading…'; }

    function setUpdateChip(status, text){
      try{
        var dot = document.getElementById('updateDot');
        var el = document.getElementById('updateText');
        if(dot){
          dot.classList.remove('ok','live','warn','err');
          if(status === 'ok') dot.classList.add('ok');
          else if(status === 'warn') dot.classList.add('warn');
          else if(status === 'err') dot.classList.add('err');
        }
        if(el) el.textContent = String(text || '');
      } catch(_e){}
    }

    try{
      var t0 = (window.performance && performance.now) ? performance.now() : Date.now();
      var j = null;
      try{
        j = await loadStaticBars(symbol, bar_s);
      } catch(eLoad){
        // Fallback: if the exact bar_s file doesn't exist, try deriving it from the smallest available bars we have.
        var base = _staticBaseBySymbol[symbol] || null;
        if(!base){
          // try any cached payload for this symbol (pick smallest bar_s)
          var best = null;
          for(var kk in (_staticBarsByKey || {})){
            if(!Object.prototype.hasOwnProperty.call(_staticBarsByKey, kk)) continue;
            if(kk.indexOf(symbol + '_') !== 0) continue;
            var cand = _staticBarsByKey[kk];
            if(!cand) continue;
            var bs0 = Math.floor(Number(cand.bar_s) || 0);
            if(!Number.isFinite(bs0) || bs0 <= 0) continue;
            if(!best || bs0 < Math.floor(Number(best.bar_s) || 0)) best = cand;
          }
          base = best;
        }
        if(base){
          j = aggregateBarsPayload(base, bar_s);
          rememberBarsPayload(j);
        } else {
          throw eLoad;
        }
      }
      var t1 = (window.performance && performance.now) ? performance.now() : Date.now();
      if(myReq !== state._reqSeq) return; // stale

      // Bounds from payload
      if(j && j.dataset_start){
        var ds = parseIsoToMs(j.dataset_start);
        if(Number.isFinite(ds)) state.datasetStartMs = ds;
      }
      if(j && j.dataset_end){
        var de = parseIsoToMs(j.dataset_end);
        if(Number.isFinite(de)) state.datasetEndMs = de;
      }
      if(!Number.isFinite(state.datasetStartMs) && Array.isArray(j.t_ms) && j.t_ms.length) state.datasetStartMs = Number(j.t_ms[0]);
      if(!Number.isFinite(state.datasetEndMs) && Array.isArray(j.t_ms) && j.t_ms.length) state.datasetEndMs = Number(j.t_ms[j.t_ms.length-1]);
      updateSpanPresetAvailability();

      var t = j.t_ms, o = j.o, h = j.h, l = j.l, c = j.c, v = j.v;
      if(!Array.isArray(t) || !Array.isArray(o) || !Array.isArray(h) || !Array.isArray(l) || !Array.isArray(c) || !Array.isArray(v)){
        throw new Error('Unexpected JSON shape. Expected arrays: t_ms,o,h,l,c,v');
      }
      var n = t.length;
      if(o.length !== n || h.length !== n || l.length !== n || c.length !== n || v.length !== n){
        throw new Error('Mismatched array lengths in payload');
      }

      // Overlays (EMA/VWAP) computed from the loaded payload (static mode doesn't do session preloads).
      var overlays = [];
      try{
        var os = getOverlaySettings();
        if(os && anyOverlayEnabled(os)){
          overlays = computeOverlays(
            { t_ms: t, o: o, h: h, l: l, c: c, v: v },
            os,
            { symbol: symbol, bar_s: bar_s }
          );
        }
      } catch(_e){}

      var out = new Array(n);
      for(var i=0;i<n;i++){
        out[i] = { t:Number(t[i]), o:Number(o[i]), h:Number(h[i]), l:Number(l[i]), c:Number(c[i]), v:Number(v[i]), bid:NaN, ask:NaN };
      }
      state.followLatest = false;
      // Store full window, then filter displayed bars.
      state.dataFull = out;
      state.overlaysFull = overlays || [];
      state.data = out;
      state._sessionType = computeSessionTypesForData(out);
      // Compute HA only if HA candles are actually selected (avoid heavy work on every load).
      try{
        var needHa1 = !!(ui && ui.showCandles && ui.showCandles.checked && state && state.candleStyle === 'ha');
        state.ha = needHa1 ? computeHeikinAshi(out) : [];
      } catch(_eHa1){
        state.ha = [];
      }
      state.overlays = overlays || [];
      applySessionFilter({ skipSave: true, skipDraw: true });
      updateSessionCountsUi();
      state.hoverIdx = -1;
      if(!Number.isFinite(state.xZoom) || state.xZoom <= 0) state.xZoom = 1;
      rightAlignXView();
      draw();

      if(ui.reqInfo){
        var extra = '';
        try{
          if(j && j._derived_from_bar_s) extra = ' · derived_from=' + Math.floor(Number(j._derived_from_bar_s) || 0) + 's';
        } catch(_e){}
        ui.reqInfo.textContent = 'bars=' + n + ' · bar_s=' + Math.floor(bar_s) + extra + ' · load=' + Math.round(Math.max(0,t1-t0)) + 'ms';
      }
      setUpdateChip('ok', 'Loaded: ' + symbol + ' @ ' + Math.floor(bar_s) + 's');
    } catch(e){
      try{ setUpdateChip('err', 'Load error'); } catch(_e){}
      if(ui.reqInfo){
        var msg = String(e && e.message ? e.message : e);
        if(/Failed to fetch/i.test(msg)){
          msg += ' (if you are on file://, use Pick snapshot folder or Pick bars file)';
        }
        ui.reqInfo.textContent = 'Error: ' + msg;
      }
    } finally {
      if(ui.regen){ ui.regen.disabled = false; ui.regen.textContent = regenButtonLabel(); }
    }
  }

  async function pollLiveIncremental(){
    try{
      if(STATIC_MODE) return;
      if(!state.followLatest) return;
      if(state.dragging || state.yDragging) return;
      // Don't compete with an in-flight full request.
      if(ui.regen && ui.regen.disabled) return;
      // If we don't have a baseline yet, wait for the next full /window sync.
      if((!Array.isArray(state.dataFull) || state.dataFull.length === 0) && (!Array.isArray(state.data) || state.data.length === 0)) return;

      var sym = String(getSymbol() || '').trim();
      if(!sym) return;
      var barS = Math.floor(Number(state.windowSec || 60));
      if(!Number.isFinite(barS) || barS <= 0) barS = 60;
      barS = snapToPreset(clamp(barS, 60, 86400));

      var base = (Array.isArray(state.dataFull) && state.dataFull.length) ? state.dataFull : state.data;
      var lastT = Number(base[base.length - 1].t);
      if(!Number.isFinite(lastT)) return;
      // Overlap a couple buckets to handle in-progress-bar updates.
      var sinceMs = lastT - (barS * 1000 * 2);

      var url = liveSinceUrl(sym, sinceMs, barS, 2000);
      var res = await fetch(url, { method:'GET', cache:'no-store' });
      if(!res.ok) return;
      var j = await res.json();
      if(!j || !Array.isArray(j.t_ms) || !Array.isArray(j.o) || !Array.isArray(j.h) || !Array.isArray(j.l) || !Array.isArray(j.c) || !Array.isArray(j.v)) return;
      var t = j.t_ms, o = j.o, h = j.h, l = j.l, c = j.c, v = j.v;
      var n = t.length;
      if(!n) return;

      // Merge/append in time order.
      if(!Array.isArray(state.dataFull) || !state.dataFull.length){
        // Establish a full baseline if we only had filtered state.data.
        state.dataFull = Array.isArray(state.data) ? state.data.slice() : [];
      }
      for(var i=0;i<n;i++){
        var tt = Number(t[i]);
        if(!Number.isFinite(tt)) continue;
        var nb = { t: tt, o: Number(o[i]), h: Number(h[i]), l: Number(l[i]), c: Number(c[i]), v: Number(v[i]), bid: NaN, ask: NaN };
        var cur = state.dataFull;
        var m = cur.length;
        if(m === 0){
          cur.push(nb);
          continue;
        }
        var last = cur[m - 1];
        if(tt > last.t){
          cur.push(nb);
        } else if(tt === last.t){
          cur[m - 1] = nb;
        } else {
          // Rare: update earlier bucket (overlap). Replace if found, else insert.
          var idx = findIndexByTimeMs(cur, tt);
          if(idx >= 0 && idx < cur.length && cur[idx].t === tt){
            cur[idx] = nb;
          } else if(idx >= 0){
            cur.splice(idx, 0, nb);
          }
        }
      }

      // Re-apply session filtering to update the visible dataset.
      applySessionFilter({ skipSave: true, skipDraw: true });
      updateSessionCountsUi();
      // Following latest: keep right-aligned.
      rightAlignXView();
      draw();

      // If the server reports a live_end watermark, use it to keep datasetEndMs moving.
      if(j && j.live_end){
        var le = parseIsoToMs(j.live_end);
        if(Number.isFinite(le)){
          if(!Number.isFinite(state.datasetEndMs) || le > state.datasetEndMs) state.datasetEndMs = le;
        }
      }
      updateSpanPresetAvailability();
    } catch(_e){
      // ignore transient errors during reloads
    }
  }

  function draw(){
    var _drawT0 = (window.performance && performance.now) ? performance.now() : Date.now();
    var rect = canvas.getBoundingClientRect();
    var Wpx = rect.width;
    var Hpx = rect.height;
    var reason = '';
    try{ reason = (state && state._render) ? String(state._render.pendingReason || '') : ''; } catch(_e){ reason = ''; }

    ctx.clearRect(0, 0, Wpx, Hpx);
    ctx.save();
    ctx.fillStyle = 'rgba(15,22,32,0.55)';
    ctx.fillRect(0, 0, Wpx, Hpx);
    ctx.restore();

    var pad = 14;
    // Reserve space for the Y-axis price labels. We render the price axis on the RIGHT side.
    var yAxisW = 50;
    // Reserve space for X-axis tick labels so they don't get clipped at the bottom.
    // Slightly taller to support 2-line day labels (month + day) when zoomed out.
    var xAxisH = 40;
    var plotW = Math.max(1, Wpx - (pad*2 + yAxisW));
    var plotH = Math.max(1, Hpx - pad*2 - xAxisH);
    var plot = { x: pad, y: pad, w: plotW, h: plotH }; // full plot region (price+volume)
    var showVolume = ui.showVolume ? !!ui.showVolume.checked : false;
    var volSep = showVolume ? 8 : 0;
    var volH = 0;
    if(showVolume){
      // Default volume pane ~22% of plot height; clamp for small canvases.
      volH = clamp(Math.floor(plot.h * 0.22), 46, Math.floor(plot.h * 0.35));
      // Ensure we always leave a reasonable price pane (avoid negative heights on small charts).
      var maxVolH = Math.max(0, Math.floor(plot.h - 110));
      if(volH > maxVolH) volH = maxVolH;
    }
    var pricePlotH = Math.max(1, Math.floor(plot.h - (showVolume ? (volH + volSep) : 0)));
    var pricePlot = { x: plot.x, y: plot.y, w: plot.w, h: pricePlotH };
    var volPlot = null;
    if(showVolume && volH > 0){
      volPlot = { x: plot.x, y: pricePlot.y + pricePlot.h + volSep, w: plot.w, h: Math.max(1, plot.h - pricePlot.h - volSep) };
    }

    var bounds = computeYBounds();
    var yMin = bounds.min;
    var yMax = bounds.max;

    // If Auto-scale is disabled, use a slightly looser static range.
    if(!ui.scale.checked){
      var mid0 = (yMin + yMax) / 2;
      var span0 = (yMax - yMin) * 1.35;
      yMin = mid0 - span0/2;
      yMax = mid0 + span0/2;
    }

    // Apply interactive Y scale factor (drag the Y-axis up/down to zoom Y).
    var mid = (yMin + yMax) / 2;
    var span = (yMax - yMin) * clamp(state.yScaleFactor, 0.2, 6);
    if(!Number.isFinite(span) || span <= 0) span = 1;
    yMin = mid - span/2;
    yMax = mid + span/2;

    // Apply vertical panning (price-space). Positive yPan shifts the range up, moving data down.
    var yPan = Number(state.yPan) || 0;
    yMin += yPan;
    yMax += yPan;

    // Cache for mousemove pan scaling (dyPx -> price delta).
    state._lastYSpan = (yMax - yMin);
    // Only the price pane participates in Y pan/zoom interactions.
    state._lastPlotH = pricePlot.h;

    // y labels (aligned to the same "nice" tick positions used by the grid)
    ctx.save();
    ctx.fillStyle = 'rgba(215,224,234,0.85)';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    var yTicksInfo = computePriceTicks(yMin, yMax, pricePlot.h, 58);
    var yTicks = (yTicksInfo && yTicksInfo.ticks && yTicksInfo.ticks.length) ? yTicksInfo.ticks : null;
    if(!yTicks){
      // Fallback to legacy fixed-row labels if tick computation fails.
      var rows = 6;
      for(var i=0;i<=rows;i++){
        var tt = i/rows;
        var price = lerp(yMax, yMin, tt);
        var yy = pricePlot.y + pricePlot.h * tt;
        ctx.fillText(price.toFixed(2), pricePlot.x + pricePlot.w + 8, yy);
      }
    } else {
      var dec = decimalsForStep(yTicksInfo.step);
      for(var yi=0; yi<yTicks.length; yi++){
        var p = yTicks[yi];
        var yy = yForPrice(p, pricePlot, yMin, yMax);
        if(!Number.isFinite(yy)) continue;
        ctx.fillText(Number(p).toFixed(dec), pricePlot.x + pricePlot.w + 8, yy);
      }
    }
    ctx.restore();

    var n = state.data.length;
    if(!n){
      // Grid + "No data" message are still clipped to the plot area.
      ctx.save();
      roundRect(ctx, plot.x, plot.y, plot.w, plot.h, 14);
      ctx.clip();
      if(ui.grid.checked && pricePlot.w > 4 && pricePlot.h > 4) drawGrid(pricePlot);
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.font = '14px system-ui';
      ctx.fillText('No data', plot.x + 8, plot.y + 18);
      ctx.restore();
      ctx.restore(); // clip

      // Plot border (always visible)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      roundRect(ctx, plot.x, plot.y, plot.w, plot.h, 14);
      ctx.stroke();
      ctx.restore();
      return;
    }

    var vb = computeVisibleBars(n, state.xZoom);
    var barsVisibleData = vb.barsVisibleData;
    var barsVisible = vb.barsVisibleScale; // used for x mapping (includes replay padding)
    var maxOff = Math.max(0, n - barsVisibleData);
    // Keep the view right-aligned (to real data) when following latest (replay + normal mode).
    // This keeps the "now" head fixed, with the projection padding rendered to the right.
    if(state.followLatest && !state.dragging && !state.yDragging){
      state.xOffset = maxOff;
    } else if(!Number.isFinite(state.xOffset) || state.xOffset === 0){
      // Initial load fallback: right-align once.
      state.xOffset = maxOff;
    }
    state.xOffset = clamp(state.xOffset, 0, maxOff);

    var start = Math.floor(state.xOffset);
    var end = Math.min(n-1, start + barsVisibleData + 1);

    // --- Base-layer cache for hover/crosshair ---
    // We cache a rendered base canvas without hover overlay, and on mousemove we only blit
    // that cached base + draw the crosshair + axis labels.
    var baseKey = '';
    try{
      var os0 = getOverlaySettings();
      baseKey = [
        Math.floor(Wpx), Math.floor(Hpx),
        n,
        Number(state.data[0] && state.data[0].t) || 0,
        Number(state.data[n-1] && state.data[n-1].t) || 0,
        start, end,
        Math.round(Number(state.xZoom) * 1000) / 1000,
        Math.round(Number(state.xOffset) * 1000) / 1000,
        Math.round(Number(state.yScaleFactor) * 1000) / 1000,
        Math.round(Number(state.yPan) * 1000) / 1000,
        ui.scale && ui.scale.checked ? 1 : 0,
        ui.grid && ui.grid.checked ? 1 : 0,
        ui.showBands && ui.showBands.checked ? 1 : 0,
        ui.showCandles && ui.showCandles.checked ? 1 : 0,
        String(state.candleStyle || ''),
        ui.fills && ui.fills.checked ? 1 : 0,
        ui.smooth && ui.smooth.checked ? 1 : 0,
        ui.outer && ui.outer.checked ? 1 : 0,
        ui.avgline && ui.avgline.checked ? 1 : 0,
        ui.showVolume && ui.showVolume.checked ? 1 : 0,
        os0 && os0.ema9 ? 1 : 0,
        os0 && os0.ema21 ? 1 : 0,
        os0 && os0.ema50 ? 1 : 0,
        os0 && os0.vwap ? 1 : 0
      ].join('|');
    } catch(_eKey){
      baseKey = '';
    }
    try{
      if(state && state._render){
        if(!state._render.baseCanvas) state._render.baseCanvas = document.createElement('canvas');
      }
    } catch(_eBC){}

    function _drawHoverOnly(){
      // Re-use the already computed yMin/yMax/plot/start/end/barsVisible above.
      try{
        if(!(state.hoverIdx >= 0 && state.hoverIdx < n)) return;
        var hi2 = state.hoverIdx;
        var rawHd2 = state.data[hi2];
        if(!rawHd2) return;

        var hx2 = xForIndex(hi2 + 0.5, plot, barsVisible);
        var hy2 = Number(state.hoverY);
        if(!Number.isFinite(hy2)) hy2 = yForPrice(rawHd2.c, pricePlot, yMin, yMax);
        if(!Number.isFinite(hy2)) return;
        hy2 = clamp(hy2, pricePlot.y, pricePlot.y + pricePlot.h);
        var cursorPrice2 = (yMax - ((hy2 - pricePlot.y) / pricePlot.h) * (yMax - yMin));

        // Crosshair inside plot clip (rounded).
        ctx.save();
        var clipInset2 = 1;
        roundRect(ctx, plot.x + clipInset2, plot.y + clipInset2, plot.w - clipInset2*2, plot.h - clipInset2*2, 14 - clipInset2);
        ctx.clip();
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(hx2, plot.y);
        ctx.lineTo(hx2, plot.y + plot.h);
        ctx.moveTo(plot.x, hy2);
        ctx.lineTo(plot.x + plot.w, hy2);
        ctx.stroke();
        ctx.restore();
        ctx.restore(); // clip

        // Axis callouts (same style as main draw).
        var stepForAxis = NaN;
        try{
          var t0a = Number(state.data[start].t);
          var t1a = Number(state.data[end].t);
          if(Number.isFinite(t0a) && Number.isFinite(t1a) && t1a > t0a){
            stepForAxis = chooseTimeStepMs(t1a - t0a, plot.w, 140);
          }
        } catch(_e){}
        var axisBg = 'rgba(120,130,145,0.70)';
        var axisBorder = 'rgba(255,255,255,0.12)';
        var axisText = 'rgba(255,255,255,0.92)';

        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 3;
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textBaseline = 'middle';

        // Right price axis pill
        var ptxt = Number.isFinite(cursorPrice2) ? cursorPrice2.toFixed(2) : '';
        var pw = ctx.measureText(ptxt).width;
        var ph = 20;
        var pPadX = 10;
        var pBoxW = Math.max(44, pw + pPadX*2);
        var axisLeft = (plot.x + plot.w);
        var axisRight = axisLeft + yAxisW;
        var pInset = 4;
        var targetX = axisLeft + Math.floor((yAxisW - pBoxW) / 2);
        var minX = axisLeft - Math.max(0, (pBoxW - (yAxisW - pInset*2)));
        var maxX = axisRight - pBoxW - pInset;
        var pBoxX = clamp(targetX, minX, maxX);
        var pBoxY = clamp(hy2 - ph/2, pricePlot.y + 3, pricePlot.y + pricePlot.h - ph - 3);
        ctx.fillStyle = axisBg;
        ctx.strokeStyle = axisBorder;
        ctx.lineWidth = 1;
        roundRect(ctx, pBoxX, pBoxY, pBoxW, ph, 8);
        ctx.fill();
        ctx.shadowColor = 'rgba(0,0,0,0)';
        ctx.shadowBlur = 0;
        ctx.stroke();
        ctx.fillStyle = axisText;
        ctx.textAlign = 'center';
        ctx.fillText(ptxt, pBoxX + pBoxW/2, pBoxY + ph/2);

        // Bottom time/date pill
        var ttxt = formatAxisTimeUtc(rawHd2.t, stepForAxis);
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 3;
        var tw = ctx.measureText(ttxt).width;
        var th = 20;
        var tPadX = 10;
        var tBoxW = Math.max(54, tw + tPadX*2);
        var tBoxX = clamp(hx2 - tBoxW/2, plot.x + 3, plot.x + plot.w - tBoxW - 3);
        var tBoxY = plot.y + plot.h + (xAxisH - th) - 4;
        ctx.fillStyle = axisBg;
        ctx.strokeStyle = axisBorder;
        roundRect(ctx, tBoxX, tBoxY, tBoxW, th, 8);
        ctx.fill();
        ctx.shadowColor = 'rgba(0,0,0,0)';
        ctx.shadowBlur = 0;
        ctx.stroke();
        ctx.fillStyle = axisText;
        ctx.textAlign = 'center';
        ctx.fillText(ttxt, tBoxX + tBoxW/2, tBoxY + th/2);
      } catch(_eHover){}
    }

    try{
      if(reason === 'hover' && baseKey && state && state._render && state._render.baseCanvas && state._render.baseKey === baseKey){
        ctx.drawImage(state._render.baseCanvas, 0, 0, Wpx, Hpx);
        _drawHoverOnly();
        try{ state._render.pendingReason = ''; } catch(_e0){}
        return;
      }
    } catch(_eFast){}

    // Suppress hover rendering during base draw so we can cache it.
    var _savedHoverIdx = state.hoverIdx;
    var _savedHoverX = state.hoverX;
    var _savedHoverY = state.hoverY;
    state.hoverIdx = -1;
    state.hoverX = NaN;
    state.hoverY = NaN;

    // X-axis ticks + labels (adaptive with zoom/span)
    (function drawXAxis(){
      if(end <= start) return;
      var t0 = Number(state.data[start].t);
      var t1 = Number(state.data[end].t);
      if(!Number.isFinite(t0) || !Number.isFinite(t1) || t1 <= t0) return;

      var tInfo = computeTimeTicksBySpan(t0, t1, plot.w, 140);
      if(!tInfo) return;
      var stepMs = tInfo.stepMs;
      var first = tInfo.first;

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      // Match Y-axis label style (font + fill) for consistency.
      ctx.fillStyle = 'rgba(215,224,234,0.85)';
      ctx.lineWidth = 1;
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      var labelY = plot.y + plot.h + 8;
      // Webull-style zoomed-out axis: show months only; show year instead of "Dec".
      var isMonthMode = stepMs >= 14*24*60*60_000;
      var isDayMode = !isMonthMode && (stepMs >= 24*60*60_000);
      var prevTm = null;
      var lastLabelRight = -1e18;
      var labelPadPx = 6;

      if(isMonthMode){
        // Find the first bar of each visible month in ET.
        var monthStarts = [];
        var prevYm = '';
        for(var bi=start; bi<=end; bi++){
          var bt = Number(state.data[bi] && state.data[bi].t);
          if(!Number.isFinite(bt)) continue;
          var ym = fmtEt(bt, { year:'numeric', month:'2-digit' });
          if(!prevYm || ym !== prevYm){
            monthStarts.push({ idx: bi, t: bt });
            prevYm = ym;
          }
        }

        var mStep = chooseMonthStep(monthStarts.length, plot.w, 140);

        function _monthNumEt(ms){
          var m = fmtEt(ms, { month:'numeric' });
          var n = parseInt(String(m), 10);
          return Number.isFinite(n) ? n : NaN;
        }

        function _shouldShowMonth(mNum, step){
          // Always include December so we can show year labels (Webull pattern).
          if(mNum === 12) return true;
          if(step <= 1) return true;
          if(step === 2) return (mNum % 2 === 0);
          if(step === 3) return (mNum === 4 || mNum === 7 || mNum === 10);
          if(step === 6) return (mNum === 6);
          // step >= 12: only show December (handled above)
          return false;
        }

        for(var mi=0; mi<monthStarts.length; mi++){
          var m0 = monthStarts[mi];
          if(!m0) continue;
          var mNum = _monthNumEt(m0.t);
          if(!Number.isFinite(mNum)) continue;
          if(!_shouldShowMonth(mNum, mStep)) continue;

          var x0 = xForIndex(m0.idx + 0.5, plot, barsVisible);
          if(x0 < plot.x - 2 || x0 > plot.x + plot.w + 2) continue;

          // tick
          ctx.beginPath();
          ctx.moveTo(x0, plot.y + plot.h);
          ctx.lineTo(x0, plot.y + plot.h + 6);
          ctx.stroke();

          var label0 = (mNum === 12) ? fmtEt(m0.t, { year:'numeric' }) : fmtEt(m0.t, { month:'short' });
          if(label0){
            var lw0 = ctx.measureText(label0).width;
            var lleft0 = x0 - (lw0/2) - labelPadPx;
            var lright0 = x0 + (lw0/2) + labelPadPx;
            if(lleft0 >= lastLabelRight){
              ctx.fillText(label0, x0, labelY);
              lastLabelRight = lright0;
            }
          }
        }

        ctx.restore();
        return;
      }

      for(var tm = first; tm <= t1; tm += stepMs){
        var idx = findIndexByTimeMs(state.data, tm);
        if(idx < start) idx = start;
        if(idx > end) idx = end;
        var x = xForIndex(idx + 0.5, plot, barsVisible);
        if(x < plot.x - 2 || x > plot.x + plot.w + 2) continue;

        // tick
        ctx.beginPath();
        ctx.moveTo(x, plot.y + plot.h);
        ctx.lineTo(x, plot.y + plot.h + 6);
        ctx.stroke();

        if(isDayMode){
          var parts = formatDayLabelPartsUtc(tm, prevTm);
          // Month label (top line) only at transitions; day number always.
          var wTop = parts.top ? ctx.measureText(parts.top).width : 0;
          var wBot = parts.bottom ? ctx.measureText(parts.bottom).width : 0;
          var w = Math.max(wTop, wBot);
          var left = x - (w/2) - labelPadPx;
          var right = x + (w/2) + labelPadPx;
          if(left >= lastLabelRight){
            if(parts.top) ctx.fillText(parts.top, x, labelY - 2);
            if(parts.bottom) ctx.fillText(parts.bottom, x, labelY + 12);
            lastLabelRight = right;
          }
        } else {
          var label = formatTimeLabelUtc(tm, stepMs);
          if(label){
            var lw = ctx.measureText(label).width;
            var lleft = x - (lw/2) - labelPadPx;
            var lright = x + (lw/2) + labelPadPx;
            if(lleft >= lastLabelRight){
              ctx.fillText(label, x, labelY);
              lastLabelRight = lright;
            }
          }
        }
        prevTm = tm;
      }
      ctx.restore();
    })();

    // Clip all in-plot rendering (grid + bands + candles + avg + crosshair) to the rounded plot frame.
    // Important: do this AFTER drawing the X-axis labels, because labels live below the plot.
    ctx.save();
    // Inset the clip slightly so antialiased strokes/bars don't paint over the border.
    var clipInset = 1;
    roundRect(ctx, plot.x + clipInset, plot.y + clipInset, plot.w - clipInset*2, plot.h - clipInset*2, 14 - clipInset);
    ctx.clip();

    // Session shading behind everything else (grid/candles/bands/volume).
    drawSessionShading(plot, start, end, barsVisible);

    if(ui.grid.checked && pricePlot.w > 4 && pricePlot.h > 4){
      drawGrid(pricePlot, { yMin: yMin, yMax: yMax, plot: plot, start: start, end: end, barsVisible: barsVisible });
    }

    var showBands = ui.showBands ? !!ui.showBands.checked : true;
    var showCandles = ui.showCandles ? !!ui.showCandles.checked : false;

    // Allow both off: leaves only Avg/BidAsk (if enabled).
    var isBands = showBands;
    var isCandles = showCandles;

    // No-cross mode is the supported/primary band rendering mode for this demo.
    // The control exists for backwards compatibility but is hidden in the UI; keep it forced on
    // so band lines (including High/Low bands) remain stable and continuous.
    if(ui.nocross) ui.nocross.checked = true;
    var useNoCross = true;
    var doFill = !!ui.fills.checked;
    var doSmooth = !!ui.smooth.checked;

    // 'outer' controls: outer bands in Bands view, and wick visibility in Candles view.
    // Important: band fill should be able to render even when band outlines are hidden.
    // So outer-band selection must not depend on `isBands` (the outlines toggle).
    var showOuterBands = !!ui.outer.checked;
    // The "High/Low bands (or wicks)" toggle:
    // - In Bands mode: controls whether we draw the outer high/low envelope.
    // - In Candles mode: controls whether we draw candle wicks.
    var showWicks = !!ui.outer.checked && isCandles;

    var showAvg = !!ui.avgline.checked;
    var showBA = false;

    // colors
    var strokeTop    = 'rgba(80,220,140,0.85)';
    var strokeMiddle = 'rgba(90,150,255,0.85)';
    var strokeLower  = 'rgba(255,110,110,0.85)';

    var strokeMain = 'rgba(255,62,165,0.78)';
    var strokeAlt  = 'rgba(215,224,234,0.52)';
    var strokeHiLo = 'rgba(138,160,181,0.45)';

    // Candle/volume direction colors (shared)
    var upColor = 'rgb(30, 200, 170)';   // teal-green
    var dnColor = 'rgb(235, 65, 120)';   // magenta-red

    // points
    var pts0=[], pts1=[], pts2=[], pts3=[];
    var ptsO=[], ptsC=[], ptsL=[], ptsH=[];
    var ptsAvg=[];
    // Bid/ask data isn't provided by this API demo.
    var ptsBid=[];
    var ptsAsk=[];

    var prevSig = null;
    var candleW = clamp((plot.w / barsVisible) * 0.60, 2, 16);

    // Volume pane (optional): scaled to vMax over the visible bars.
    if(volPlot && volPlot.w > 2 && volPlot.h > 2){
      // Separator line between panes (subtle)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      var sepY = pricePlot.y + pricePlot.h + Math.floor(volSep * 0.5);
      ctx.beginPath();
      ctx.moveTo(plot.x, sepY);
      ctx.lineTo(plot.x + plot.w, sepY);
      ctx.stroke();
      ctx.restore();

      var vMax = 0;
      for(var vi=start; vi<=end; vi++){
        var vd = state.data[vi];
        if(!vd) continue;
        var vv = Number(vd.v);
        if(Number.isFinite(vv) && vv > vMax) vMax = vv;
      }

      if(vMax > 0){
        var vPad = 4;
        var vBottom = volPlot.y + volPlot.h - vPad;
        var vAvail = Math.max(1, volPlot.h - vPad*2);
        var barW = Math.max(1, Math.floor(candleW));
        for(var vbi=start; vbi<=end; vbi++){
          var bd = state.data[vbi];
          if(!bd) continue;
          var v = Number(bd.v);
          if(!Number.isFinite(v) || v <= 0) continue;
          var hpx = (v / vMax) * vAvail;
          if(hpx < 1) hpx = 1;
          var cx = xForIndex(vbi + 0.5, plot, barsVisible);
          var x0 = Math.floor(cx - barW/2);
          var y0 = Math.floor(vBottom - hpx);
          var isUpV = (Number(bd.c) >= Number(bd.o));
          ctx.save();
          // Volume bars: brighter, Webull-like (keep candle colors unchanged).
          ctx.fillStyle = isUpV ? 'rgba(0, 214, 180, 0.88)' : 'rgba(255, 60, 125, 0.88)';
          ctx.fillRect(x0, y0, barW, Math.floor(vBottom - y0));
          ctx.restore();
        }
      }
    }

    for(var bi=start; bi<=end; bi++){
      var d = state.data[bi];
      if(!d) continue;
      var x = xForIndex(bi + 0.5, plot, barsVisible);

      if(useNoCross){
        var vals = [d.o, d.c, d.l, d.h].slice().sort(function(a,b){ return a-b; });
        pts0.push([x, yForPrice(vals[0], pricePlot, yMin, yMax)]);
        pts1.push([x, yForPrice(vals[1], pricePlot, yMin, yMax)]);
        pts2.push([x, yForPrice(vals[2], pricePlot, yMin, yMax)]);
        pts3.push([x, yForPrice(vals[3], pricePlot, yMin, yMax)]);
      } else {
        var sig = orderSig(d);
        if(prevSig !== null && sig !== prevSig){
          ptsO.push([NaN, NaN]);
          ptsC.push([NaN, NaN]);
          ptsL.push([NaN, NaN]);
          ptsH.push([NaN, NaN]);
        }
        ptsO.push([x, yForPrice(d.o, pricePlot, yMin, yMax)]);
        ptsC.push([x, yForPrice(d.c, pricePlot, yMin, yMax)]);
        ptsL.push([x, yForPrice(d.l, pricePlot, yMin, yMax)]);
        ptsH.push([x, yForPrice(d.h, pricePlot, yMin, yMax)]);
        prevSig = sig;
      }

      var avg = (d.o + d.c + d.h + d.l) / 4;
      ptsAvg.push([x, yForPrice(avg, pricePlot, yMin, yMax)]);

      ptsBid.push([NaN, NaN]);
      ptsAsk.push([NaN, NaN]);
    }

    // Band fills (render behind candles for proper layering)
    // Fill bands should be independent from drawing band outlines:
    // - Bands only: outlines only
    // - Bands + Fill: outlines + fill
    // - Fill only: fill only (no outlines)
    if(useNoCross && doFill){
      if(showOuterBands){
        fillBetween(ctx, pts3, pts2, 'rgba(80,220,140,0.18)', doSmooth);
        fillBetween(ctx, pts2, pts1, 'rgba(90,150,255,0.18)', doSmooth);
        fillBetween(ctx, pts1, pts0, 'rgba(255,110,110,0.18)', doSmooth);
      } else {
        fillBetween(ctx, pts2, pts1, 'rgba(90,150,255,0.18)', doSmooth);
      }
    }

    // Candles
    if(isCandles){
      var cdata = (state.candleStyle === 'ha') ? state.ha : state.data;
      if(state.candleStyle === 'ha' && (!Array.isArray(state.ha) || state.ha.length !== state.data.length)){
        state.ha = computeHeikinAshi(state.data);
        cdata = state.ha;
      }
      for(var ci=start; ci<=end; ci++){
        var cd = cdata[ci];
        if(!cd) continue;
        var cx = xForIndex(ci + 0.5, plot, barsVisible);
        var yo = yForPrice(cd.o, pricePlot, yMin, yMax);
        var yc = yForPrice(cd.c, pricePlot, yMin, yMax);
        var yh = yForPrice(cd.h, pricePlot, yMin, yMax);
        var yl = yForPrice(cd.l, pricePlot, yMin, yMax);

        var isUp = (cd.c >= cd.o);
        var bodyColor = isUp ? upColor : dnColor;

        if(showWicks){
          ctx.save();
          ctx.strokeStyle = bodyColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx, yh);
          ctx.lineTo(cx, yl);
          ctx.stroke();
          ctx.restore();
        }
        var top = Math.min(yo, yc);
        var bot = Math.max(yo, yc);
        var bh = Math.max(1, bot - top);
        var bx = cx - candleW/2;
        var by = top;

        ctx.save();
        // Ensure candles are fully opaque regardless of any prior drawing.
        ctx.globalAlpha = 1;
        ctx.fillStyle = bodyColor;
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(bx, by, candleW, bh);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }

    // Band lines
    if(isBands && useNoCross){
      if(showOuterBands){
        strokePolyline(ctx, pts0, strokeLower, 1.4, doSmooth);
        strokePolyline(ctx, pts1, strokeMiddle, 1.6, doSmooth);
        strokePolyline(ctx, pts2, strokeMiddle, 1.6, doSmooth);
        strokePolyline(ctx, pts3, strokeTop, 1.8, doSmooth);
      } else {
        strokePolyline(ctx, pts1, strokeMiddle, 1.7, doSmooth);
        strokePolyline(ctx, pts2, strokeMiddle, 1.7, doSmooth);
      }
    } else if(isBands) {
      strokePolyline(ctx, ptsO, strokeAlt, 1.25, doSmooth);
      strokePolyline(ctx, ptsC, strokeMain, 1.8, doSmooth);
      strokePolyline(ctx, ptsL, strokeHiLo, 1.0, doSmooth);
      strokePolyline(ctx, ptsH, strokeHiLo, 1.0, doSmooth);
    }

    // Avg line
    if(showAvg){
      // Match the bright UI blue used elsewhere (screenshot).
      strokePolyline(ctx, ptsAvg, 'rgb(0, 162, 255)', 1.15, doSmooth);
    }

    // Indicator overlays (EMA/VWAP), aligned 1:1 with state.data.
    (function drawOverlays(){
      try{
        var ovs = state.overlays;
        if(!ovs || !ovs.length) return;
        for(var si=0; si<ovs.length; si++){
          var s = ovs[si];
          if(!s || !Array.isArray(s.y) || s.y.length < 2) continue;
          var pts = [];
          for(var bi=start; bi<=end; bi++){
            var x = xForIndex(bi + 0.5, plot, barsVisible);
            var yyv = Number(s.y[bi]);
            if(!Number.isFinite(yyv)){
              pts.push([NaN, NaN]);
            } else {
              pts.push([x, yForPrice(yyv, pricePlot, yMin, yMax)]);
            }
          }
          strokePolyline(ctx, pts, s.color || 'rgba(215,224,234,0.65)', (s.width || 1.25), doSmooth);
        }
      } catch(_e){}
    })();

    // Bid/ask dotted lines removed (not present in API data).

    // Hover label
    var hoverData = null;
    if(state.hoverIdx >= 0 && state.hoverIdx < n){
      var hi = state.hoverIdx;
      var rawHd = state.data[hi];
      var showHa = (state.candleStyle === 'ha');
      var hd = rawHd;
      if(showHa){
        if(!Array.isArray(state.ha) || state.ha.length !== state.data.length) state.ha = computeHeikinAshi(state.data);
        if(state.ha[hi]) hd = state.ha[hi];
      }
      var hx = xForIndex(hi + 0.5, plot, barsVisible);
      var hy = Number(state.hoverY);
      if(!Number.isFinite(hy)) hy = yForPrice(hd.c, pricePlot, yMin, yMax);
      hy = clamp(hy, pricePlot.y, pricePlot.y + pricePlot.h);

      // Cursor price derived from mouse Y (crosshair horizontal line).
      var cursorPrice = (yMax - ((hy - pricePlot.y) / pricePlot.h) * (yMax - yMin));

      // Store hover info; draw crosshair inside the clip, tooltip outside the clip.
      hoverData = { hi: hi, rawHd: rawHd, showHa: showHa, hd: hd, hx: hx, hy: hy, cursorPrice: cursorPrice };

      ctx.save();
      // Crosshair lines: vertical snapped to bar time, horizontal follows cursor price.
      ctx.strokeStyle = 'rgba(255,255,255,1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(hx, plot.y);
      ctx.lineTo(hx, plot.y + plot.h);
      ctx.moveTo(plot.x, hy);
      ctx.lineTo(plot.x + plot.w, hy);
      ctx.stroke();
      ctx.restore();
    }

    // End of plot clip region
    ctx.restore();

    // Crosshair axis callouts (outside the clip so they're never cut off).
    if(hoverData){
      var hi2 = hoverData.hi;
      var rawHd2 = hoverData.rawHd;
      var showHa2 = hoverData.showHa;
      var hd2 = hoverData.hd;
      var hx2 = hoverData.hx;
      var hy2 = hoverData.hy;
      var cursorPrice2 = hoverData.cursorPrice;

      // Axis callouts (Webull-like): right price label + bottom time/date label.
      var stepForAxis = NaN;
      try{
        var t0a = Number(state.data[start].t);
        var t1a = Number(state.data[end].t);
        if(Number.isFinite(t0a) && Number.isFinite(t1a) && t1a > t0a){
          stepForAxis = chooseTimeStepMs(t1a - t0a, plot.w, 140);
        }
      } catch(_e){}

      var axisBg = 'rgba(120,130,145,0.70)';
      var axisBorder = 'rgba(255,255,255,0.12)';
      var axisText = 'rgba(255,255,255,0.92)';

      // Small drop shadow (subtle)
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;

      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textBaseline = 'middle';

      // Right price axis label
      var ptxt = Number.isFinite(cursorPrice2) ? cursorPrice2.toFixed(2) : '';
      var pw = ctx.measureText(ptxt).width;
      var ph = 20;
      var pPadX = 10;
      var pBoxW = Math.max(44, pw + pPadX*2);
      // Place the price pill in the RIGHT axis gutter (Webull-style overlap).
      // If the pill is wider than the gutter, allow it to overlap slightly into the plot.
      var axisLeft = (plot.x + plot.w);
      var axisRight = axisLeft + yAxisW;
      var pInset = 4;
      var targetX = axisLeft + Math.floor((yAxisW - pBoxW) / 2);
      var minX = axisLeft - Math.max(0, (pBoxW - (yAxisW - pInset*2)));
      var maxX = axisRight - pBoxW - pInset;
      var pBoxX = clamp(targetX, minX, maxX);
      var pBoxY = clamp(hy2 - ph/2, pricePlot.y + 3, pricePlot.y + pricePlot.h - ph - 3);
      ctx.fillStyle = axisBg;
      ctx.strokeStyle = axisBorder;
      ctx.lineWidth = 1;
      roundRect(ctx, pBoxX, pBoxY, pBoxW, ph, 8);
      ctx.fill();
      // Crisp edge: no shadow on stroke
      ctx.shadowColor = 'rgba(0,0,0,0)';
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.fillStyle = axisText;
      ctx.textAlign = 'center';
      ctx.fillText(ptxt, pBoxX + pBoxW/2, pBoxY + ph/2);

      // Bottom time/date axis label (in X-axis reserved area)
      var ttxt = formatAxisTimeUtc(rawHd2.t, stepForAxis);
      var tw = ctx.measureText(ttxt).width;
      var th = 20;
      var tPadX = 10;
      var tBoxW = Math.max(54, tw + tPadX*2);
      var tBoxX = clamp(hx2 - tBoxW/2, plot.x + 3, plot.x + plot.w - tBoxW - 3);
      var tBoxY = plot.y + plot.h + (xAxisH - th) - 4;
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 3;
      ctx.fillStyle = axisBg;
      ctx.strokeStyle = axisBorder;
      roundRect(ctx, tBoxX, tBoxY, tBoxW, th, 8);
      ctx.fill();
      ctx.shadowColor = 'rgba(0,0,0,0)';
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.fillStyle = axisText;
      ctx.textAlign = 'center';
      ctx.fillText(ttxt, tBoxX + tBoxW/2, tBoxY + th/2);

      ctx.restore();
    }

    // Position marker pill (replay): show avg entry price + qty on the right axis.
    (function drawPositionAxisPill(){
      try{
        if(!(state && state.replay && state.replay.active && state.replay.lastState)) return;
        var st = state.replay.lastState;
        if(!st || !st.position) return;
        var q = Number(st.position.qty);
        var px = Number(st.position.avg_price);
        if(!Number.isFinite(q) || q === 0) return;
        if(!Number.isFinite(px)) return;

        var sideTag = (q < 0) ? 'S' : 'L';
        // Practice / gameplay UX requirement: color-code side tags.
        // - Longs: blue
        // - Shorts: purple
        var pillFill = (q < 0)
          ? 'rgba(147,51,234,0.92)'  // purple-600-ish
          : 'rgba(59,130,246,0.92)'; // blue-500-ish
        var qAbs = Math.abs(q);
        // Shares are integers in the UI; but we keep it robust for floats.
        var qTxt = (Math.abs(qAbs - Math.round(qAbs)) < 1e-9) ? String(Math.round(qAbs)) : qAbs.toFixed(2);
        // PnL indicator: arrow + signed unrealized PnL in parentheses.
        // Backend provides unrealized_pnl as an approximation from last close; good enough for UI.
        var unreal = Number(st.position.unrealized_pnl);
        var pnlPart = '';
        if(Number.isFinite(unreal)){
          var arrow = (unreal > 0) ? '↑' : ((unreal < 0) ? '↓' : '→');
          var s = (unreal >= 0 ? '+' : '') + unreal.toFixed(2);
          pnlPart = ' ' + arrow + ' (' + s + ')';
        }
        var txt = sideTag + ' ' + px.toFixed(2) + ' × ' + qTxt + pnlPart;

        // Compute Y position from price scale.
        var yy = yForPrice(px, pricePlot, yMin, yMax);
        if(!Number.isFinite(yy)) return;

        // If hover price pill is near this y, offset to avoid overlap.
        if(hoverData){
          var hy2 = Number(hoverData.hy);
          if(Number.isFinite(hy2) && Math.abs(hy2 - yy) < 24){
            yy = yy - 26;
          }
        }

        ctx.save();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';

        var ph2 = 20;
        var padX2 = 10;
        var tw2 = ctx.measureText(txt).width;
        var boxW = Math.max(64, tw2 + padX2 * 2);

        var axisLeft2 = (plot.x + plot.w);
        var axisRight2 = axisLeft2 + yAxisW;
        var inset2 = 4;
        var targetX2 = axisLeft2 + Math.floor((yAxisW - boxW) / 2);
        var minX2 = axisLeft2 - Math.max(0, (boxW - (yAxisW - inset2 * 2)));
        var maxX2 = axisRight2 - boxW - inset2;
        var boxX = clamp(targetX2, minX2, maxX2);
        var boxY = clamp(yy - ph2 / 2, pricePlot.y + 3, pricePlot.y + pricePlot.h - ph2 - 3);

        // Side-colored pill
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 3;
        ctx.fillStyle = pillFill;
        ctx.strokeStyle = 'rgba(255,255,255,0.14)';
        ctx.lineWidth = 1;
        roundRect(ctx, boxX, boxY, boxW, ph2, 10);
        ctx.fill();
        ctx.shadowColor = 'rgba(0,0,0,0)';
        ctx.shadowBlur = 0;
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,0.96)';
        ctx.fillText(txt, boxX + boxW / 2, boxY + ph2 / 2);
        ctx.restore();
      } catch(_e){}
    })();

    // Optional replay perf overlay: enable with ?replay_debug=1
    (function drawReplayPerfOverlay(){
      try{
        if(!(state && state.replay && state.replay.active && state.replay._debug && state.replay._debug.enabled)) return;
        var d = state.replay._debug;
        function fms(x){ return Number.isFinite(x) ? (Math.round(x) + 'ms') : '—'; }
        function fint(x){ return Number.isFinite(x) ? String(Math.round(x)) : '—'; }
        function lastList(arr, n){
          try{
            if(!Array.isArray(arr) || !arr.length) return '—';
            var m = Math.max(1, Math.floor(Number(n) || 10));
            var from = Math.max(0, arr.length - m);
            var xs = [];
            for(var i=from;i<arr.length;i++){
              var v = Number(arr[i]);
              xs.push(Number.isFinite(v) ? String(Math.round(v)) : '—');
            }
            return xs.join(',');
          } catch(_e){
            return '—';
          }
        }
        var bpm = (ui && ui.practiceSpeed) ? Number(ui.practiceSpeed.value) : NaN;
        var lines = [];
        lines.push('replay_debug');
        lines.push('bpm=' + (Number.isFinite(bpm) ? String(Math.round(bpm)) : '—') + ' target=' + fms(d.targetMs) + ' behind=' + fms(d.behindMs));
      lines.push('fetch=' + fms(d.lastFetchMs) + ' (max ' + fms(d.maxFetchMs) + ')'
        + ' render=' + fms(d.lastRenderMs) + ' (max ' + fms(d.maxRenderMs) + ')'
        + ' draw=' + fms(d.lastDrawMs) + ' (max ' + fms(d.maxDrawMs) + ')'
        + ' step=' + fms(d.lastStepMs) + ' (max ' + fms(d.maxStepMs) + ')'
        + ' behindMax=' + fms(d.maxBehindMs)
        + ' gapMax=' + fms(d.maxGapMs)
      );
        // List view: last durations (helps spot variability instantly)
        lines.push('last_gap_ms=[' + lastList(d._gap, 12) + ']');
        lines.push('last_step_ms=[' + lastList(d._step, 12) + ']');
        lines.push('last_fetch_ms=[' + lastList(d._fetch, 12) + ']');
        try{
          var qn = (state && state.replay && Array.isArray(state.replay._queue)) ? state.replay._queue.length : 0;
          var fs = (state && state.replay) ? (state.replay._fastStats || null) : null;
          var hits = fs ? (Number(fs.hits) || 0) : 0;
          var misses = fs ? (Number(fs.misses) || 0) : 0;
          var mode = fs ? String(fs.lastMode || '') : '';
          lines.push('queue=' + String(qn) + ' fast=' + String(hits) + '/' + String(misses) + ' mode=' + (mode || '—'));
        } catch(_eFsLine){}
        lines.push('n=' + String(state.data ? state.data.length : 0) + ' xOff=' + fint(state.xOffset) + ' zoom=' + (Number.isFinite(state.xZoom) ? state.xZoom.toFixed(2) : '—'));
      try{
        var st = state.replay.lastState || null;
        var endIso = (st && st.clock && st.clock.disp_window) ? String(st.clock.disp_window.end || '') : '';
        if(endIso){
          lines.push('disp_end=' + endIso);
          d.lastDispEnd = endIso;
          d.lastDispEndAt = Date.now();
        }
      } catch(_eClock){}

        ctx.save();
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        var pad = 8;
        var lh = 16;
        var w = 0;
        for(var i=0;i<lines.length;i++){
          var tw = ctx.measureText(lines[i]).width;
          if(tw > w) w = tw;
        }
        w = Math.ceil(w + pad*2);
        var h = Math.ceil(lines.length * lh + pad*2);
        var x = plot.x + 10;
        var y = plot.y + 10;
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        roundRect(ctx, x, y, w, h, 10);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = 'rgba(235,245,255,0.92)';
        for(var j=0;j<lines.length;j++){
          ctx.fillText(lines[j], x + pad, y + pad + j*lh);
        }
        ctx.restore();
      } catch(_e){}
    })();

    // Plot border
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    roundRect(ctx, plot.x, plot.y, plot.w, plot.h, 14);
    ctx.stroke();
    ctx.restore();

    // Cache base layer (without hover overlay) for future hover-only draws.
    try{
      if(state && state._render && state._render.baseCanvas){
        var bc = state._render.baseCanvas;
        if(bc.width !== canvas.width || bc.height !== canvas.height){
          bc.width = canvas.width;
          bc.height = canvas.height;
        }
        var bctx = bc.getContext('2d');
        if(bctx){
          bctx.setTransform(1,0,0,1,0,0);
          bctx.clearRect(0,0,bc.width,bc.height);
          bctx.drawImage(canvas, 0, 0);
          state._render.baseKey = baseKey;
          state._render.baseW = bc.width;
          state._render.baseH = bc.height;
        }
      }
    } catch(_eCache){}

    // Restore hover state and draw hover overlay on top.
    state.hoverIdx = _savedHoverIdx;
    state.hoverX = _savedHoverX;
    state.hoverY = _savedHoverY;
    _drawHoverOnly();
    try{ if(state && state._render) state._render.pendingReason = ''; } catch(_e1){}

    // Record draw cost (after all rendering).
    try{
      if(state && state.replay && state.replay.active && state.replay._debug && state.replay._debug.enabled){
        var _drawT1 = (window.performance && performance.now) ? performance.now() : Date.now();
        var dm = Math.max(0, _drawT1 - _drawT0);
        state.replay._debug.lastDrawMs = dm;
        try{
          state.replay._debug._draw.push(dm);
          while(state.replay._debug._draw.length > (state.replay._debug._N || 60)) state.replay._debug._draw.shift();
          var md = -Infinity;
          for(var kk=0; kk<state.replay._debug._draw.length; kk++){
            var z = Number(state.replay._debug._draw[kk]);
            if(Number.isFinite(z) && z > md) md = z;
          }
          state.replay._debug.maxDrawMs = (md === -Infinity) ? NaN : md;
        } catch(_eArr3){}
      }
    } catch(_eDrawMs){}
  }

  // interaction
  function updateHover(e){
    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var yAxisW = 50;
    var xAxisH = 40;
    var plotW = Math.max(1, r.width - (pad*2 + yAxisW));
    var plotX = pad;
    var plotY = pad;
    var plotH = Math.max(1, r.height - pad*2 - xAxisH);

    var n = state.data.length;
    if(!n) return;

    var vb = computeVisibleBars(n, state.xZoom);
    var barsVisible = vb.barsVisibleScale;
    var x = e.clientX - r.left;
    var y = e.clientY - r.top;

    // Keep hover only when inside the plot area (not in axes).
    if(x < plotX || x > plotX + plotW || y < plotY || y > plotY + plotH){
      state.hoverIdx = -1;
      state.hoverX = NaN;
      state.hoverY = NaN;
      requestDraw('hover');
      return;
    }

    var t = (x - plotX) / plotW;
    var idx = Math.floor(state.xOffset + t * barsVisible);
    state.hoverIdx = clamp(idx, 0, n-1);
    state.hoverX = x;
    state.hoverY = y;
    requestDraw('hover');
  }

  canvas.addEventListener('mousemove', function(e){
    if(state.yDragging){
      var r = canvas.getBoundingClientRect();
      var dyPx = (e.clientY - r.top) - state.dragY0;
      // dy>0 => zoom out (expand span); dy<0 => zoom in
      var f = state.yScale0 * Math.exp(dyPx * 0.006);
      state.yScaleFactor = clamp(f, 0.2, 6);
      requestDraw('pan');
    } else if(state.dragging){
      var r = canvas.getBoundingClientRect();
      var dxPx = (e.clientX - r.left) - state.dragX0;
      var dyPx = (e.clientY - r.top) - state.dragY0;
      var n = state.data.length;
      var vb = computeVisibleBars(n, state.xZoom);
      var barsVisible = vb.barsVisibleScale;
      // Keep in sync with draw(): reserve 50px for the right-side Y-axis gutter.
      var yAxisW = 50;
      var plotW = Math.max(1, r.width - (14*2 + yAxisW));
      var barsPerPx = barsVisible / plotW;
      state.xOffset = state.xOffset0 - dxPx * barsPerPx;
      state.lastDragDx = dxPx;

      // Vertical pan: convert pixel delta to price-space delta using the last computed span.
      var span = Number(state._lastYSpan);
      var ph = Number(state._lastPlotH);
      if(Number.isFinite(span) && span > 0 && Number.isFinite(ph) && ph > 0){
        state.yPan = Number(state.yPan0) + (dyPx / ph) * span;
      }
      requestDraw('pan');
    } else {
      updateHover(e);
    }
  });

  canvas.addEventListener('mouseleave', function(){
    state.hoverIdx = -1;
    state.hoverX = NaN;
    state.hoverY = NaN;
    state.dragging = false;
    state.yDragging = false;
    requestDraw('hover');
  });

  canvas.addEventListener('mousedown', function(e){
    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var yAxisW = 50;
    var plotRight = r.width - pad - yAxisW; // plot.x(=pad) + plot.w
    var x = (e.clientX - r.left);
    var y = (e.clientY - r.top);

    // Any mouse interaction implies manual exploration; stop snapping back to latest.
    state.followLatest = false;

    // If user clicks in the Y-axis area (right of plot), start Y-zoom drag.
    if(x > plotRight){
      state.yDragging = true;
      state.dragY0 = y;
      state.yScale0 = state.yScaleFactor;
      return;
    }

    // Otherwise, pan on X.
    state.dragging = true;
    state.dragX0 = x;
    state.dragY0 = y;
    state.xOffset0 = state.xOffset;
    state.yPan0 = Number(state.yPan) || 0;
  });

  canvas.addEventListener('dblclick', function(e){
    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var yAxisW = 50;
    var plotRight = r.width - pad - yAxisW; // right edge of plot area; Y-axis region is x > plotRight
    var x = (e.clientX - r.left);

    if(x > plotRight){
      e.preventDefault();
      e.stopPropagation();
      yAxisAutoFit();
    }
  });
    
  window.addEventListener('mouseup', function(){
    // If user panned into an edge, shift the requested window and refetch to browse history.
    // Older data: drag chart right => dx>0 => xOffset decreases and clamps to 0.
    // Newer data: drag chart left  => dx<0 => xOffset increases and clamps to max.
    try{
      if(!state.dragging) { state.lastDragDx = 0; }
      var dx = Number(state.lastDragDx) || 0;
      var n = state.data.length;
      if(n && Math.abs(dx) > 40){
        var vb = computeVisibleBars(n, state.xZoom);
        var barsVisibleData = vb.barsVisibleData;
        var maxOff = Math.max(0, n - barsVisibleData);
        var atLeft = (state.xOffset <= 0.0001);
        var atRight = (state.xOffset >= maxOff - 0.0001);

        var span = Number(state.viewSpanMs);
        var endMs = Number(state.viewEndMs);
        if(Number.isFinite(span) && span > 0 && Number.isFinite(endMs)){
          var step = Math.max(60*1000, Math.floor(span * 0.7));
          if(atLeft && dx > 0){
            // go older
            state.followLatest = false;
            var newEnd = endMs - step;
            if(Number.isFinite(state.datasetStartMs)){
              newEnd = Math.max(newEnd, state.datasetStartMs + span);
            }
            if(newEnd !== endMs){
              state.viewEndMs = newEnd;
              loadFromAPI();
            }
          } else if(atRight && dx < 0){
            // go newer
            var newEnd2 = endMs + step;
            if(Number.isFinite(state.datasetEndMs)){
              newEnd2 = Math.min(newEnd2, state.datasetEndMs);
              if(newEnd2 === state.datasetEndMs) state.followLatest = true;
            } else {
              state.followLatest = false;
            }
            if(newEnd2 !== endMs){
              state.viewEndMs = newEnd2;
              loadFromAPI();
            }
          }
        }
      }
    } catch(_e){
      // ignore pan-to-fetch failures
    }
    state.dragging = false;
    state.yDragging = false;
    state.lastDragDx = 0;
  });

  canvas.addEventListener('wheel', function(e){
    e.preventDefault();
    // Zooming is manual exploration; stop snapping back to latest.
    state.followLatest = false;
    var n = state.data.length;
    if(!n) return;

    var zoomFactor = Math.exp(-e.deltaY * 0.0015);
    var oldZoom = state.xZoom;
    // Allow deep zoom-in; bar size minimum stays at 1m.
    var newZoom = clamp(oldZoom * zoomFactor, 1, 256);

    var r = canvas.getBoundingClientRect();
    var pad = 14;
    var yAxisW = 50;
    var plotX = pad;
    var plotW = Math.max(1, r.width - (pad*2 + yAxisW));
    var mouseX = (e.clientX - r.left);
    var tt = clamp((mouseX - plotX) / plotW, 0, 1);

    var vbOld = computeVisibleBars(n, oldZoom);
    var vbNew = computeVisibleBars(n, newZoom);
    var oldBarsVisible = vbOld.barsVisibleScale;
    var newBarsVisible = vbNew.barsVisibleScale;

    // Anchor in data-index space (clamp to real bars to avoid "anchoring" into future padding).
    var anchorBar = clamp(state.xOffset + tt * oldBarsVisible, 0, Math.max(0, n - 1));
    state.xZoom = newZoom;
    state.xOffset = anchorBar - tt * newBarsVisible;

    draw();
    // Update the selector immediately (UI-only) based on what the user now sees.
    try{ syncSpanPresetFromNavigation({ skipSave: true, skipUrl: true }); } catch(_e){}

    // If user zooms out to the point where we would show (nearly) all loaded bars, expand the
    // requested window span and refetch more history so zoom-out keeps working.
    try{
      // Important: when already clamped at xZoom==1, further zoom-out attempts won't change zoom.
      // Detect that via wheel direction (deltaY>0) and expand span repeatedly.
      var tryingZoomOut = (e && Number(e.deltaY) > 0);
      var atMinZoom = (oldZoom <= 1.01 && newZoom <= 1.01);
      var shouldExpand = (tryingZoomOut && atMinZoom) || (newZoom <= 1.01 && oldZoom > newZoom);
      if(shouldExpand && Number.isFinite(state.datasetStartMs) && Number.isFinite(state.datasetEndMs) && Number.isFinite(state.viewSpanMs) && Number.isFinite(state.viewEndMs)){
        var fullSpan = Math.max(60*1000, Number(state.datasetEndMs) - Number(state.datasetStartMs));
        var curSpan = clamp(Number(state.viewSpanMs), 60*1000, fullSpan);
        if(curSpan < fullSpan - 60*1000){
          // Manual zoom implies exploration; don't follow latest.
          state.followLatest = false;
          // Jump faster to reduce the number of expensive /window scans needed to reach full history.
          var monthMs = 30 * 24 * 60 * 60 * 1000;
          var nextSpan = (curSpan >= monthMs) ? fullSpan : Math.floor(curSpan * 4.0);
          state.viewSpanMs = Math.min(fullSpan, Math.max(curSpan + 60*1000, nextSpan));
          syncSpanPresetFromNavigation();
          if(windowTimer) clearTimeout(windowTimer);
          windowTimer = setTimeout(function(){ loadFromAPI(); }, 90);
        }
      }
    } catch(_e){}

    // Debounce persistence (URL + localStorage) so we don't spam while wheel-scrolling.
    try{
      if(state._spanPresetCommitTimer) clearTimeout(state._spanPresetCommitTimer);
      state._spanPresetCommitTimer = setTimeout(function(){
        try{ syncSpanPresetFromNavigation({ skipSave: false, skipUrl: false }); } catch(_e2){}
      }, 220);
    } catch(_e3){}

    // Auto W recompute on zoom: if the recommended bar size changes, refetch.
    try{
      if(ui.autoW && ui.autoW.checked && Number.isFinite(state.viewSpanMs) && state.viewSpanMs > 0){
        var vis = getVisibleSpanMs(state.viewSpanMs);
        var effMaxBars = (getQueryParam('max_bars','') !== '' ? getQueryParam('max_bars','') : (getQueryParam('limit','') !== '' ? getQueryParam('limit','') : '5000'));
        var rec = recommendBarSecForVisibleSpan(vis, effMaxBars);
        rec = snapToPreset(rec);
        if(Math.floor(rec) !== Math.floor(state.windowSec)){
          state.windowSec = rec;
          if(ui.window) ui.window.value = String(rec);
          if(ui.windowVal) ui.windowVal.textContent = formatWindow(rec);
          syncBarPresetUi();
          updateUrlBarSize();
          if(windowTimer) clearTimeout(windowTimer);
          windowTimer = setTimeout(function(){ loadFromAPI(); }, 90);
        }
      }
    } catch(_e){}
  }, { passive:false });

  var windowTimer = null;
  function updateUrlBarSize(){
    try{
      var u = new URL(window.location.href);
      u.searchParams.set('bar_s', String(Math.floor(state.windowSec)));
      // Time scale preset (requested span).
      if(state && state.spanPreset) u.searchParams.set('span', String(state.spanPreset));
      if(ui.autoW && ui.autoW.checked) u.searchParams.set('auto_w', '1');
      else u.searchParams.delete('auto_w');
      u.searchParams.set('max_bars', String(Math.floor(Number(getQueryParam('max_bars','') || '5000') || 5000)));
      // Legacy param: keep reading it on load, but don't keep emitting it.
      u.searchParams.delete('w');
      window.history.replaceState(null, '', u.toString());
    } catch(e){
      // Ignore URL update failures (e.g., very old browsers / unusual environments).
    }
  }

  function setWindowSecFromUI(fromSlider){
    // If the user touches the bar size slider, treat that as a manual override and disable Auto W.
    enforceAlwaysOnOptions();
    // Any direct interaction implies the user is exploring history; stop snapping back to latest.
    if(fromSlider) state.followLatest = false;
    if(fromSlider && ui.autoW) ui.autoW.checked = false;
    var w = Number(ui.window.value);
    // App is always in snapped mode: bar size is restricted to preset increments.
    w = snapToPreset(w);
    state.windowSec = clamp(w, 60, 86400);

    ui.windowVal.textContent = formatWindow(state.windowSec);
    ui.window.value = String(state.windowSec);
    syncBarPresetUi();

    updateUrlBarSize();
    scheduleSaveUiConfig();

    // Replay mode: bar size (W) is governed by the replay display clock (disp_tf_sec) and
    // the frontend intentionally re-syncs `state.windowSec` from server state every step.
    // That makes bar-size changes appear "ignored" during an active replay session.
    // UX improvement: changing bar size while replay is active will restart replay using the new disp_tf_sec.
    try{
      if(state && state.replay && state.replay.active){
        // Preserve whether the user was playing so we can auto-resume.
        var wasPlaying = !!state.replay.playing;
        _setPracticeStatus('Restarting replay with new bar size…');
        // Start a brand-new session using current UI settings (including state.windowSec as disp_tf_sec).
        // This is the simplest way to "change resolution" in replay without introducing mid-session resampling.
        replayStart({ autoPlay: wasPlaying, preserveUi: true });
        return;
      }
    } catch(_eReplayW){}

    if(windowTimer) clearTimeout(windowTimer);
    windowTimer = setTimeout(function(){ loadFromAPI(); }, 120);
  }

  if(ui.autoW) ui.autoW.addEventListener('change', function(){ setWindowSecFromUI(false); });
  // Bar size radios (footer).
  (function bindBarPresetRadios(){
    try{
      var els = document.querySelectorAll('input[type="radio"][name="windowPreset"]');
      for(var i=0;i<els.length;i++){
        (function(el){
          if(!el) return;
          el.addEventListener('change', function(){
            try{
              if(!el.checked) return;
              if(ui.window) ui.window.value = String(el.value);
              setWindowSecFromUI(true);
            } catch(_e){}
          });
        })(els[i]);
      }
      syncBarPresetUi();
    } catch(_e){}
  })();
  // Scale preset radios (footer).
  (function bindSpanPresetRadios(){
    try{
      var els = document.querySelectorAll('input[type="radio"][name="spanPreset"]');
      for(var i=0;i<els.length;i++){
        (function(el){
          if(!el) return;
          el.addEventListener('change', function(){
            try{
              if(!el.checked) return;
              setSpanPreset(el.value, { skipLoad: false, skipSave: false, skipUrl: false });
            } catch(_e){}
          });
        })(els[i]);
      }
      syncSpanPresetUi();
    } catch(_e){}
  })();
  // Candle style dropdown interactions
  if(ui.candleStyleBtn){
    ui.candleStyleBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      toggleCandleStyleMenu();
    });
  }
  if(ui.candleStyleMenu){
    ui.candleStyleMenu.addEventListener('click', function(e){
      var t = e.target;
      if(!t || !t.getAttribute) return;
      var v = t.getAttribute('data-value');
      if(!v) return;
      setCandleStyle(v);
      closeCandleStyleMenu();
      scheduleSaveUiConfig();
      draw();
    });
  }
  document.addEventListener('click', function(e){
    // Close any open dropdown when clicking outside.
    if(ui.tickerDD && ui.tickerDD.classList.contains('open')){
      if(!(e && e.target && ui.tickerDD.contains(e.target))) closeTickerMenu();
    }
    if(ui.symbolDD && ui.symbolDD.classList.contains('open')){
      if(!(e && e.target && ui.symbolDD.contains(e.target))) closeSymbolMenu();
    }
    if(ui.candleStyleDD && ui.candleStyleDD.classList.contains('open')){
      if(!(e && e.target && ui.candleStyleDD.contains(e.target))) closeCandleStyleMenu();
    }
  });
  document.addEventListener('keydown', function(e){
    if(e && e.key === 'Escape'){
      closeTickerMenu();
      closeSymbolMenu();
      closeCandleStyleMenu();
    }
  });
  // (goLive removed)

  function onToggleDraw(){
    draw();
    scheduleSaveUiConfig();
  }

  function onSessionFilterChanged(e){
    // Use TradingView-style filtering: remove off-hours bars from the rendered dataset.
    // Guard: never allow all sessions to be disabled (otherwise the chart becomes empty/blank).
    try{
      var pre = ui.sessPreMarket ? !!ui.sessPreMarket.checked : true;
      var after = ui.sessAfterHours ? !!ui.sessAfterHours.checked : true;
      var closed = ui.sessClosed ? !!ui.sessClosed.checked : true;
      if(!pre && !after && !closed){
        // Re-enable the one the user just tried to turn off.
        if(e && e.target && typeof e.target.checked === 'boolean') e.target.checked = true;
      }
    } catch(_e){}
    applySessionFilter({ skipSave: false, skipDraw: false });
  }

  function recomputeOverlaysFromState(){
    try{
      var s = getOverlaySettings();
      if(!s || !anyOverlayEnabled(s) || !Array.isArray(state.data) || !state.data.length){
        state.overlays = [];
        return;
      }
      var n = state.data.length;
      var t_ms = new Array(n);
      var o = new Array(n);
      var h = new Array(n);
      var l = new Array(n);
      var c = new Array(n);
      var v = new Array(n);
      for(var i=0;i<n;i++){
        var d = state.data[i];
        t_ms[i] = Number(d.t);
        o[i] = Number(d.o);
        h[i] = Number(d.h);
        l[i] = Number(d.l);
        c[i] = Number(d.c);
        v[i] = Number(d.v);
      }
      state.overlays = computeOverlays(
        { t_ms: t_ms, o: o, h: h, l: l, c: c, v: v },
        s,
        { symbol: String(getSymbol() || ''), bar_s: Math.floor(Number(state.windowSec) || 60) }
      );
    } catch(_e){
      state.overlays = [];
    }
  }

  async function onOverlayToggleChanged(){
    // EMA toggles can recompute locally; VWAP prefers a refetch (non-replay) so we can preload to session start.
    scheduleSaveUiConfig();
    async function apply(){
      var s = getOverlaySettings();
      if(s && s.vwap && !STATIC_MODE && !(state && state.replay && state.replay.active)){
        await loadFromAPI();
        return;
      }
      recomputeOverlaysFromState();
      draw();
    }
    try{
      // During gameplay, briefly pause stepping while we recompute overlays to avoid mid-frame clobbering.
      if(state && state.replay && state.replay.active){
        return await withReplayPaused(apply);
      }
      return await apply();
    } catch(_e){
      draw();
    }
  }
  ui.grid.addEventListener('change', onToggleDraw);
  ui.scale.addEventListener('change', onToggleDraw);
  ui.nocross.addEventListener('change', onToggleDraw);
  ui.fills.addEventListener('change', onToggleDraw);
  ui.smooth.addEventListener('change', onToggleDraw);
  ui.outer.addEventListener('change', onToggleDraw);
  ui.avgline.addEventListener('change', onToggleDraw);
  if(ui.indEma9) ui.indEma9.addEventListener('change', onOverlayToggleChanged);
  if(ui.indEma21) ui.indEma21.addEventListener('change', onOverlayToggleChanged);
  if(ui.indEma50) ui.indEma50.addEventListener('change', onOverlayToggleChanged);
  if(ui.indVwap) ui.indVwap.addEventListener('change', onOverlayToggleChanged);
  // Candle bias removed.
  if(ui.showBands) ui.showBands.addEventListener('change', onToggleDraw);
  if(ui.showVolume) ui.showVolume.addEventListener('change', onToggleDraw);
  if(ui.sessPreMarket) ui.sessPreMarket.addEventListener('change', onSessionFilterChanged);
  if(ui.sessAfterHours) ui.sessAfterHours.addEventListener('change', onSessionFilterChanged);
  if(ui.sessClosed) ui.sessClosed.addEventListener('change', onSessionFilterChanged);
  if(ui.showCandles) ui.showCandles.addEventListener('change', function(){
    syncCandleStyleEnabled();
    onToggleDraw();
  });

  // Practice / Play Mode (replay / practice-field).
  // Contract: see notes.txt (server returns {state, delta} and state is authoritative).
  function _setPracticeStatus(txt){
    try{
      if(!ui.practiceStatus) return;
      var t = String(txt || '');
      ui.practiceStatus.textContent = t;
      // Auto-hide when empty; only show errors / important messages.
      ui.practiceStatus.style.display = t ? '' : 'none';
    } catch(_e){}
  }
  function _practiceSpeedBpm(){
    try{
      var v = ui.practiceSpeed ? Number(ui.practiceSpeed.value) : NaN;
      if(!Number.isFinite(v) || v <= 0) v = 100;
      return clamp(Math.floor(v), 30, 150);
    } catch(_e){
      return 60;
    }
  }

  function _syncPracticeSpeedLabel(){
    try{
      if(!ui.practiceSpeedLabel) return;
      ui.practiceSpeedLabel.textContent = String(_practiceSpeedBpm());
    } catch(_e){}
  }

  function _setPracticeUiStateActive(active){
    // Two UI states:
    // - idle: show Play only
    // - active: show Pause + Reset only
    try{
      if(ui.practiceBtn) ui.practiceBtn.style.display = active ? 'none' : '';
      if(ui.practicePauseBtn) ui.practicePauseBtn.style.display = active ? '' : 'none';
      if(ui.practiceResetBtn) ui.practiceResetBtn.style.display = active ? '' : 'none';
    } catch(_e){}
    // While replay is active, lock time-scale UI to 1M to match simulator requirements.
    try{
      updateSpanPresetAvailability();
      syncSpanPresetUi();
    } catch(_e2){}
  }

  function _syncPracticePauseBtn(){
    // When a session is active:
    // - if playing: show "Pause"
    // - if paused:  show "Resume"
    try{
      if(!ui.practicePauseBtn) return;
      var playing = !!(state && state.replay && state.replay.playing);
      var lbl = ui.practicePauseBtn.querySelector('.practiceCtl__label');
      if(lbl) lbl.textContent = playing ? 'Pause' : 'Resume';
      ui.practicePauseBtn.title = playing ? 'Pause replay' : 'Resume replay';
      // Swap icon between pause and play for clarity.
      var icon = ui.practicePauseBtn.querySelector('.practiceCtl__icon');
      if(icon){
        icon.classList.toggle('practiceCtl__icon--pause', playing);
        icon.classList.toggle('practiceCtl__icon--play', !playing);
      }
    } catch(_e){}
  }

  function _stopReplayTimer(){
    // Pause stepping without ending the server session.
    try{
      if(state && state.replay){
        // Cancel any scheduled tick (supports both interval + timeout handles).
        try{ if(state.replay.timer) clearInterval(state.replay.timer); } catch(_e0){}
        try{ if(state.replay.timer) clearTimeout(state.replay.timer); } catch(_e1){}
        state.replay.timer = null;
        state.replay.playing = false;
        // Stop any RAF-driven playback loop.
        try{
          if(state.replay._rafId){
            cancelAnimationFrame(state.replay._rafId);
            state.replay._rafId = null;
          }
          state.replay._rafLastTs = 0;
          state.replay._rafAcc = 0;
        } catch(_eRaf){}
        // Clear any buffered states and in-flight prefetch flag.
        try{
          state.replay._queue = [];
          state.replay._prefetchInFlight = false;
          state.replay._needsDraw = false;
        } catch(_eQ){}
        // Cancel any in-progress loop scheduling; in-flight network calls will finish naturally.
        state.replay._loopToken = (Number(state.replay._loopToken) || 0) + 1;
      }
    } catch(_e){}
    _syncPracticePauseBtn();
  }

  function _startReplayLoop(intervalMs){
    // Buffered replay loop:
    // - Prefetch a batch of N future states from the server (single-flight)
    // - Consume them locally at an even cadence (RAF-driven), so network jitter doesn't change step timing
    if(!state || !state.replay) return;
    if(!state.replay.active || !state.replay.sessionId) return;

    // Stop any prior playback.
    _stopReplayTimer();

    state.replay.playing = true;
    state.replay._stepFailCount = 0;
    state.replay._loopToken = (Number(state.replay._loopToken) || 0) + 1;
    state.replay._queue = [];
    state.replay._prefetchInFlight = false;
    state.replay._rafLastTs = 0;
    state.replay._rafAcc = 0;
    state.replay._needsDraw = true;
    state.replay._lastUiUpdateAt = 0;
    _syncPracticePauseBtn();

    // Update debug targetMs (best-effort).
    try{
      if(state.replay._debug && state.replay._debug.enabled){
        // Prefer bpm-derived cadence, but keep intervalMs as a fallback.
        var bpm0 = _practiceSpeedBpm();
        var ms0 = Math.max(80, Math.floor(60000 / bpm0));
        var ms1 = Math.max(80, Math.floor(Number(intervalMs) || ms0));
        state.replay._debug.targetMs = ms1;
      }
    } catch(_eDbg0){}

    // Kick initial prefetch and start RAF loop.
    _replayMaybePrefetch(true);
    _replayStartRafLoop();
  }

  function _replayMsPerStep(){
    var bpm = _practiceSpeedBpm();
    return Math.max(80, Math.floor(60000 / bpm));
  }

  function _replayQueueLen(){
    try{ return (state && state.replay && Array.isArray(state.replay._queue)) ? state.replay._queue.length : 0; } catch(_e){ return 0; }
  }

  function _replayMaybePrefetch(force){
    try{
      if(!state || !state.replay) return;
      if(!state.replay.active || !state.replay.sessionId) return;
      if(!state.replay.playing) return;
      if(state.replay._prefetchInFlight) return;
      // Keep batches small: large `states[]` payloads create JSON parse spikes and can
      // *cause* the stop/start cadence even if we buffer.
      var low = 2;
      var want = 4; // batch size
      // If we detected a delta alignment issue, force an immediate resync fetch.
      if(state.replay.deltaMode && state.replay._forceResync){
        force = true;
        want = 1;
      }
      if(!force && _replayQueueLen() >= low) return;
      state.replay._prefetchInFlight = true;
      // Fetch a batch of future steps. We don't render immediately; we enqueue.
      _replayFetchBatch(want, null).then(function(states){
        try{
          if(!state || !state.replay) return;
          if(!Array.isArray(states) || !states.length) return;
          if(!Array.isArray(state.replay._queue)) state.replay._queue = [];
          // Append in order.
          for(var i=0;i<states.length;i++){
            state.replay._queue.push(states[i]);
          }
        } catch(_eQ){}
      }).catch(function(e){
        console.error(e);
        _setPracticeStatus('Replay prefetch failed: ' + String(e && e.message ? e.message : e));
        // Do not hard-stop on one failure; allow the next frame to retry.
      }).finally(function(){
        try{ if(state && state.replay) state.replay._prefetchInFlight = false; } catch(_eF){}
      });
    } catch(_e){}
  }

  function _replayConsumeOne(){
    try{
      if(!state || !state.replay) return false;
      if(!Array.isArray(state.replay._queue) || !state.replay._queue.length) return false;
      var item = state.replay._queue.shift();
      if(!item) return false;
      if(state.replay.deltaMode){
        var ok = _applyReplayDelta(item, { skipDraw: true });
        if(!ok) return false;
      } else {
        _renderReplayState(item, { skipDraw: true });
      }
      state.replay._needsDraw = true;
      return true;
    } catch(_e){
      return false;
    }
  }

  function _replayStartRafLoop(){
    try{
      if(!state || !state.replay) return;
      if(state.replay._rafId) return;
      var token = state.replay._loopToken;
      function frame(ts){
        try{
          if(!state || !state.replay) return;
          if(!state.replay.playing) { state.replay._rafId = null; return; }
          if(token !== state.replay._loopToken) { state.replay._rafId = null; return; }

          if(!state.replay._rafLastTs) state.replay._rafLastTs = ts;
          var dt = ts - state.replay._rafLastTs;
          state.replay._rafLastTs = ts;
          // Clamp dt to avoid huge catch-up loops after tab was backgrounded.
          if(!Number.isFinite(dt) || dt < 0) dt = 0;
          if(dt > 250) dt = 250;
          state.replay._rafAcc += dt;

          var ms = _replayMsPerStep();
          // Prevent unbounded accumulation (keeps playback feeling steady).
          if(state.replay._rafAcc > ms * 5) state.replay._rafAcc = ms * 2;

          var advanced = false;
          while(state.replay._rafAcc >= ms){
            var ok = _replayConsumeOne();
            if(!ok) break;
            advanced = true;
            state.replay._rafAcc -= ms;
          }

          // Keep the buffer topped up.
          if(advanced || _replayQueueLen() < 4){
            _replayMaybePrefetch(false);
          }

          // Draw only when state changed (reduces CPU while keeping responsiveness).
          if(state.replay._needsDraw){
            draw();
            state.replay._needsDraw = false;
          }

          // Throttle tiny UI updates (labels/tooltips) while replay is running.
          try{
            if(!state.replay._lastUiUpdateAt) state.replay._lastUiUpdateAt = ts;
            if(ts - state.replay._lastUiUpdateAt > 120){
              _syncPracticePauseBtn();
              state.replay._lastUiUpdateAt = ts;
            }
          } catch(_eUi){}

          state.replay._rafId = requestAnimationFrame(frame);
        } catch(_eFrame){
          console.error(_eFrame);
          try{ _stopReplayTimer(); } catch(_eStop){}
        }
      }
      state.replay._rafId = requestAnimationFrame(frame);
    } catch(_e){}
  }

  async function withReplayPaused(fn){
    var wasPlaying = !!(state && state.replay && state.replay.playing);
    if(wasPlaying) _stopReplayTimer();
    try{
      return await fn();
    } finally {
      if(wasPlaying && state && state.replay && state.replay.active && state.replay.sessionId){
        var bpm = _practiceSpeedBpm();
        var intervalMs = Math.max(80, Math.floor(60000 / bpm));
        _startReplayLoop(intervalMs);
      }
    }
  }

  async function _endReplaySession(){
    _stopReplayTimer();
    try{
      if(state && state.replay && state.replay.sessionId){
        await _postJson('/replay/end', { session_id: state.replay.sessionId });
      }
    } catch(_e0){}
    if(state && state.replay){
      state.replay.active = false;
      state.replay.sessionId = '';
      state.replay.lastState = null;
    }
    _setPracticeUiStateActive(false);
    // If the history modal is open, refresh it so the just-ended session appears immediately.
    try{
      if(ui.historyModal && ui.historyModal.style.display !== 'none'){
        loadTradeHistory();
      }
    } catch(_e2){}
  }

  function _clearReplayLocal(){
    // Clear local replay UI state without calling server.
    _stopReplayTimer();
    try{
      if(state && state.replay){
        state.replay.active = false;
        state.replay.sessionId = '';
        state.replay.lastState = null;
      }
    } catch(_e){}
    _setPracticeUiStateActive(false);
  }
  async function _postJson(url, payload){
    var res = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload || {}) });
    if(!res.ok){
      var t = '';
      try{ t = await res.text(); } catch(_e){}
      throw new Error('HTTP ' + res.status + ' ' + url + (t ? (': ' + t) : ''));
    }
    return await res.json();
  }

  async function _getJson(url){
    var res = await fetch(url, { method:'GET', cache:'no-store' });
    if(!res.ok){
      var t = '';
      try{ t = await res.text(); } catch(_e){}
      throw new Error('HTTP ' + res.status + ' ' + url + (t ? (': ' + t) : ''));
    }
    return await res.json();
  }

  function _setHistoryStatus(txt){
    try{
      if(ui.practiceHistoryStatus) ui.practiceHistoryStatus.textContent = String(txt || '');
    } catch(_e){}
  }

  function _setHistoryModalStatus(txt){
    try{
      if(ui.historyModalStatus) ui.historyModalStatus.textContent = String(txt || '');
    } catch(_e){}
  }

  function _showHistoryModal(show){
    try{
      if(!ui.historyModal) return;
      ui.historyModal.style.display = show ? '' : 'none';
      if(show){
        // Avoid background scroll when modal is open.
        document.body.style.overflow = 'hidden';
      } else {
        document.body.style.overflow = '';
      }
    } catch(_e){}
  }

  function _fmtDateShort(iso){
    var s = String(iso || '');
    if(!s) return '';
    // sqlite CURRENT_TIMESTAMP is often "YYYY-MM-DD HH:MM:SS"
    return s.replace('T',' ').slice(0,16);
  }

  function _fmtNum2(x){
    var n = Number(x);
    return Number.isFinite(n) ? n.toFixed(2) : '';
  }

  function _setHistoryViewMode(mode){
    // mode: 'cards' | 'ledger' | 'matrix'
    try{
      state.historyViewMode = (mode === 'matrix' || mode === 'ledger' || mode === 'cards') ? mode : 'cards';
      if(ui.historyViewCardsBtn){
        ui.historyViewCardsBtn.classList.toggle('btnToggleOn', state.historyViewMode === 'cards');
      }
      if(ui.historyViewLedgerBtn){
        ui.historyViewLedgerBtn.classList.toggle('btnToggleOn', state.historyViewMode === 'ledger');
      }
      if(ui.historyViewMatrixBtn){
        ui.historyViewMatrixBtn.classList.toggle('btnToggleOn', state.historyViewMode === 'matrix');
      }
    } catch(_e){}
  }

  function _fmtDur(sec){
    var s = Math.floor(Number(sec) || 0);
    if(!Number.isFinite(s) || s <= 0) return '';
    var h = Math.floor(s / 3600);
    var m = Math.floor((s % 3600) / 60);
    if(h > 0) return h + 'h ' + m + 'm';
    return m + 'm';
  }

  function _renderSessionCards(j){
    if(!ui.historyTableWrap) return;
    ui.historyTableWrap.innerHTML = '';
    var sessions = (j && Array.isArray(j.sessions)) ? j.sessions : [];
    // Cards: show most recent sessions first.
    // We sort by best-available timestamp (updated_at/t_end/created_at/t_start).
    try{
      sessions.sort(function(a,b){
        function key(s){
          if(!s) return 0;
          var iso = s.updated_at || s.t_end || s.created_at || s.t_start || '';
          var ms = parseIsoToMs(iso);
          return Number.isFinite(ms) ? ms : 0;
        }
        return key(b) - key(a);
      });
    } catch(_eSort){}
    if(!sessions.length){
      ui.historyTableWrap.innerHTML = '<div class="hint" style="padding:10px;">No sessions yet.</div>';
      return;
    }

    // Cards should not carry any ledger filter forward.
    try{ state.historySessionFilter = null; } catch(_e0){}

    var list = document.createElement('div');
    list.className = 'cardList';

    function pnlClass(v){
      var n = Number(v);
      if(!Number.isFinite(n) || n === 0) return 'pnlFlat';
      return n > 0 ? 'pnlPos' : 'pnlNeg';
    }

    function segClass(v){
      var n = Number(v);
      if(!Number.isFinite(n) || n === 0) return '';
      return n > 0 ? 'segPos' : 'segNeg';
    }

    for(var i=0;i<sessions.length;i++){
      var s = sessions[i] || {};
      var pnl = (s.pnl && (s.pnl.realized !== undefined)) ? Number(s.pnl.realized) : Number(s.realized);
      var act = s.activity || {};
      var strip = s.strip || {};
      var segs = Array.isArray(strip.segments) ? strip.segments : [];

      var card = document.createElement('div');
      card.className = 'sessCard';

      var hd = document.createElement('div');
      hd.className = 'sessCardHd';

      var left = document.createElement('div');
      var titleRow = document.createElement('div');
      titleRow.style.display = 'flex';
      titleRow.style.alignItems = 'center';
      titleRow.style.gap = '10px';
      var title = document.createElement('div');
      title.className = 'sessTitle';
      title.textContent = String((s.label || '') + ' · ' + (s.symbol || '—')).trim();

      // Badge (label_session) — place next to title per notes.
      var lab = s.session_label || null;
      if(lab && typeof lab === 'object'){
        var pill = document.createElement('div');
        var sev = String(lab.severity || 'neutral');
        var cls = (sev === 'good') ? 'badgeGood' : (sev === 'warn' ? 'badgeWarn' : (sev === 'bad' ? 'badgeBad' : 'badgeNeutral'));
        pill.className = 'badgePill ' + cls;
        pill.textContent = String(lab.label || '');
        pill.title = String(lab.reason || '');
        titleRow.appendChild(title);
        titleRow.appendChild(pill);
      } else {
        titleRow.appendChild(title);
      }
      var sub = document.createElement('div');
      sub.className = 'sessSub';
      var t0 = _fmtDateShort(s.t_start || s.created_at);
      var t1 = _fmtDateShort(s.t_end || s.updated_at);
      var dur = _fmtDur(s.duration_sec);
      sub.textContent = (t0 && t1) ? (t0 + ' → ' + t1 + (dur ? (' (' + dur + ')') : '')) : (t0 || t1 || '');
      left.appendChild(titleRow);
      left.appendChild(sub);

      var rightWrap = document.createElement('div');
      rightWrap.style.display = 'flex';
      rightWrap.style.flexDirection = 'column';
      rightWrap.style.alignItems = 'flex-end';
      rightWrap.style.gap = '6px';

      var headline = (s.outcome && (s.outcome.headline !== undefined) && (s.outcome.headline !== null)) ? String(s.outcome.headline) : '';
      var right = document.createElement('div');
      right.className = 'pnlBig ' + pnlClass(pnl);
      right.textContent = headline ? headline : (Number.isFinite(pnl) ? (pnl >= 0 ? '+' : '') + pnl.toFixed(2) : '—');

      rightWrap.appendChild(right);

      hd.appendChild(left);
      hd.appendChild(rightWrap);

      var bd = document.createElement('div');
      bd.className = 'sessBd';

      var mini = document.createElement('div');
      mini.className = 'miniRow';
      var roundTrips = (act && Number.isFinite(Number(act.round_trips))) ? Number(act.round_trips) : 0;
      var scaleIns = (act && Number.isFinite(Number(act.adds))) ? Number(act.adds) : 0;
      mini.innerHTML =
        '<span><span class="miniK">Round Trips:</span> ' + String(roundTrips) + '</span>'
        + '<span><span class="miniK">Hit Rate:</span> ' + (s.pnl && Number.isFinite(Number(s.pnl.win_rate)) ? Math.round(Number(s.pnl.win_rate) * 100) + '%' : '—') + '</span>'
        + '<span><span class="miniK">MaxPos:</span> ' + String(Number.isFinite(Number(act.max_abs_position_qty)) ? Number(act.max_abs_position_qty) : '—') + '</span>'
        + '<span><span class="miniK">Scale-ins:</span> ' + String(scaleIns) + '</span>';
      bd.appendChild(mini);

      var stripEl = document.createElement('div');
      stripEl.className = 'strip';
      // Encode quantity (width) + outcome strength (opacity):
      // - width proportional to qty_peak
      // - opacity proportional to |realized| (relative within the session)
      var maxAbsPnl = 0;
      var maxQtyPeak = 0;
      for(var kk=0; kk<segs.length; kk++){
        var gg = segs[kk] || {};
        var rv = Math.abs(Number(gg.realized) || 0);
        var qp = Math.abs(Number(gg.qty_peak) || 0);
        if(Number.isFinite(rv) && rv > maxAbsPnl) maxAbsPnl = rv;
        if(Number.isFinite(qp) && qp > maxQtyPeak) maxQtyPeak = qp;
      }
      if(!Number.isFinite(maxAbsPnl) || maxAbsPnl <= 0) maxAbsPnl = 0;
      if(!Number.isFinite(maxQtyPeak) || maxQtyPeak <= 0){
        var sessMaxPos = Math.abs(Number(act.max_abs_position_qty) || 0);
        maxQtyPeak = (Number.isFinite(sessMaxPos) && sessMaxPos > 0) ? sessMaxPos : 0;
      }

      // Zero-trade/no-exit case: show a neutral strip instead of "empty".
      if(!segs.length){
        var fills = (act && Number.isFinite(Number(act.fills))) ? Number(act.fills) : 0;
        var pillsN = clamp(Math.max(1, Math.min(6, Math.floor(fills || 1))), 1, 6);
        for(var q=0; q<pillsN; q++){
          var p0 = document.createElement('span');
          p0.className = 'segPill segNeu';
          // width proportional to session max position (if present)
          var w0 = maxQtyPeak > 0 ? (24 + 40) : 34;
          p0.style.width = String(Math.floor(clamp(w0, 20, 76))) + 'px';
          p0.style.opacity = '0.55';
          stripEl.appendChild(p0);
        }
      } else {
        for(var k=0;k<segs.length;k++){
          var g = segs[k] || {};
          var rv2 = Number(g.realized) || 0;
          var abs2 = Math.abs(rv2);
          var qp2 = Math.abs(Number(g.qty_peak) || 0);
          var relQty = (maxQtyPeak > 0) ? (qp2 / maxQtyPeak) : 0;
          var relPnl = (maxAbsPnl > 0) ? (abs2 / maxAbsPnl) : 0;
          // width 22..76 by qty, opacity 0.30..1.0 by pnl
          var w = 22 + relQty * 54;
          var op = 0.30 + relPnl * 0.70;
          if(!Number.isFinite(w)) w = 34;
          if(!Number.isFinite(op)) op = 0.55;
          w = clamp(w, 20, 76);
          op = clamp(op, 0.25, 1.0);

          var pill = document.createElement('span');
          pill.className = 'segPill ' + (segClass(rv2) || 'segNeu');
          pill.style.width = String(Math.floor(w)) + 'px';
          pill.style.opacity = String(op);
          pill.title = 'Trip ' + String(g.trip_index || (k+1)) + ' · ' + String(g.dir || '') + ' · ' + _fmtNum2(rv2)
            + (Number.isFinite(Number(g.qty_peak)) ? (' · qty_peak=' + String(g.qty_peak)) : '')
            + (Number.isFinite(Number(g.adds)) && Number(g.adds) > 0 ? (' · scale-ins=' + String(g.adds)) : '');
          stripEl.appendChild(pill);
        }
      }
      bd.appendChild(stripEl);

      var ft = document.createElement('div');
      ft.className = 'sessFt';
      var hint = document.createElement('div');
      hint.className = 'sessHint';
      hint.textContent = (s.outcome && s.outcome.confidence_hint) ? String(s.outcome.confidence_hint) : '';
      var actions = document.createElement('div');
      actions.style.display = 'flex';
      actions.style.gap = '8px';
      actions.style.alignItems = 'center';
      var btnLedger = document.createElement('button');
      btnLedger.className = 'btn';
      btnLedger.type = 'button';
      btnLedger.textContent = 'View Ledger';
      btnLedger.addEventListener('click', (function(sess){
        return function(){
          try{ state.historySessionFilter = String(sess.session_id || ''); } catch(_e){}
          _setHistoryViewMode('ledger');
          loadTradeHistory();
        };
      })(s));
      actions.appendChild(btnLedger);

      var btnDel = document.createElement('button');
      btnDel.className = 'btn';
      btnDel.type = 'button';
      btnDel.textContent = 'Delete';
      btnDel.title = 'Delete this session and all its events';
      btnDel.addEventListener('click', (function(sess, cardEl){
        return async function(){
          var sid = String(sess && sess.session_id ? sess.session_id : '');
          if(!sid) return;
          var ok = false;
          try{
            var name = String((sess.label || '') + ' · ' + (sess.symbol || '')).trim();
            var when = String(_fmtDateShort(sess.t_start || sess.created_at) || '');
            ok = window.confirm('Delete this session and all associated events?\n\n' + (name ? (name + '\n') : '') + (when ? (when + '\n') : '') + '\nThis cannot be undone.');
          } catch(_e){ ok = false; }
          if(!ok) return;
          _setHistoryModalStatus('Deleting…');
          try{
            await _postJson('/replay/session/delete', { session_id: sid });
            // Remove the specific card immediately so the user sees it disappear,
            // even though S1/S2 labels may shift after refresh.
            try{ if(cardEl && cardEl.parentNode) cardEl.parentNode.removeChild(cardEl); } catch(_eRm){}
            // If the deleted session is currently active in practice mode, clear local state.
            try{
              if(state && state.replay && String(state.replay.sessionId || '') === sid){
                _clearReplayLocal();
              }
            } catch(_e2){}
            await loadTradeHistory();
            _setHistoryModalStatus('Deleted.');
          } catch(e){
            console.error(e);
            _setHistoryModalStatus('Delete failed');
          }
        };
      })(s, card));
      actions.appendChild(btnDel);
      ft.appendChild(hint);
      ft.appendChild(actions);

      card.appendChild(hd);
      card.appendChild(bd);
      card.appendChild(ft);
      list.appendChild(card);
    }

    ui.historyTableWrap.appendChild(list);
  }

  function _renderTradeLedger(j){
    if(!ui.historyTableWrap) return;
    ui.historyTableWrap.innerHTML = '';
    var sessionsAll = (j && Array.isArray(j.sessions)) ? j.sessions : [];
    var sessions = sessionsAll;
    try{
      var f = (state && state.historySessionFilter) ? String(state.historySessionFilter) : '';
      if(f){
        sessions = [];
        for(var si=0; si<sessionsAll.length; si++){
          var ss = sessionsAll[si];
          if(ss && String(ss.session_id || '') === f) sessions.push(ss);
        }
        // show a small filter hint above the table
        var hint = document.createElement('div');
        hint.className = 'hint';
        hint.style.marginBottom = '10px';
        hint.innerHTML = 'Filtered to one session · <a href="#" style="color:rgba(90,150,255,.92);text-decoration:none;">Clear</a>';
        hint.querySelector('a').addEventListener('click', function(e){
          try{ e.preventDefault(); } catch(_e){}
          try{ state.historySessionFilter = null; } catch(_e2){}
          loadTradeLedger();
        });
        ui.historyTableWrap.appendChild(hint);
      }
    } catch(_e0){}
    if(!sessions.length){
      ui.historyTableWrap.innerHTML = '<div class="hint" style="padding:10px;">No sessions yet.</div>';
      return;
    }

    var table = document.createElement('table');
    table.className = 'histTable';

    var thead = document.createElement('thead');
    var hr = document.createElement('tr');
    var cols = ['Session','Symbol','Exec Time','FillID','Row','TradeID','Type','Open/Close','Ref','Qty','SignedQty','Price','Value','RPnLΔ'];
    for(var i=0;i<cols.length;i++){
      var th = document.createElement('th');
      th.textContent = cols[i];
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    table.appendChild(thead);

    var tbody = document.createElement('tbody');
    for(var s=0;s<sessions.length;s++){
      var sess = sessions[s] || {};
      var rows = Array.isArray(sess.rows) ? sess.rows : [];
      for(var r=0;r<rows.length;r++){
        var x = rows[r] || {};
        var tr = document.createElement('tr');
        function td(v){
          var t = document.createElement('td');
          t.textContent = (v === null || v === undefined) ? '' : String(v);
          return t;
        }
        tr.appendChild(td(sess.label || sess.session_id || ''));
        tr.appendChild(td(sess.symbol || ''));
        tr.appendChild(td(_fmtDateShort(x.exec_ts)));
        tr.appendChild(td(x.fill_id));
        tr.appendChild(td(x.row_in_fill));
        tr.appendChild(td(x.trade_id));
        tr.appendChild(td(x.entry_type));
        tr.appendChild(td(x.open_close));
        tr.appendChild(td(x.reference));
        tr.appendChild(td(x.qty));
        tr.appendChild(td(x.signed_qty));
        tr.appendChild(td(_fmtNum2(x.price)));
        tr.appendChild(td(_fmtNum2(x.value)));
        tr.appendChild(td(_fmtNum2(x.realized_pnl_delta)));
        tbody.appendChild(tr);
      }
    }

    table.appendChild(tbody);
    var wrap = document.createElement('div');
    wrap.className = 'tableWrap';
    wrap.appendChild(table);
    ui.historyTableWrap.appendChild(wrap);
  }

  function _renderTradeMatrix(matrix){
    if(!ui.historyTableWrap) return;
    var sessions = (matrix && Array.isArray(matrix.sessions)) ? matrix.sessions : [];
    var maxTrades = (matrix && Number.isFinite(Number(matrix.max_trades))) ? Math.floor(Number(matrix.max_trades)) : 0;
    ui.historyTableWrap.innerHTML = '';
    if(!sessions.length){
      ui.historyTableWrap.innerHTML = '<div class="hint" style="padding:10px;">No sessions yet.</div>';
      return;
    }
    if(maxTrades <= 0) maxTrades = 1;

    var table = document.createElement('table');
    table.className = 'histTable';

    var thead = document.createElement('thead');
    var hr = document.createElement('tr');
    var th0 = document.createElement('th');
    th0.textContent = 'Trade';
    hr.appendChild(th0);
    for(var i=0;i<sessions.length;i++){
      var s = sessions[i];
      var th = document.createElement('th');
      var lbl = (s && s.label) ? String(s.label) : ('S' + (i+1));
      var sym = s && s.symbol ? String(s.symbol) : '—';
      var created = _fmtDateShort(s && s.created_at);
      th.innerHTML = '<div style="display:flex;flex-direction:column;gap:2px;">'
        + '<div style="font-weight:800;">' + lbl + ' · ' + sym + '</div>'
        + '<div class="tradeMeta">' + created + '</div>'
        + '</div>';
      th.title = (s && s.session_id) ? String(s.session_id) : '';
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    table.appendChild(thead);

    var tbody = document.createElement('tbody');
    for(var r=0;r<maxTrades;r++){
      var tr = document.createElement('tr');
      var td0 = document.createElement('td');
      td0.textContent = 'T' + (r+1);
      tr.appendChild(td0);
      for(var c=0;c<sessions.length;c++){
        var td = document.createElement('td');
        var trades = sessions[c] && Array.isArray(sessions[c].trades) ? sessions[c].trades : [];
        var t = trades[r] || null;
        if(!t){
          td.innerHTML = '<div class="tradeMeta">—</div>';
        } else {
          var side = (t.side === 'short') ? 'S' : 'L';
          var qty = (t.qty !== undefined && t.qty !== null) ? String(t.qty) : '';
          var ep = Number(t.entry_price);
          var xp = Number(t.exit_price);
          var pnl = Number(t.pnl);
          var pnlCls = Number.isFinite(pnl) ? (pnl >= 0 ? 'tradePnlUp' : 'tradePnlDn') : 'tradeMeta';
          td.innerHTML =
            '<div class="tradeCell">'
            + '<div><span style="font-weight:800;">' + side + '</span> × ' + qty + '</div>'
            + '<div class="tradeMeta">' + (Number.isFinite(ep) ? ep.toFixed(2) : '—') + ' → ' + (Number.isFinite(xp) ? xp.toFixed(2) : '—') + '</div>'
            + '<div class="' + pnlCls + '">PnL ' + (Number.isFinite(pnl) ? pnl.toFixed(2) : '—') + '</div>'
            + '</div>';
          td.title = (sessions[c] && sessions[c].session_id) ? ('session=' + sessions[c].session_id) : '';
        }
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);

    var wrap = document.createElement('div');
    wrap.className = 'tableWrap';
    wrap.appendChild(table);
    ui.historyTableWrap.appendChild(wrap);
  }

  async function loadTradeMatrix(){
    _setHistoryModalStatus('Loading…');
    try{
      var j = await _getJson('/replay/trade_matrix?limit_sessions=8');
      _renderTradeMatrix(j);
      _setHistoryModalStatus('Loaded ' + ((j && j.sessions && j.sessions.length) ? j.sessions.length : 0) + ' sessions');
    } catch(e){
      console.error(e);
      _setHistoryModalStatus('Failed to load history');
      if(ui.historyTableWrap) ui.historyTableWrap.innerHTML = '';
    }
  }

  async function loadTradeLedger(){
    _setHistoryModalStatus('Loading…');
    try{
      var j = await _getJson('/replay/trade_ledger?limit_sessions=8');
      _renderTradeLedger(j);
      var n = (j && j.sessions && j.sessions.length) ? j.sessions.length : 0;
      var total = (j && Number.isFinite(Number(j.total_sessions))) ? Number(j.total_sessions) : null;
      _setHistoryModalStatus('Loaded ' + String(n) + (total !== null ? (' of ' + String(total)) : '') + ' sessions');
    } catch(e){
      console.error(e);
      _setHistoryModalStatus('Failed to load history');
      if(ui.historyTableWrap) ui.historyTableWrap.innerHTML = '';
    }
  }

  async function loadSessionCards(){
    _setHistoryModalStatus('Loading…');
    try{
      // Default to meaningful "sessions" (those with fills); backend supports `only_with_fills=0` if needed.
      var j = await _getJson('/replay/session_summaries?limit_sessions=8&only_with_fills=1');
      _renderSessionCards(j);
      var n = (j && j.sessions && j.sessions.length) ? j.sessions.length : 0;
      var total = (j && Number.isFinite(Number(j.total_sessions))) ? Number(j.total_sessions) : null;
      var fills = (j && Number.isFinite(Number(j.total_sessions_with_fills))) ? Number(j.total_sessions_with_fills) : null;
      var extra = '';
      if(total !== null) extra = ' of ' + String(total);
      if(fills !== null) extra += ' · ' + String(fills) + ' w/ fills';
      _setHistoryModalStatus('Loaded ' + String(n) + extra + ' sessions');
    } catch(e){
      console.error(e);
      _setHistoryModalStatus('Failed to load history');
      if(ui.historyTableWrap) ui.historyTableWrap.innerHTML = '';
    }
  }

  async function loadTradeHistory(){
    var m = (state && state.historyViewMode) ? String(state.historyViewMode) : 'cards';
    if(m === 'matrix') return await loadTradeMatrix();
    if(m === 'ledger') return await loadTradeLedger();
    return await loadSessionCards();
  }
  function _barsFromReplayState(st){
    var bars = (st && st.display_series && Array.isArray(st.display_series.bars)) ? st.display_series.bars : [];
    var out = new Array(bars.length);
    for(var i=0;i<bars.length;i++){
      var b = bars[i];
      if(!b){ out[i] = null; continue; }
      var tm = parseIsoToMs(b.ts);
      out[i] = {
        t: Number.isFinite(tm) ? tm : NaN,
        o: Number(b.o),
        h: Number(b.h),
        l: Number(b.l),
        c: Number(b.c),
        v: Number(b.v),
        bid: NaN,
        ask: NaN
      };
    }
    // Filter nulls defensively
    var clean = [];
    for(var j=0;j<out.length;j++){
      var d = out[j];
      if(d && Number.isFinite(Number(d.t))) clean.push(d);
    }
    return clean;
  }
  function _renderReplayState(st, opts){
    var o = opts || {};
    if(!st) return;
    if(!state || !state.replay) return;
    state.replay.lastState = st;

    // Keep UI bar size aligned to disp_tf_sec (display clock).
    try{
      var bs = Math.floor(Number(st.disp_tf_sec) || Math.floor(Number(state.windowSec) || 60));
      if(Number.isFinite(bs) && bs > 0){
        state.windowSec = clamp(bs, 60, 86400);
        state._loadedBarS = state.windowSec;
        if(ui.window) ui.window.value = String(state.windowSec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(state.windowSec);
        syncBarPresetUi();
        updateUrlBarSize();
      }
    } catch(_e0){}

    // Clamp navigation bounds so the chart stays future-blind.
    try{
      var ds0 = st.actual_range && st.actual_range.start ? parseIsoToMs(st.actual_range.start) : parseIsoToMs(st.requested_range && st.requested_range.start);
      var de0 = st.clock && st.clock.disp_window && st.clock.disp_window.end ? parseIsoToMs(st.clock.disp_window.end) : NaN;
      // Full history end (does NOT change future-blind clamp).
      var deMax0 = st.actual_range && st.actual_range.end ? parseIsoToMs(st.actual_range.end) : parseIsoToMs(st.requested_range && st.requested_range.end);
      if(Number.isFinite(ds0)) state.datasetStartMs = ds0;
      if(Number.isFinite(de0)) state.datasetEndMs = de0;
      if(Number.isFinite(deMax0)) state.datasetMaxEndMs = deMax0;
      if(Number.isFinite(state.datasetEndMs)) state.viewEndMs = state.datasetEndMs;
      updateSpanPresetAvailability();
    } catch(_e1){}

    // Render candles from authoritative display_series.
    //
    // Fast path (append-only):
    // - Only when session filters are "show all" (so dataFull==data)
    // - Only when the new window overlaps the old window by all-but-last timestamps
    // - Only when relevant toggles haven't changed since the last replay render
    //
    // Otherwise: fall back to the safe full rebuild + applySessionFilter().
    try{
      function allSessionsEnabled(){
        try{
          return !!(
            (!ui.sessPreMarket || ui.sessPreMarket.checked) &&
            (!ui.sessAfterHours || ui.sessAfterHours.checked) &&
            (!ui.sessClosed || ui.sessClosed.checked)
          );
        } catch(_e){ return true; }
      }
      function replayFastSig(){
        var os = getOverlaySettings();
        return [
          'sym', String(getSymbol() || ''),
          'disp', Math.floor(Number(st.disp_tf_sec) || 0),
          'cand', ui.showCandles && ui.showCandles.checked ? 1 : 0,
          'cstyle', String(state.candleStyle || ''),
          'pre', ui.sessPreMarket && ui.sessPreMarket.checked ? 1 : 0,
          'after', ui.sessAfterHours && ui.sessAfterHours.checked ? 1 : 0,
          'closed', ui.sessClosed && ui.sessClosed.checked ? 1 : 0,
          'ema9', os && os.ema9 ? 1 : 0,
          'ema21', os && os.ema21 ? 1 : 0,
          'ema50', os && os.ema50 ? 1 : 0,
          'vwap', os && os.vwap ? 1 : 0
        ].join('|');
      }
      function buildOverlaysFromReplayState(st2){
        try{
          var os = getOverlaySettings();
          if(!os || !anyOverlayEnabled(os)) return [];
          if(!(st2 && replayOverlaysAvailable(st2.overlays))) return [];
          var out = [];
          // Helper to map [{ts,v}] -> y[]
          function yFromPoints(points){
            if(!Array.isArray(points)) return [];
            var y = new Array(points.length);
            for(var i=0;i<points.length;i++){
              var p = points[i];
              var v = (p && p.v !== null && p.v !== undefined) ? Number(p.v) : NaN;
              y[i] = Number.isFinite(v) ? v : NaN;
            }
            return y;
          }
          var ema = (st2.overlays && st2.overlays.ema) ? st2.overlays.ema : {};
          if(os.ema9 && Array.isArray(ema['9']) && ema['9'].length){
            out.push({ t_ms: [], y: yFromPoints(ema['9']), key: 'ema_9', label: 'EMA 9', color: 'rgba(215,224,234,0.92)', width: 1.25 });
          }
          if(os.ema21 && Array.isArray(ema['21']) && ema['21'].length){
            out.push({ t_ms: [], y: yFromPoints(ema['21']), key: 'ema_21', label: 'EMA 21', color: 'rgba(215,224,234,0.72)', width: 1.25 });
          }
          if(os.ema50 && Array.isArray(ema['50']) && ema['50'].length){
            out.push({ t_ms: [], y: yFromPoints(ema['50']), key: 'ema_50', label: 'EMA 50', color: 'rgba(215,224,234,0.52)', width: 1.25 });
          }
          if(os.vwap && Array.isArray(st2.overlays && st2.overlays.vwap) && st2.overlays.vwap.length){
            out.push({ t_ms: [], y: yFromPoints(st2.overlays.vwap), key: 'vwap_session', label: 'VWAP', color: 'rgb(255, 215, 0)', width: 1.55 });
          }
          // Fill t_ms from current data (aligned by index)
          try{
            if(Array.isArray(state.dataFull) && state.dataFull.length){
              for(var si=0; si<out.length; si++){
                var s = out[si];
                s.t_ms = new Array(state.dataFull.length);
                for(var j=0;j<state.dataFull.length;j++) s.t_ms[j] = Number(state.dataFull[j].t);
              }
            }
          } catch(_eTms){}
          return out;
        } catch(_e){
          return [];
        }
      }
      function appendHa(prevHa, rawBar){
        var o = Number(rawBar.o), h = Number(rawBar.h), l = Number(rawBar.l), c = Number(rawBar.c);
        var haClose = (o + h + l + c) / 4;
        var prevOpen = prevHa ? Number(prevHa.o) : NaN;
        var prevClose = prevHa ? Number(prevHa.c) : NaN;
        var haOpen = (!Number.isFinite(prevOpen) || !Number.isFinite(prevClose)) ? ((o + c) / 2) : ((prevOpen + prevClose) / 2);
        var haHigh = Math.max(h, haOpen, haClose);
        var haLow = Math.min(l, haOpen, haClose);
        return { o: haOpen, h: haHigh, l: haLow, c: haClose };
      }

      var rawBars = (st && st.display_series && Array.isArray(st.display_series.bars)) ? st.display_series.bars : [];
      var newLen = rawBars.length;
      var oldArr = Array.isArray(state.dataFull) ? state.dataFull : null;
      var oldLen = oldArr ? oldArr.length : 0;
      var sig = replayFastSig();
      var prevSig = (state.replay._fastSig || '');

      var canFast = !!(oldArr && oldLen > 2 && newLen === oldLen && allSessionsEnabled() && sig === prevSig);
      if(canFast){
        // Quick compute ts arrays
        var oldTs0 = new Array(oldLen);
        for(var i0=0;i0<oldLen;i0++) oldTs0[i0] = Number(oldArr[i0] && oldArr[i0].t);
        var newTs0 = new Array(newLen);
        for(var j0=0;j0<newLen;j0++) newTs0[j0] = parseIsoToMs(rawBars[j0] && rawBars[j0].ts);

        // Determine drop count (how many old bars rolled off).
        var drop = 0;
        if(oldLen >= 2 && oldTs0[1] === newTs0[0]) drop = 1;
        else {
          // find first match of newTs[0] in oldTs (drop index)
          var head = newTs0[0];
          for(var k0=0;k0<oldLen;k0++){
            if(oldTs0[k0] === head){ drop = k0; break; }
          }
        }
        if(drop > 0 && drop < oldLen){
          // Validate overlap: old[drop..] == new[0..oldLen-drop-1]
          var ok = true;
          for(var x=drop; x<oldLen; x++){
            if(oldTs0[x] !== newTs0[x - drop]) { ok = false; break; }
          }
          if(ok){
            var appendN = drop; // fixed window size
            // Ensure we are in "no filter" mode: data === dataFull (same reference).
            if(state.data !== state.dataFull) state.data = state.dataFull;
            // Drop rolled-off bars
            state.dataFull.splice(0, drop);

            // Drop aligned derived arrays
            try{
              if(Array.isArray(state._sessionType) && state._sessionType.length === oldLen) state._sessionType.splice(0, drop);
            } catch(_eS){}
            try{
              if(Array.isArray(state.ha) && state.ha.length === oldLen) state.ha.splice(0, drop);
            } catch(_eHaSp){}
            try{
              if(Array.isArray(state.overlays)){
                for(var si0=0; si0<state.overlays.length; si0++){
                  var s0 = state.overlays[si0];
                  if(s0 && Array.isArray(s0.y) && s0.y.length === oldLen) s0.y.splice(0, drop);
                  if(s0 && Array.isArray(s0.t_ms) && s0.t_ms.length === oldLen) s0.t_ms.splice(0, drop);
                }
              }
            } catch(_eOvSp){}

            // Append new bars
            for(var a=0; a<appendN; a++){
              var rb = rawBars[newLen - appendN + a];
              if(!rb) continue;
              var tm = parseIsoToMs(rb.ts);
              var nb = { t: Number.isFinite(tm) ? tm : NaN, o: Number(rb.o), h: Number(rb.h), l: Number(rb.l), c: Number(rb.c), v: Number(rb.v), bid: NaN, ask: NaN };
              state.dataFull.push(nb);
            }

            // Ensure length restored
            if(state.dataFull.length !== newLen){
              throw new Error('fast path length mismatch');
            }

            // Append session types
            try{
              if(!Array.isArray(state._sessionType) || state._sessionType.length !== (newLen - appendN)){
                state._sessionType = computeSessionTypesForData(state.dataFull);
              } else {
                for(var a2=0;a2<appendN;a2++){
                  var t2 = Number(state.dataFull[newLen - appendN + a2].t);
                  state._sessionType.push(Number.isFinite(t2) ? sessionTypeForMsEt(t2) : 'closed');
                }
              }
            } catch(_eSess){
              state._sessionType = computeSessionTypesForData(state.dataFull);
            }

            // HA append-only (only if HA candles are enabled)
            var needHa = !!(ui && ui.showCandles && ui.showCandles.checked && state && state.candleStyle === 'ha');
            if(needHa){
              try{
                if(!Array.isArray(state.ha) || state.ha.length !== (newLen - appendN)){
                  state.ha = computeHeikinAshi(state.dataFull);
                } else {
                  var prev = state.ha.length ? state.ha[state.ha.length - 1] : null;
                  for(var a3=0;a3<appendN;a3++){
                    var raw = state.dataFull[newLen - appendN + a3];
                    var haBar = appendHa(prev, raw);
                    state.ha.push(haBar);
                    prev = haBar;
                  }
                }
              } catch(_eHa2){
                state.ha = computeHeikinAshi(state.dataFull);
              }
            } else {
              state.ha = [];
            }

            // Overlays (prefer server overlays): rebuild once if missing or settings changed; otherwise shift+append last points
            try{
              var os2 = getOverlaySettings();
              if(!os2 || !anyOverlayEnabled(os2)){
                state.overlays = [];
              } else if(st && replayOverlaysAvailable(st.overlays)){
                var needRebuildOv = !Array.isArray(state.overlays) || !state.overlays.length || (state.replay._fastOvSig !== sig);
                if(needRebuildOv){
                  // Build from the authoritative overlay arrays (O(n) once per settings change)
                  state.overlays = buildOverlaysFromReplayState(st);
                  state.replay._fastOvSig = sig;
                } else {
                  // Append overlay points for the newly appended bars (assume overlay arrays aligned to rawBars).
                  function appendSeries(key, points){
                    if(!Array.isArray(points) || !points.length) return;
                    var s = null;
                    for(var i=0;i<state.overlays.length;i++){
                      if(state.overlays[i] && state.overlays[i].key === key){ s = state.overlays[i]; break; }
                    }
                    if(!s || !Array.isArray(s.y)) return;
                    // points are full-length; take the last appendN values
                    for(var q=0;q<appendN;q++){
                      var p = points[newLen - appendN + q];
                      var vv = (p && p.v !== null && p.v !== undefined) ? Number(p.v) : NaN;
                      s.y.push(Number.isFinite(vv) ? vv : NaN);
                      if(Array.isArray(s.t_ms)) s.t_ms.push(Number(state.dataFull[newLen - appendN + q].t));
                    }
                  }
                  var ema2 = st.overlays.ema || {};
                  if(os2.ema9) appendSeries('ema_9', ema2['9']);
                  if(os2.ema21) appendSeries('ema_21', ema2['21']);
                  if(os2.ema50) appendSeries('ema_50', ema2['50']);
                  if(os2.vwap) appendSeries('vwap_session', st.overlays.vwap);
                }
              } else {
                // If replay overlays absent, keep overlays empty in fast path (avoid local recompute).
                state.overlays = [];
              }
            } catch(_eOv2){
              // If overlay update fails, clear them (safe) and continue.
              state.overlays = [];
            }

            // Replay UX: keep right-aligned as time advances.
            state.followLatest = true;
            state.hoverIdx = -1;
            if(!o.skipDraw) draw();
            try{
              if(state && state.replay && state.replay._fastStats){
                state.replay._fastStats.hits = (Number(state.replay._fastStats.hits) || 0) + 1;
                state.replay._fastStats.lastMode = 'fast';
              }
            } catch(_eFS){}
            // Update fast-path signature
            state.replay._fastSig = sig;
            return;
          }
        }
      }
      // Update signature even if fast path not taken (keeps it current for next attempt).
      state.replay._fastSig = sig;
    } catch(_eFast){
      // fall through to full rebuild
    }

    // Safe full rebuild + filter/derived recompute (correctness path)
    var out = _barsFromReplayState(st);
    state.dataFull = out;
    state.data = out;
    state._sessionType = [];
    state.ha = [];
    state.overlaysFull = [];
    state.overlays = [];
    state.followLatest = true;
    applySessionFilter({ skipSave: true, skipDraw: true });
    state.hoverIdx = -1;
    if(!o.skipDraw) draw();
    try{
      if(state && state.replay && state.replay._fastStats){
        state.replay._fastStats.misses = (Number(state.replay._fastStats.misses) || 0) + 1;
        state.replay._fastStats.lastMode = 'full';
      }
    } catch(_eFS2){}
  }

  function _applyReplayDelta(item, opts){
    var o = opts || {};
    try{
      if(!item) return false;
      // If server included a full resync snapshot, just render it (correctness-first).
      if(item.state){
        _renderReplayState(item.state, o);
        return true;
      }
      var d = item.delta || null;
      if(!d) return false;
      if(!state || !state.replay) return false;

      var drop = Math.max(0, Math.floor(Number(d.drop) || 0));
      var appendBars = Array.isArray(d.append_bars) ? d.append_bars : [];
      if(!Array.isArray(state.dataFull) || !state.dataFull.length){
        state.replay._forceResync = true;
        return false;
      }
      function _allSessionsEnabled(){
        try{
          return !!(
            (!ui.sessPreMarket || ui.sessPreMarket.checked) &&
            (!ui.sessAfterHours || ui.sessAfterHours.checked) &&
            (!ui.sessClosed || ui.sessClosed.checked)
          );
        } catch(_e){ return true; }
      }
      var _filtersAll = _allSessionsEnabled();
      if(_filtersAll){
        // Fast delta path assumes no filtering, so keep data as the authoritative full window.
        if(state.data !== state.dataFull) state.data = state.dataFull;
      }

      // Fixed-window expectation: usually drop === appendBars.length.
      if(drop > 0 && appendBars.length && drop !== appendBars.length){
        state.replay._forceResync = true;
      }

      if(drop){
        state.dataFull.splice(0, drop);
        if(_filtersAll){
          try{
            if(Array.isArray(state._sessionType) && state._sessionType.length >= drop) state._sessionType.splice(0, drop);
          } catch(_eS){}
          try{
            if(Array.isArray(state.ha) && state.ha.length >= drop) state.ha.splice(0, drop);
          } catch(_eHa){}
          try{
            if(Array.isArray(state.overlays)){
              for(var si=0; si<state.overlays.length; si++){
                var s = state.overlays[si];
                if(s && Array.isArray(s.y) && s.y.length >= drop) s.y.splice(0, drop);
                if(s && Array.isArray(s.t_ms) && s.t_ms.length >= drop) s.t_ms.splice(0, drop);
              }
            }
          } catch(_eOv){}
        }
      }

      function barFromDelta(b){
        var tm = parseIsoToMs(b && b.ts);
        return {
          t: Number.isFinite(tm) ? tm : NaN,
          o: Number(b && b.o),
          h: Number(b && b.h),
          l: Number(b && b.l),
          c: Number(b && b.c),
          v: Number(b && b.v),
          bid: NaN,
          ask: NaN
        };
      }

      var newOnes = [];
      for(var i=0;i<appendBars.length;i++){
        var bb = appendBars[i];
        if(!bb) continue;
        var b2 = barFromDelta(bb);
        if(b2 && Number.isFinite(Number(b2.t))) newOnes.push(b2);
      }
      for(var j=0;j<newOnes.length;j++) state.dataFull.push(newOnes[j]);

      // Keep replay.lastState updated so applySessionFilter() can build server-authoritative overlays.
      try{
        if(!state.replay.lastState) state.replay.lastState = {};
        var ls = state.replay.lastState;
        if(!ls.display_series) ls.display_series = { bars: [] };
        if(!Array.isArray(ls.display_series.bars)) ls.display_series.bars = [];
        if(drop && ls.display_series.bars.length >= drop) ls.display_series.bars.splice(0, drop);
        for(var jj=0;jj<appendBars.length;jj++){
          var rb = appendBars[jj];
          if(rb) ls.display_series.bars.push(rb);
        }
        if(item.meta && item.meta.disp_window_end){
          if(!ls.clock) ls.clock = {};
          if(!ls.clock.disp_window) ls.clock.disp_window = {};
          ls.clock.disp_window.end = String(item.meta.disp_window_end);
        }
        // Shift+append overlays in lastState (window-sized).
        var oaLS = d.overlays_append || {};
        if(!ls.overlays) ls.overlays = {};
        var ovLS = ls.overlays;
        if(!ovLS.ema) ovLS.ema = {};
        function shiftAppend(arr, pt){
          if(!Array.isArray(arr)) arr = [];
          if(drop && arr.length >= drop) arr.splice(0, drop);
          if(pt) arr.push(pt);
          return arr;
        }
        try{
          var emaLS = oaLS.ema || {};
          var p9 = (Array.isArray(emaLS['9']) && emaLS['9'].length) ? emaLS['9'][emaLS['9'].length - 1] : null;
          var p21 = (Array.isArray(emaLS['21']) && emaLS['21'].length) ? emaLS['21'][emaLS['21'].length - 1] : null;
          var p50 = (Array.isArray(emaLS['50']) && emaLS['50'].length) ? emaLS['50'][emaLS['50'].length - 1] : null;
          ovLS.ema['9'] = shiftAppend(ovLS.ema['9'], p9);
          ovLS.ema['21'] = shiftAppend(ovLS.ema['21'], p21);
          ovLS.ema['50'] = shiftAppend(ovLS.ema['50'], p50);
        } catch(_eEmaLS){}
        try{
          var vwLS = (Array.isArray(oaLS.vwap) && oaLS.vwap.length) ? oaLS.vwap[oaLS.vwap.length - 1] : null;
          ovLS.vwap = shiftAppend(ovLS.vwap, vwLS);
        } catch(_eVwLS){}
      } catch(_eLS){}

      // If session filters are active, rebuild filtered view + derived arrays for correctness.
      if(!_filtersAll){
        try{
          applySessionFilter({ skipSave: true, skipDraw: true });
        } catch(_eFilt){}
        state.followLatest = true;
        state.hoverIdx = -1;
        if(!o.skipDraw) draw();
        return true;
      }

      // Session types (best-effort; fast path only)
      try{
        if(!Array.isArray(state._sessionType)) state._sessionType = [];
        for(var k=0;k<newOnes.length;k++){
          var t2 = Number(newOnes[k].t);
          state._sessionType.push(Number.isFinite(t2) ? sessionTypeForMsEt(t2) : 'closed');
        }
      } catch(_eSess){}

      // HA append-only if enabled
      try{
        var needHa = !!(ui && ui.showCandles && ui.showCandles.checked && state && state.candleStyle === 'ha');
        function appendHa(prevHa, rawBar){
          var oo = Number(rawBar.o), hh = Number(rawBar.h), ll = Number(rawBar.l), cc = Number(rawBar.c);
          var haClose = (oo + hh + ll + cc) / 4;
          var prevOpen = prevHa ? Number(prevHa.o) : NaN;
          var prevClose = prevHa ? Number(prevHa.c) : NaN;
          var haOpen = (!Number.isFinite(prevOpen) || !Number.isFinite(prevClose)) ? ((oo + cc) / 2) : ((prevOpen + prevClose) / 2);
          var haHigh = Math.max(hh, haOpen, haClose);
          var haLow = Math.min(ll, haOpen, haClose);
          return { o: haOpen, h: haHigh, l: haLow, c: haClose };
        }
        if(needHa){
          if(!Array.isArray(state.ha)) state.ha = [];
          var prev = state.ha.length ? state.ha[state.ha.length - 1] : null;
          for(var a=0;a<newOnes.length;a++){
            var haBar = appendHa(prev, newOnes[a]);
            state.ha.push(haBar);
            prev = haBar;
          }
          // Safety: if anything drifted (e.g. after a resync/mismatch), rebuild once from authoritative bars.
          if(!Array.isArray(state.ha) || state.ha.length !== state.dataFull.length){
            state.ha = computeHeikinAshi(state.dataFull);
          }
        } else {
          state.ha = [];
        }
      } catch(_eHa2){
        state.ha = [];
      }

      // Overlays append (server-authoritative)
      try{
        var os = getOverlaySettings();
        if(!os || !anyOverlayEnabled(os)){
          state.overlays = [];
        } else if(Array.isArray(state.overlays) && state.overlays.length){
          var oa = d.overlays_append || {};
          var ema = oa.ema || {};
          var vwap = oa.vwap || [];
          function pushPoint(seriesKey, pt){
            if(!pt) return;
            var v = (pt.v !== null && pt.v !== undefined) ? Number(pt.v) : NaN;
            for(var ii=0; ii<state.overlays.length; ii++){
              var s2 = state.overlays[ii];
              if(!s2 || s2.key !== seriesKey) continue;
              if(!Array.isArray(s2.y)) s2.y = [];
              if(!Array.isArray(s2.t_ms)) s2.t_ms = [];
              s2.y.push(Number.isFinite(v) ? v : NaN);
              var tms = state.dataFull.length ? Number(state.dataFull[state.dataFull.length - 1].t) : NaN;
              s2.t_ms.push(Number.isFinite(tms) ? tms : NaN);
              return;
            }
          }
          if(os.ema9 && Array.isArray(ema['9']) && ema['9'].length) pushPoint('ema_9', ema['9'][ema['9'].length - 1]);
          if(os.ema21 && Array.isArray(ema['21']) && ema['21'].length) pushPoint('ema_21', ema['21'][ema['21'].length - 1]);
          if(os.ema50 && Array.isArray(ema['50']) && ema['50'].length) pushPoint('ema_50', ema['50'][ema['50'].length - 1]);
          if(os.vwap && Array.isArray(vwap) && vwap.length) pushPoint('vwap_session', vwap[vwap.length - 1]);
        } else {
          state.overlays = [];
        }
      } catch(_eOv2){
        state.overlays = [];
      }

      // Update metadata/bounds (best-effort)
      try{
        if(!state.replay.lastState) state.replay.lastState = {};
        if(item.position) state.replay.lastState.position = item.position;
        if(item.orders) state.replay.lastState.orders = item.orders;
        if(item.meta && item.meta.disp_window_end){
          var endMs = parseIsoToMs(item.meta.disp_window_end);
          if(Number.isFinite(endMs)){
            state.datasetEndMs = endMs;
            state.viewEndMs = endMs;
          }
        }
      } catch(_eMeta){}

      state.followLatest = true;
      state.hoverIdx = -1;
      if(!o.skipDraw) draw();
      return true;
    } catch(_e){
      try{ if(state && state.replay) state.replay._forceResync = true; } catch(_e2){}
      return false;
    }
  }
  async function replayStart(opts){
    var o = opts || {};
    await _endReplaySession();

    var symbol = String(getSymbol() || '').trim();
    if(!symbol) symbol = 'SPY';

    // Replay start should use the user's *current* settings (span preset + bar size),
    // not reset them. Defaults should be established by UI config / initial UI state, not here.

    var dispTf = clamp(Math.floor(Number(state.windowSec) || 60), 60, 86400);
    var payload = {
      symbol: symbol,
      exec_tf_sec: 60,
      disp_tf_sec: dispTf,
      // Randomize scenario/anchor each time replay starts.
      seed: Math.floor(Math.random() * 1000000000),
      snap_to_disp_boundary: true,
      // Opt-in delta protocol for replay (keeps payloads tiny per step).
      delta_mode: true
    };
    // Display history: derive from current requested x-axis span (plus small slack).
    // Prefer explicit state.viewSpanMs (set by the span preset UI), then fall back to span preset mapping.
    var targetSpanMs = Number(state && state.viewSpanMs);
    if(!Number.isFinite(targetSpanMs) || targetSpanMs <= 0){
      try{
        var sp = String(state && state.spanPreset ? state.spanPreset : '1d');
        targetSpanMs = Number(SPAN_PRESETS[sp]) || (24*60*60*1000);
      } catch(_eSp){
        targetSpanMs = (24*60*60*1000);
      }
    }
    var dispMs = Math.max(60_000, Math.floor(dispTf) * 1000);
    var wantBars = Math.ceil(targetSpanMs / dispMs) + 5; // +slack so "6M" isn't borderline
    // Cap to keep payload sizes reasonable.
    var MAX_HISTORY_BARS = 800;
    payload.initial_history_bars = clamp(wantBars, 50, MAX_HISTORY_BARS);
    // Ensure the randomized anchor has enough runway beyond the "now" cursor.
    // (Frontend also reserves 5 empty display slots for projection.)
    payload.min_future_disp_bars = 5;
    // Use full DB history; enforce that the random start point is at least 4 weeks back.
    // Requirement: start at least ~1 month in the past (when possible).
    payload.min_anchor_age_days = 30;

    _setPracticeStatus('Starting replay…');
    try{
      var j = await _postJson('/replay/start', payload);
      state.replay.active = true;
      state.replay.sessionId = String(j.session_id || '');
      state.replay.deltaMode = true;
      state.replay._forceResync = false;
      state.replay.playing = false;
      state.replay.timer = null;
      _renderReplayState(j.state);
      // Hide debug/status readout after successful start (sidebar design TBD).
      _setPracticeStatus('');
      _setPracticeUiStateActive(true);
      _syncPracticePauseBtn();
      if(o.autoPlay){
        // Start the timer immediately.
        replayTogglePlay();
      }
    } catch(e){
      console.error(e);
      state.replay.active = false;
      state.replay.sessionId = '';
      _setPracticeStatus('Replay start failed: ' + String(e && e.message ? e.message : e));
      _setPracticeUiStateActive(false);
    }
  }
  async function _replayFetchBatch(dispSteps, dbgSample){
    // Fetch N display steps from the server.
    // If dispSteps>1, ask the server to return an array of intermediate states ("states") so
    // the frontend can buffer and play smoothly.
    if(!state.replay.active || !state.replay.sessionId){
      await replayStart();
      return [];
    }
    var steps = Math.max(1, Math.floor(Number(dispSteps) || 1));
    try{
      var t0 = (window.performance && performance.now) ? performance.now() : Date.now();
      var payload = { session_id: state.replay.sessionId, disp_steps: steps };
      if(state.replay.deltaMode){
        payload.delta_only = true;
        payload.return_deltas = (steps > 1);
        payload.resync_every = 500;
        if(state.replay._forceResync){
          payload.force_state = true;
          try{ state.replay._queue = []; } catch(_eQ){}
          state.replay._forceResync = false;
        }
      } else {
        if(steps > 1) payload.return_states = true;
      }
      var j = await _postJson('/replay/step', payload);
      var t1 = (window.performance && performance.now) ? performance.now() : Date.now();
      try{
        if(state && state.replay && state.replay._debug && state.replay._debug.enabled){
          var fm = Math.max(0, t1 - t0);
          state.replay._debug.lastFetchMs = fm;
          try{
            state.replay._debug._fetch.push(fm);
            while(state.replay._debug._fetch.length > (state.replay._debug._N || 60)) state.replay._debug._fetch.shift();
            var mf = -Infinity;
            for(var ii=0; ii<state.replay._debug._fetch.length; ii++){
              var x = Number(state.replay._debug._fetch[ii]);
              if(Number.isFinite(x) && x > mf) mf = x;
            }
            state.replay._debug.maxFetchMs = (mf === -Infinity) ? NaN : mf;
          } catch(_eArr){}
        }
      } catch(_eDbgF){}
      try{
        if(dbgSample){
          dbgSample.fetch_ms = Math.max(0, t1 - t0);
        }
      } catch(_eS0){}
      if(state.replay.deltaMode){
        var deltas = (j && Array.isArray(j.deltas) && j.deltas.length) ? j.deltas : (j && j.delta ? [j] : []);
        return deltas;
      }
      var states = (j && Array.isArray(j.states) && j.states.length) ? j.states : (j && j.state ? [j.state] : []);
      return states;
    } catch(e){
      console.error(e);
      var msg = String(e && e.message ? e.message : e);
      _setPracticeStatus('Replay fetch failed: ' + msg);
      try{ state.replay._stepFailCount = (Number(state.replay._stepFailCount) || 0) + 1; } catch(_e1){}
      // If the server session is gone, pause (don't nuke local state; allow Play to restart).
      if(msg.indexOf('HTTP 404') !== -1 || msg.indexOf('session not found') !== -1){
        _stopReplayTimer();
        _setPracticeStatus('Replay restarting: session not found (server).');
        // Auto-restart a new session and resume playback (sessions are in-memory; server restarts clear them).
        try{
          replayStart({ autoPlay: true });
        } catch(_eAuto){
          _setPracticeStatus('Replay paused: session not found (server). Press Play to start a new session.');
        }
        return [];
      }
      // Avoid infinite noisy failing; pause after repeated failures.
      try{
        if((Number(state.replay._stepFailCount) || 0) >= 3){
          _stopReplayTimer();
          _setPracticeStatus('Replay paused after repeated fetch errors. Press Resume to retry.');
        }
      } catch(_e2){}
      return [];
    }
  }

  async function replayStepOnce(dbgSample){
    // Compatibility: single-step fetch + render (used by non-buffered callers).
    var states = await _replayFetchBatch(1, dbgSample);
    if(!states || !states.length) return;
    var st = states[states.length - 1];
    // Always render from authoritative state (delta is optional optimization).
    var r0 = (window.performance && performance.now) ? performance.now() : Date.now();
    _renderReplayState(st);
    var r1 = (window.performance && performance.now) ? performance.now() : Date.now();
    try{
      if(state && state.replay && state.replay._debug && state.replay._debug.enabled){
        var rm = Math.max(0, r1 - r0);
        state.replay._debug.lastRenderMs = rm;
        try{
          state.replay._debug._render.push(rm);
          while(state.replay._debug._render.length > (state.replay._debug._N || 60)) state.replay._debug._render.shift();
          var mr = -Infinity;
          for(var jj=0; jj<state.replay._debug._render.length; jj++){
            var y = Number(state.replay._debug._render[jj]);
            if(Number.isFinite(y) && y > mr) mr = y;
          }
          state.replay._debug.maxRenderMs = (mr === -Infinity) ? NaN : mr;
        } catch(_eArr2){}
      }
    } catch(_eDbgR){}
    try{
      if(dbgSample){
        dbgSample.render_ms = Math.max(0, r1 - r0);
        if(state && state.replay && state.replay._debug && state.replay._debug.enabled){
          dbgSample.draw_ms = Number(state.replay._debug.lastDrawMs);
        }
      }
    } catch(_eS1){}
    try{ state.replay._stepFailCount = 0; } catch(_e0){}
  }

  function _practiceQty(){
    try{
      // Discrete presets (shares)
      var PRESETS = [1, 5, 10, 25, 50, 100];
      if(ui.practiceQty && String(ui.practiceQty.type || '').toLowerCase() === 'range'){
        var idx = Math.floor(Number(ui.practiceQty.value));
        if(!Number.isFinite(idx)) idx = 0;
        idx = clamp(idx, 0, PRESETS.length - 1);
        return Number(PRESETS[idx]) || 1;
      }
      // Fallback: numeric input (legacy)
      var v = ui.practiceQty ? Number(ui.practiceQty.value) : NaN;
      if(!Number.isFinite(v) || v <= 0) v = 1;
      return Math.max(1, Math.floor(v));
    } catch(_e){
      return 1;
    }
  }

  function _syncPracticeQtyLabel(){
    try{
      if(!ui.practiceQtyLabel) return;
      var q = _practiceQty();
      ui.practiceQtyLabel.textContent = String(q) + ' shares';
    } catch(_e){}
  }

  async function placeMarket(side){
    if(!state.replay.active || !state.replay.sessionId){
      _setPracticeStatus('Start replay first.');
      return;
    }
    var qty = _practiceQty();
    return withReplayPaused(async function(){
      try{
        var j = await _postJson('/replay/order/place', { session_id: state.replay.sessionId, type: 'market', side: side, qty: qty, tag: 'ui' });
        _renderReplayState(j.state);
      } catch(e){
        console.error(e);
        _setPracticeStatus('Order failed: ' + String(e && e.message ? e.message : e));
      }
    });
  }

  async function flattenNow(){
    if(!state.replay.active || !state.replay.sessionId){
      _setPracticeStatus('Start replay first.');
      return;
    }
    return withReplayPaused(async function(){
      try{
        var j = await _postJson('/replay/flatten', { session_id: state.replay.sessionId });
        _renderReplayState(j.state);
      } catch(e){
        console.error(e);
        _setPracticeStatus('Flatten failed: ' + String(e && e.message ? e.message : e));
      }
    });
  }
  function replayTogglePlay(){
    // Play/Pause/Resume UX:
    // - If no active session: start one and begin stepping.
    // - If active and playing: pause (stop stepping timer, keep session).
    // - If active and paused: resume (restart stepping timer).
    if(!state.replay.active || !state.replay.sessionId){
      replayStart({ autoPlay: true });
      return;
    }
    if(state.replay.playing){
      _stopReplayTimer();
      // Hide status label (design TBD). Errors will still surface via _setPracticeStatus.
      _setPracticeStatus('');
      return;
    }
    var bpm = _practiceSpeedBpm();
    var intervalMs = Math.max(80, Math.floor(60000 / bpm));
    _startReplayLoop(intervalMs);
    // Hide any prior "Starting replay…" etc once playback is running.
    _setPracticeStatus('');
  }

  if(ui.practiceBtn) ui.practiceBtn.addEventListener('click', function(){ replayTogglePlay(); });
  if(ui.practicePauseBtn) ui.practicePauseBtn.addEventListener('click', function(){ replayTogglePlay(); });
  // Reset should end the current session and return to the idle "Play" state.
  if(ui.practiceResetBtn) ui.practiceResetBtn.addEventListener('click', function(){ _endReplaySession(); });
  if(ui.practiceLongBtn) ui.practiceLongBtn.addEventListener('click', function(){ placeMarket('buy'); });
  if(ui.practiceShortBtn) ui.practiceShortBtn.addEventListener('click', function(){ placeMarket('sell'); });
  if(ui.practiceFlattenBtn) ui.practiceFlattenBtn.addEventListener('click', function(){ flattenNow(); });
  if(ui.practiceQty){
    ui.practiceQty.addEventListener('input', function(){ _syncPracticeQtyLabel(); });
    ui.practiceQty.addEventListener('change', function(){ _syncPracticeQtyLabel(); });
  }
  if(ui.practiceSpeed){
    ui.practiceSpeed.addEventListener('input', function(){
      _syncPracticeSpeedLabel();
      // Playback cadence is derived from bpm inside the RAF loop; no restart needed.
      // Reset accumulator so the new cadence takes effect immediately.
      try{
        if(state && state.replay && state.replay.playing){
          state.replay._rafAcc = 0;
          if(state.replay._debug && state.replay._debug.enabled){
            state.replay._debug.targetMs = _replayMsPerStep();
          }
        }
      } catch(_e){}
    });
    ui.practiceSpeed.addEventListener('change', function(){
      _syncPracticeSpeedLabel();
      try{
        if(state && state.replay && state.replay.playing){
          if(state.replay._debug && state.replay._debug.enabled){
            state.replay._debug.targetMs = _replayMsPerStep();
          }
        }
      } catch(_e2){}
    });
  }
  _syncPracticeSpeedLabel();
  _syncPracticeQtyLabel();
  _setPracticeUiStateActive(!!(state && state.replay && state.replay.active));
  // History modal wiring
  if(ui.practiceHistoryBtn){
    ui.practiceHistoryBtn.addEventListener('click', function(){
      _showHistoryModal(true);
      _setHistoryViewMode('cards');
      loadTradeHistory();
    });
  }
  if(ui.historyCloseBtn) ui.historyCloseBtn.addEventListener('click', function(){ _showHistoryModal(false); });
  if(ui.historyRefreshBtn) ui.historyRefreshBtn.addEventListener('click', function(){ loadTradeHistory(); });
  if(ui.historyViewCardsBtn) ui.historyViewCardsBtn.addEventListener('click', function(){ _setHistoryViewMode('cards'); loadTradeHistory(); });
  if(ui.historyViewLedgerBtn) ui.historyViewLedgerBtn.addEventListener('click', function(){ _setHistoryViewMode('ledger'); loadTradeHistory(); });
  if(ui.historyViewMatrixBtn) ui.historyViewMatrixBtn.addEventListener('click', function(){ _setHistoryViewMode('matrix'); loadTradeHistory(); });
  if(ui.historyModal){
    ui.historyModal.addEventListener('click', function(e){
      // Click outside the modal closes
      try{
        if(e && e.target === ui.historyModal) _showHistoryModal(false);
      } catch(_e){}
    });
  }
  document.addEventListener('keydown', function(e){
    try{
      if(e && e.key === 'Escape' && ui.historyModal && ui.historyModal.style.display !== 'none'){
        _showHistoryModal(false);
      }
    } catch(_e){}
  });
  async function fetchLatestAndReload(){
    // In API mode, this triggers the server-side fetch for *all* tickers, then reloads the window.
    if(STATIC_MODE){
      return loadFromAPI();
    }
    if(ui.regen && ui.regen.disabled) return;
    var prev = ui.regen ? ui.regen.textContent : '';
    if(ui.regen){ ui.regen.disabled = true; ui.regen.textContent = 'Fetching…'; }
    try{
      var res = await fetch('/api/fetch-latest', { method:'POST', headers:{'Content-Type':'application/json'} });
      // Ignore response body errors here; chart reload will show empty/error in footer if needed.
      try{ if(res && res.ok) await res.json(); } catch(_e){}
    } catch(_e2){
      // ignore; reload below will reflect current DB state
    } finally {
      if(ui.regen){ ui.regen.disabled = false; ui.regen.textContent = regenButtonLabel(); }
    }
    loadFromAPI();
  }

  ui.regen.addEventListener('click', fetchLatestAndReload);
  // Symbol dropdown interactions
  if(ui.tickerBtn){
    ui.tickerBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      toggleTickerMenu();
    });
  }
  if(ui.tickerMenu){
    ui.tickerMenu.addEventListener('click', function(e){
      var t = e.target;
      if(!t || !t.getAttribute) return;
      var v = t.getAttribute('data-value');
      if(!v) return;
      setTicker(v);
      closeTickerMenu();
      // Rebuild symbol list for this dataset and choose an appropriate default symbol.
      refreshSymbolMenuForTicker();
      var catalog = state._catalog || null;
      var ds = String(getTicker() || 'ES').trim().toUpperCase();
      var curSym = getSymbol();
      var curDs = (catalog && catalog.datasetBySymbol) ? catalog.datasetBySymbol[curSym] : '';
      if(curDs !== ds){
        var defSym = chooseDefaultSymbolForTicker(ds);
        if(defSym){
          ensureSymbolItem(defSym);
          setSymbol(defSym);
        }
      }
      scheduleSaveUiConfig();
      loadFromAPI();
    });
  }
  if(ui.symbolBtn){
    ui.symbolBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      toggleSymbolMenu();
    });
  }
  if(ui.symbolMenu){
    ui.symbolMenu.addEventListener('click', function(e){
      var t = e.target;
      if(!t || !t.getAttribute) return;
      var v = t.getAttribute('data-value');
      if(!v) return;
      setSymbol(v);
      closeSymbolMenu();
      scheduleSaveUiConfig();
      loadFromAPI();
    });
  }

  // tests
  function assert(cond, msg){ if(!cond) throw new Error('Test failed: ' + msg); }

  function applyYScaleBounds(minV, maxV, factor){
    var mid = (minV + maxV) / 2;
    var span = (maxV - minV) * factor;
    return { min: mid - span/2, max: mid + span/2 };
  }

  (function runTests(){
    assert(Array.isArray(SNAP_PRESETS) && SNAP_PRESETS.length > 5, 'snap presets');
    assert(snapToPreset(61) === 60, 'snap 61->60');
    assert(snapToPreset(89) === 60, 'snap 89->60');
    assert(snapCeilToPreset(61) === 300, 'snapCeil 61->300');
    assert(snapCeilToPreset(1) === 60, 'snapCeil clamps min preset');
    assert(snapCeilToPreset(86400) === 86400, 'snapCeil 86400->86400');

    // Minimum bar size is the smallest preset, even if the span/target would imply smaller.
    // In Alpaca-only mode, smallest preset is 60s (1-minute base resolution).
    assert(recommendBarSec(3600*1000, 5000, 800) === 60, 'recommend 1h clamps to min preset');
    // Limit guard: if limit is tiny, bar_s must grow (>= 1h/100 = 36s -> snapCeil to 60s).
    assert(recommendBarSec(3600*1000, 100, 800) >= 60, 'recommend respects max bars');

    var dummy = document.createElement('canvas').getContext('2d');
    var up = [[0,0],[1,0],[2,0]];
    var lo = [[0,1],[1,1],[2,1]];
    fillBetween(dummy, up, lo, 'rgba(255,0,0,0.2)', false);
    fillBetween(dummy, up, lo, 'rgba(0,255,0,0.2)', true);
    strokePolyline(dummy, up, 'rgba(0,0,0,1)', 1, true, [3,4]);

    var threw = false;
    try {
      roundRect(dummy, 10, 10, 100, 40, 12);
      dummy.stroke();
      roundRect(dummy, 10, 10, -50, 20, 12);
      dummy.stroke();
      roundRect(dummy, 10, 10, 20, -10, 12);
      dummy.stroke();
      roundRect(dummy, 10, 10, 0.1, 0.1, 12);
      dummy.stroke();
    } catch(e){
      threw = true;
    }
    assert(!threw, 'roundRect robustness');

    assert(!!document.getElementById('showBands'), 'showBands exists');
    assert(!!document.getElementById('showCandles'), 'showCandles exists');
    assert(!!document.getElementById('tickerDD'), 'ticker dropdown exists');
    assert(!!document.getElementById('tickerBtn'), 'ticker dropdown button exists');
    assert(!!document.getElementById('tickerMenu'), 'ticker dropdown menu exists');
    assert(!!document.getElementById('candleStyleDD'), 'candleStyle dropdown exists');
    assert(!!document.getElementById('candleStyleBtn'), 'candleStyle button exists');
    assert(!!document.getElementById('candleStyleMenu'), 'candleStyle menu exists');
    assert(!!document.getElementById('sessPreMarket'), 'session toggle pre-market exists');
    assert(!!document.getElementById('sessAfterHours'), 'session toggle after-hours exists');
    assert(!!document.getElementById('sessClosed'), 'session toggle closed exists');
    assert(!!ui.autoW, 'autoW control exists');
    assert(!!ui.showVolume && ui.showVolume.checked === true, 'showVolume forced on');
    assert(!!ui.grid && ui.grid.checked === true, 'grid forced on');
    assert(!!ui.scale && ui.scale.checked === true, 'scale forced on');

    var b0 = applyYScaleBounds(0, 10, 2);
    assert(Math.abs((b0.max - b0.min) - 20) < 1e-9, 'applyYScaleBounds doubles span');
    var b1 = applyYScaleBounds(0, 10, 0.5);
    assert(Math.abs((b1.max - b1.min) - 5) < 1e-9, 'applyYScaleBounds halves span');
  })();

  // boot
  (async function(){
    // Static demo: no API hint.
    // Enable bar size controls; they re-fetch the API with bar_s.
    ui.window.disabled = false;
    // API mode: minimum resolution is 60s.
    try{
      if(!STATIC_MODE && ui.window){
        if(Number(ui.window.value) < 30) ui.window.value = '30';
        syncBarPresetUi();
      }
      if(ui.regen) ui.regen.textContent = regenButtonLabel();
    } catch(_e){}

    // 0) Populate ticker + symbol dropdown from the server's discovered datasets.
    try{
      if(ui.symbolLabel) ui.symbolLabel.textContent = 'Loading…';
      if(ui.symbolMenu) ui.symbolMenu.innerHTML = '';
    } catch(_e){}
    var items = await fetchSymbolCatalog();
    state._catalog = buildCatalogIndex(items || []);
    // Populate ticker menu
    if(ui.tickerMenu){
      ui.tickerMenu.innerHTML = '';
      var dss = (state._catalog && state._catalog.datasets) ? state._catalog.datasets : [];
      if(dss && dss.length){
        for(var di=0; di<dss.length; di++) ensureTickerItem(dss[di]);
      } else {
        ['ES','NQ','LE'].forEach(function(d){ ensureTickerItem(d); });
      }
    }
    // Choose ticker: prefer current symbol's dataset if possible, else ES, else first.
    (function(){
      var catalog = state._catalog || null;
      var curSym = getSymbol();
      var ds0 = (catalog && catalog.datasetBySymbol) ? catalog.datasetBySymbol[curSym] : '';
      if(!ds0){
        var dss2 = (catalog && catalog.datasets) ? catalog.datasets : [];
        if(dss2.indexOf('ES') >= 0) ds0 = 'ES';
        else ds0 = (dss2[0] || 'ES');
      }
      ensureTickerItem(ds0);
      setTicker(ds0);
      refreshSymbolMenuForTicker();
      // Ensure symbol is valid for the chosen ticker.
      var syms2 = (catalog && catalog.byDataset) ? catalog.byDataset[ds0] : [];
      if(syms2 && syms2.length){
        if(syms2.indexOf(curSym) < 0){
          var def = chooseDefaultSymbolForTicker(ds0);
          if(def){ ensureSymbolItem(def); setSymbol(def); }
        } else {
          ensureSymbolItem(curSym);
          setSymbol(curSym);
        }
      } else {
        // Fallback if no catalog available.
        if(ds0 === 'ES') ['ES_CONT','ESZ5','ESU5','ESM5'].forEach(function(s){ ensureSymbolItem(s); });
        setSymbol(getSymbol());
      }
    })();

    // 1) Load persisted UI config (if present).
    var cfg = await fetchUiConfig();
    if(cfg && applyUiConfig(cfg)){
      persist.hadConfig = true;
    }

    // 2) Apply URL overrides (so shareable URLs still win).
    (function(){
      // Optional: allow symbol in URL to override config.
      var symQ = getQueryParam('symbol', '');
      if(symQ){
        var s0 = String(symQ).trim();
        // With Symbol dropdown removed, treat the URL symbol as the selected ticker too.
        ensureTickerItem(s0);
        setTicker(s0);
        ensureSymbolItem(s0);
        setSymbol(s0);
      }

      // Auto W:
      // - if explicitly specified (?auto_w=1/0), honor it
      // - otherwise, if we did NOT load a saved config, default to enabled unless bar size is in URL
      var autoQ = getQueryParam('auto_w', '');
      if(ui.autoW){
        if(autoQ !== ''){
          ui.autoW.checked = !(String(autoQ).trim() === '0');
        } else if(!persist.hadConfig){
          // Default: enabled unless bar size is explicitly specified in URL.
          var qsBar0 = getQueryParam('bar_s', '');
          var qsW0 = getQueryParam('w', '');
          ui.autoW.checked = !((qsBar0 !== '') || (qsW0 !== ''));
        }
      }

      // Bar size from URL (?bar_s=60) or legacy (?w=60), else keep existing (config/default).
      var qsBar = getQueryParam('bar_s', '');
      var qsW = getQueryParam('w', '');
      var raw = (qsBar !== '' ? qsBar : qsW);
      var ww = (raw !== '' ? clamp(Number(raw), 30, 86400) : clamp(Number(state.windowSec || ui.window.value), 30, 86400));
      if(!Number.isFinite(ww)) ww = 60;
      ww = snapToPreset(ww);
      state.windowSec = ww;
      ui.window.value = String(ww);
      ui.windowVal.textContent = formatWindow(state.windowSec);
      syncBarPresetUi();

      // Scale preset from URL (?span=1d/5d/1m/3m), else keep config/default.
      var spanQ = getQueryParam('span', '');
      if(spanQ !== ''){
        setSpanPreset(spanQ, { skipLoad: true, skipSave: true, skipUrl: true });
      } else if(!persist.hadConfig) {
        // Default to 1d unless a saved config provided something else.
        setSpanPreset('1d', { skipLoad: true, skipSave: true, skipUrl: true });
      } else {
        // Ensure UI matches current state from config.
        syncSpanPresetUi();
      }

      // Candle style from URL or existing (config/default).
      var csQ = getQueryParam('candle_style', '');
      if(csQ !== '') setCandleStyle(csQ);
      else if(!persist.hadConfig) setCandleStyle('std');
      syncCandleStyleEnabled();

      updateUrlBarSize();
      enforceAlwaysOnOptions();
    })();

    // 3) Enable persistence after initial state is coherent.
    persist.enabled = true;
    scheduleSaveUiConfig();

    loadFromAPI();
  })();

  // Live polling:
  // - Prefer incremental updates via /live/since (fast, avoids DBN scan).
  // - Do a full /window sync occasionally as a safety net.
  (function(){
    if(STATIC_MODE) return;
    try{
      if(livePollTimer) clearInterval(livePollTimer);
      livePollTimer = setInterval(function(){
        try{
          if(!state.followLatest) return;
          if(state.dragging || state.yDragging) return;
          if(ui.regen && ui.regen.disabled) return; // request in flight
          pollLiveIncremental();
          var now = Date.now();
          var lastFull = Number(state._lastFullSyncAtMs);
          if(!Number.isFinite(lastFull) || (now - lastFull) > 60_000){
            if(ui.regen && ui.regen.disabled) return; // request in flight
            loadFromAPI();
          }
        } catch(_e){}
      }, 2_000);
    } catch(_e){}
  })();

  // Live status polling (for freshness diagnostics / UI chip hints).
  (function(){
    if(STATIC_MODE) return;
    try{
      if(liveStatusTimer) clearInterval(liveStatusTimer);
      liveStatusTimer = setInterval(async function(){
        try{
          return; // disabled in static demo
          if(!res.ok) return;
          var j = await res.json();
          state._liveStatus = j;
          state._liveStatusAtMs = Date.now();
        } catch(_e){}
      }, 15_000);
    } catch(_e){}
  })();

  // Snapshot folder picker (file:// support).
  (function(){
    var btn = document.getElementById('pickStaticDir');
    if(!btn) return;
    btn.addEventListener('click', async function(){
      try{
        if(!window.showDirectoryPicker){
          alert('Directory picker not available in this browser. Serve this folder over http(s) or use Edge/Chrome.');
          return;
        }
        var h = await window.showDirectoryPicker();
        // Detect whether this is the root (contains catalog.json) or the bars folder.
        _staticDirMode = '';
        _staticRootDirHandle = null;
        _staticBarsDirHandle = null;
        _staticGeneratedCatalog = null;
        try{
          await h.getFileHandle('catalog.json');
          _staticDirMode = 'root';
          _staticRootDirHandle = h;
        } catch(_e){
          // Treat as bars directory and generate a catalog from filenames.
          _staticDirMode = 'bars';
          _staticBarsDirHandle = h;
          _staticGeneratedCatalog = await generateCatalogFromBarsDir(h);
        }
        // Try to load catalog immediately to populate menus.
        var items = await fetchSymbolCatalog();
        state._catalog = buildCatalogIndex(items || []);
        if(ui.tickerMenu){
          ui.tickerMenu.innerHTML = '';
          var dss = (state._catalog && state._catalog.datasets) ? state._catalog.datasets : [];
          if(dss && dss.length){
            for(var di=0; di<dss.length; di++) ensureTickerItem(dss[di]);
          }
        }
        // Re-sync menus + reload.
        refreshSymbolMenuForTicker();
        scheduleSaveUiConfig();
        loadFromAPI();
      } catch(e){
        try{ console.error(e); } catch(_e){}
      }
    });
  })();

  // Single bars-file picker (file:// support).
  (function(){
    var btn = document.getElementById('pickBarsFile');
    if(!btn) return;
    var input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    input.style.display = 'none';
    document.body.appendChild(input);

    btn.addEventListener('click', function(){
      try{ input.value = ''; } catch(_e){}
      input.click();
    });

    input.addEventListener('change', async function(){
      try{
        var f = (input.files && input.files[0]) ? input.files[0] : null;
        if(!f) return;
        var txt = await f.text();
        var j = JSON.parse(txt);
        if(!j || typeof j !== 'object') throw new Error('Invalid JSON');
        if(!Array.isArray(j.t_ms) || !Array.isArray(j.o) || !Array.isArray(j.h) || !Array.isArray(j.l) || !Array.isArray(j.c) || !Array.isArray(j.v)){
          throw new Error('Unexpected JSON shape. Expected arrays: t_ms,o,h,l,c,v');
        }
        var sym = String(j.symbol || '').trim();
        var bs = Math.floor(Number(j.bar_s) || 60);
        if(!sym) sym = String(getSymbol() || 'ES_CONT').trim();
        if(!Number.isFinite(bs) || bs <= 0) bs = Math.floor(Number(state.windowSec) || 60);
        _staticBarsByKey[barsKey(sym, bs)] = j;
        rememberBarsPayload(j);
        // Also synthesize a catalog (single symbol) so menus work.
        _staticGeneratedCatalog = { symbols: [{ dataset: inferDatasetFromSymbol(sym), symbol: sym }], _generated: true };
        _staticDirMode = ''; // file-driven
        _staticRootDirHandle = null;
        _staticBarsDirHandle = null;

        // Update UI state to match the file and reload.
        ensureTickerItem(inferDatasetFromSymbol(sym) || 'ES');
        setTicker(inferDatasetFromSymbol(sym) || 'ES');
        refreshSymbolMenuForTicker();
        ensureSymbolItem(sym);
        setSymbol(sym);
        state.windowSec = snapToPreset(clamp(bs, 60, 86400));
        if(ui.window) ui.window.value = String(state.windowSec);
        if(ui.windowVal) ui.windowVal.textContent = formatWindow(state.windowSec);
        syncBarPresetUi();
        scheduleSaveUiConfig();
        loadFromAPI();
      } catch(e){
        alert('Failed to load bars file: ' + String(e && e.message ? e.message : e));
      }
    });
  })();

  // Continuous detrend + oscillation scan (UI only): dial widgets
  // Ported from osc demo, but intentionally NOT wired into analysis yet.
  (function(){
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function getCSS(name){
      try{ return String(getComputedStyle(document.documentElement).getPropertyValue(name) || '').trim(); }
      catch(_e){ return ''; }
    }
    function fmtLookbackShort(min){
      var m = Math.max(0, Math.round(Number(min) || 0));
      if(m < 60) return String(m) + 'm';
      if(m % 60 === 0){
        var h = m/60;
        if(h < 24) return String(h) + 'h';
        var d = h/24;
        return (Number.isInteger(d) ? d : d.toFixed(1)) + 'd';
      }
      return (m/60).toFixed(1) + 'h';
    }

    // Minimal dial implementation (canvas knob + pointer interactions)
    function createDial(opts){
      var canvas = opts.canvas;
      if(!canvas) return null;
      var min = Number(opts.min);
      var max = Number(opts.max);
      var step = Number(opts.step || 1);
      var format = opts.format || function(v){ return String(v); };
      var onChange = opts.onChange || function(){};
      var colorVar = opts.colorVar || '';
      var color = opts.color || '';

      // 270° sweep centered at bottom (like many audio knobs)
      var START = (-225) * Math.PI/180;
      var END   = (  45) * Math.PI/180;
      var SWEEP = END - START;
      var ctx = canvas.getContext('2d');

      function snap(v){
        var s = step > 0 ? step : 1;
        return Math.round(v / s) * s;
      }
      function valueToAngle(v){
        var t = (clamp(v, min, max) - min) / (max - min || 1);
        return START + t * SWEEP;
      }
      function angleToValue(a){
        var TWO_PI = Math.PI * 2;
        var aa = a;
        while(aa > END) aa -= TWO_PI;
        while(aa < START) aa += TWO_PI;
        var t = (aa - START) / (SWEEP || 1);
        t = clamp01(t);
        return snap(min + t * (max - min));
      }

      function dialColor(){
        if(color) return color;
        if(colorVar) return getCSS(colorVar) || 'rgba(90,150,255,.95)';
        return 'rgba(90,150,255,.95)';
      }

      function draw(v){
        var dpr = window.devicePixelRatio || 1;
        var rect = canvas.getBoundingClientRect();
        // If the section is collapsed, the canvas can be 0×0; skip until visible.
        if(!(rect.width > 0 && rect.height > 0)) return;

        var size = Math.max(1, Math.floor(rect.width * dpr));
        if(canvas.width !== size || canvas.height !== size){
          canvas.width = size;
          canvas.height = size;
        }
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr, dpr);

        var w = rect.width, h = rect.height;
        var cx = w/2, cy = h/2;
        var r = Math.min(w,h)*0.42;

        ctx.clearRect(0,0,w,h);

        // base ring
        ctx.save();
        ctx.lineWidth = Math.max(10, r*0.14);
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.beginPath();
        ctx.arc(cx, cy, r, START, END, false);
        ctx.stroke();

        // value ring
        var a = valueToAngle(v);
        ctx.strokeStyle = dialColor();
        ctx.beginPath();
        ctx.arc(cx, cy, r, START, a, false);
        ctx.stroke();

        // tick dots
        var ticks = 9;
        ctx.fillStyle = 'rgba(255,255,255,0.10)';
        for(var i=0; i<=ticks; i++){
          var tt = i / ticks;
          var ang = START + tt*SWEEP;
          var tx = cx + Math.cos(ang) * (r + ctx.lineWidth*0.25);
          var ty = cy + Math.sin(ang) * (r + ctx.lineWidth*0.25);
          ctx.beginPath();
          ctx.arc(tx, ty, 1.5, 0, Math.PI*2);
          ctx.fill();
        }

        // knob center
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.beginPath();
        ctx.arc(cx, cy, r*0.78, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // pointer
        ctx.strokeStyle = dialColor();
        ctx.lineWidth = 3;
        var px = cx + Math.cos(a) * (r*0.90);
        var py = cy + Math.sin(a) * (r*0.90);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(px, py);
        ctx.stroke();

        // value text
        ctx.fillStyle = getCSS('--text') || 'rgba(215,224,234,.92)';
        ctx.font = '800 18px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(format(v), cx, cy + r*0.55);

        ctx.restore();
      }

      var value = snap(clamp(Number(opts.value), min, max));
      function setValue(v, fire){
        if(fire === undefined) fire = true;
        var nv = snap(clamp(Number(v), min, max));
        if(nv === value) return;
        value = nv;
        draw(value);
        if(fire) onChange(value);
      }

      function pointerToAngle(ev){
        var rect = canvas.getBoundingClientRect();
        var x = (ev.clientX - rect.left) - rect.width/2;
        var y = (ev.clientY - rect.top)  - rect.height/2;
        return Math.atan2(y, x);
      }

      var dragging = false;
      function onPointerDown(ev){
        dragging = true;
        canvas.setPointerCapture(ev.pointerId);
        setValue(angleToValue(pointerToAngle(ev)), true);
      }
      function onPointerMove(ev){
        if(!dragging) return;
        setValue(angleToValue(pointerToAngle(ev)), true);
      }
      function onPointerUp(ev){
        dragging = false;
        try{ canvas.releasePointerCapture(ev.pointerId); } catch(_e){}
      }

      canvas.addEventListener('pointerdown', onPointerDown);
      canvas.addEventListener('pointermove', onPointerMove);
      canvas.addEventListener('pointerup', onPointerUp);
      canvas.addEventListener('pointercancel', onPointerUp);

      canvas.addEventListener('wheel', function(ev){
        ev.preventDefault();
        var dir = ev.deltaY > 0 ? -1 : 1;
        setValue(value + dir*step, true);
      }, {passive:false});

      // initial draw (may be skipped if collapsed)
      draw(value);

      return {
        get value(){ return value; },
        setValue: setValue,
        redraw: function(){ draw(value); }
      };
    }

    var details = document.querySelector('details.sideCard[aria-label="Continuous detrend + oscillation scan"]');
    var detrendCanvas = document.getElementById('detrendDial');
    var scanCanvas = document.getElementById('scanDial');
    var detrendInput = document.getElementById('detrendHours');
    var scanInput = document.getElementById('scanWindow');
    var detrendLabel = document.getElementById('detrendLabel');
    var scanLabel = document.getElementById('scanLabel');
    if(!detrendCanvas || !scanCanvas || !detrendInput || !scanInput) return;

    function updateLabels(){
      var dh = Number(detrendInput.value) || 2.0;
      var sw = Math.round(Number(scanInput.value) || 780);
      if(detrendLabel) detrendLabel.textContent = (dh).toFixed(1) + 'h';
      if(scanLabel) scanLabel.textContent = fmtLookbackShort(sw);
    }

    // Create dials (UI-only: update labels/hidden inputs)
    var detrendDial = createDial({
      canvas: detrendCanvas,
      min: 0.25,
      max: 8.0,
      step: 0.25,
      value: Number(detrendInput.value) || 2.0,
      color: 'rgba(122,227,255,0.95)',
      format: function(v){ return Number(v).toFixed(1) + 'h'; },
      onChange: function(v){
        detrendInput.value = Number(v).toFixed(2);
        updateLabels();
      }
    });

    var scanDial = createDial({
      canvas: scanCanvas,
      min: 120,
      max: 14400, // MINUTES_PER_DAY*10 (UI-only mirror)
      step: 30,
      value: Math.round(Number(scanInput.value) || 780),
      color: 'rgba(255,209,102,0.95)',
      format: function(v){ return fmtLookbackShort(v); },
      onChange: function(v){
        scanInput.value = String(Math.round(Number(v)));
        updateLabels();
      }
    });

    // If the section starts collapsed, redraw on open so canvases have real sizes.
    function redrawIfVisible(){
      try{ if(detrendDial) detrendDial.redraw(); } catch(_e){}
      try{ if(scanDial) scanDial.redraw(); } catch(_e){}
    }
    if(details){
      details.addEventListener('toggle', function(){
        if(details.open) redrawIfVisible();
      });
    }
    window.addEventListener('resize', redrawIfVisible);
    updateLabels();
  })();

  window.addEventListener('resize', resize);
  requestAnimationFrame(resize);

  </script>
</body>
</html>
