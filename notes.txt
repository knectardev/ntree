Combining your existing **ntree** dashboard (Flask) with the **Market Inventions** engine (FastAPI) into a unified server is the best way to leverage your 90-day historical data while maintaining the sub-second musical performance.

Based on the current structure, here is the recommended path forward:

### 1. The Mounting Strategy: Root vs. `/dashboard`

The cleanest approach for a trading app is to let the **Flask Dashboard take the root (`/`)** while the **Market Inventions performance lives at `/market_inventions/**`.

* **Why?** Your existing Flask routes (like `/ticker/SPY`) are likely already hardcoded in your templates. Moving them to `/dashboard/ticker/SPY` would require a tedious search-and-replace across your HTML files.
* **The Compromise**: We will mount Flask at the root level using `WSGIMiddleware`. FastAPI will intercept specific paths (like `/market_inventions/`) first, and everything else will "fall through" to the Flask app.

### 2. Solving the Import Path Challenge

Since `main.py` is in a subdirectory (`market_inventions_port/`) and `app.py` is in the root, we will use a **Root Entry Point**.

I recommend creating a new file at the project root called `run_unified.py`. This avoids `ModuleNotFoundError` by ensuring both folders are in the Python path simultaneously.

```python
# run_unified.py (Place in c:\local_dev\ntree)
import sys
import os
from fastapi import FastAPI
from fastapi.middleware.wsgi import WSGIMiddleware
from fastapi.staticfiles import StaticFiles

# 1. Add current directory to path so we can find app.py and market_inventions_port
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# 2. Import the two apps
from app import app as flask_app
from market_inventions_port.main import app as fast_api_app

# 3. Mount Flask into FastAPI
# This allows Flask to handle all routes not captured by FastAPI
fast_api_app.mount("/", WSGIMiddleware(flask_app))

app = fast_api_app # Export the unified app for uvicorn

```

### 3. Unified Startup Command

Once `run_unified.py` is created, your startup becomes much simpler:

```bash
cd c:\local_dev\ntree
uvicorn run_unified:app --port 8001 --reload

```

*Note: Use port 8001 for both now. Your browser will access `http://localhost:8001/` for the ntree dashboard and `http://localhost:8001/market_inventions/` for the music.*

### 4. Shared Config: "Minimal First" then "Refactor"

Since you are in the middle of a migration, **Option 2 (Minimal Integration first)** is the safer play.

* **Step 1**: Get the unified server running using the existing hardcoded keys in both files.
* **Step 2**: Once you verify the WebSocket hasn't lost its "16-step" performance, create a `config.py` in the root and move your Alpaca keys there.

### 5. Managing Shared Resources (The DB)

Because youâ€™re running in one process now, you can eventually share the database connection.

### Final Instruction for Cursor:

To implement this, you can tell Cursor:

> "Create a `run_unified.py` in the root directory. Use `WSGIMiddleware` to mount the `app` from `app.py` onto the `app` from `market_inventions_port/main.py`. Ensure the root path `/` is handled by Flask, but keep the `/market_inventions/` routes explicitly in FastAPI so the high-frequency WebSockets aren't slowed down by the Flask middleware."

**Does this unified structure solve the port conflict while keeping your existing dashboard accessible?**