Would this add value in your system?
✅ Yes — but only for one specific purpose

It adds value if the question is:

“Is this rhythm structural or merely episodic?”

That is not something your current global sine fit can fully answer.

Your current metrics tell you:

stability across windows

average coherence

total energy contribution

They do not tell you:

when the rhythm is active

whether it switches off/on

whether phase resets occur

Segmentation answers those questions.

“Rhythm Presence Map” (diagnostic only)

For the already-selected period:

slide a short window

compute local amplitude / correlation

mark:

strong presence

weak presence

phase breaks

Visually:

opacity modulation

dashed vs solid segments

subtle background bands

Crucially:

no new period selection

no automatic regime switching

no additional scores feeding selection

Just: where does this rhythm breathe?



Nice — this is the perfect insertion point. You already have:

cycleTf (your bandpass-ish rhythm series)

sineFit.fit (global sine fit at the selected period)

drawSeries() for plotting

Here’s the clean way to add a “Local presence” mode without clutter:

Goal

Keep cycleTf as the main line, and add a presence strip (and optionally a gated/thickened rhythm line) driven by a local coherence score.

1) Add a local-presence computation (fast + simple)

In scan.js (pure functions), add:

computeLocalSinePresence(series, periodMin, windowCycles=2.5, step=1)

returns presence[] aligned with series length, values 0..1 (use r mapped to 0..1 or varShare)

Practical choice: use correlation r because it’s intuitive and already in your system.

Presence mapping:

presence = clamp((r - r0) / (r1 - r0), 0, 1)

where r0=0.2, r1=0.7 (tunable)

Also: compute it on the tail window to avoid huge CPU cost.

2) Render it as a strip in the rhythm panel (minimal clutter)

Add right after drawSeries(cycleRect, cycleTf, ...):

// Local presence strip (diagnostic mode)
if (state.rhythmFitMode === "local_presence" && activePeriodMin != null) {
  const pres = state._localPresence; // cached per activePeriodMin + scanWindow
  if (pres && pres.length) {
    drawPresenceStrip(cycleRect, pres);
  }
}

Presence strip drawing logic (simple)

Draw a thin bar along the bottom of cycleRect

For each x pixel (or each sample), set opacity based on presence

Visually it reads: bright = rhythm present; dim = absent

3) Optional: make the rhythm line “thicken” only where present

This is the more dramatic (and cool) version, but still honest:

draw normal cycleTf faint

draw a second pass where presence is high with higher alpha/lineWidth

Where your snippet fits

You already have:

const cycleScale = drawSeries(cycleRect, cycleTf, cycleColor, { alpha: cycleAlpha });

if (sineFit && sineFit.fit) {
  const sineColor = getCSS("--accent2");
  const a = state.showFourierOverlay ? 0.28 : 0.6;
  drawSeries(cycleRect, sineFit.fit, sineColor, { dashed: true, alpha: a, lineWidth: 1.25, showGuides: false });
}


Here’s the minimal change that keeps your current behavior and adds the new mode:

const cycleScale = drawSeries(cycleRect, cycleTf, cycleColor, { alpha: cycleAlpha });

// New: local presence overlay (strip + optional gated highlight)
if (state.rhythmFitMode === "local_presence" && state.localPresence && state.localPresence.length) {
  drawPresenceStrip(cycleRect, state.localPresence);

  if (state.localPresenceHighlight) {
    // draw a "gated" highlight version of the rhythm where presence is strong
    drawSeriesGatedByPresence(cycleRect, cycleTf, cycleColor, state.localPresence, {
      alpha: 0.9,
      lineWidth: 2.0,
      threshold: state.localPresenceThresh || 0.55
    });
  }
}

// Keep your existing global sine fit mode
if (state.rhythmFitMode !== "off" && sineFit && sineFit.fit) {
  const sineColor = getCSS("--accent2");
  const a = state.showFourierOverlay ? 0.28 : 0.6;
  const dashed = (state.rhythmFitMode === "global_sine");
  drawSeries(cycleRect, sineFit.fit, sineColor, { dashed, alpha: a, lineWidth: 1.25, showGuides: false });
}

Caching requirement (so you don’t jank)

Don’t compute local presence inside render.

Cache state.localPresence when any of these change:

selected/active period

scan window length (tailN)

detrend lookback

the underlying resid1m tail identity (last timestamp / length)

This is the same caching logic you already had to add for projection spectrum.

Recommended UX default

Add a dropdown: Fit mode: Global sine / Local presence / Off

Default to Global sine (what you already have)

Local presence is opt-in “diagnostic mode”

That keeps things from feeling cluttered.