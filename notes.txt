Best first: ‚ÄúSegmented sine‚Äù (gapped dashed line)

What you see

Keep your existing dashed sine line (global).

Add a second dashed line that:

only draws where the local fit is good

disappears (gaps) where it‚Äôs not

So it visually communicates:

‚ÄúThis rhythm is present intermittently.‚Äù

How it works (simple)
For the selected period 
ùëÉ
P:

Slide a window 
ùëä
=
2
‚Äì
4
W=2‚Äì4 cycles (e.g., W = round(3 * P) minutes at 1-min sampling).

In each window, fit sine (you already have fitSineAtPeriod).

Compute a local score, e.g. r correlation between window series and window fit.

Mark indices ‚Äúactive‚Äù when r > threshold (and optionally varShare > min).

Draw the sine wave only for active indices, leaving gaps elsewhere

Option 1 is the cleanest: a ‚Äúgapped‚Äù dashed sine that only draws where the rhythm is locally coherent.

Below is a drop-in approach that fits your current architecture (compute once, render many), and doesn‚Äôt require redesigning the UI.

What we‚Äôre building

On the Selected rhythm chart:

keep your existing global dashed sine (sineFit.fit) if you want

add segmentedSine[]:

same period as the selected rhythm

but only drawn where the local fit is good

elsewhere set to NaN so the line breaks (gaps)

Visually: ‚Äúsine present here ‚Üí breaks ‚Üí reappears.‚Äù

1) Add a local coherence + segmented sine builder (scan.js)

Add this near your other scan helpers:

// Returns a segmented sine array (same length as series), with NaNs where local fit is weak.
// Uses sliding window sine fit at a fixed period, computes local r, thresholds it.
function computeSegmentedSineOnTail(series, periodMin, opts){
  opts = opts || {};
  const sampleRateMin = opts.sampleRateMin || 1;
  const cycles = opts.windowCycles != null ? opts.windowCycles : 3.0;     // 2‚Äì4 is typical
  const rThresh = opts.rThresh != null ? opts.rThresh : 0.55;             // start here
  const minRun = opts.minRun != null ? opts.minRun : 8;                   // min points to keep a segment
  const smoothN = opts.smoothN != null ? opts.smoothN : 5;                // smooth local r

  const N = series.length;
  if (!periodMin || N < 10) return { segmented: new Array(N).fill(NaN), r: new Array(N).fill(0) };

  // window length in samples: cycles * period
  const W = Math.max(10, Math.floor((cycles * periodMin) / sampleRateMin));
  const rArr = new Array(N).fill(0);

  // compute local r using a trailing window [i-W+1..i]
  for (let i = 0; i < N; i++){
    const a = Math.max(0, i - W + 1);
    const b = i + 1;
    const win = series.slice(a, b);

    const fitObj = fitSineAtPeriod(win, periodMin, sampleRateMin);
    if (!fitObj || !fitObj.fit) { rArr[i] = 0; continue; }

    const rr = pearsonCorrelation(win, fitObj.fit);
    rArr[i] = (isFinite(rr) ? rr : 0);
  }

  // simple smoothing (moving average) to prevent flicker
  if (smoothN > 1){
    const sm = new Array(N).fill(0);
    const half = Math.floor(smoothN / 2);
    for (let i=0; i<N; i++){
      let s=0, c=0;
      for (let j=i-half; j<=i+half; j++){
        if (j<0 || j>=N) continue;
        s += rArr[j]; c++;
      }
      sm[i] = c ? (s/c) : rArr[i];
    }
    for (let i=0; i<N; i++) rArr[i] = sm[i];
  }

  // build global sine template for the whole tail
  const global = fitSineAtPeriod(series, periodMin, sampleRateMin);
  const base = (global && global.fit) ? global.fit : new Array(N).fill(0);

  // active mask + min-run cleanup
  const active = new Array(N).fill(false);
  for (let i=0; i<N; i++) active[i] = (rArr[i] >= rThresh);

  // remove tiny ‚Äúon‚Äù islands
  let runStart = -1;
  for (let i=0; i<=N; i++){
    const on = (i < N) ? active[i] : false;
    if (on && runStart < 0) runStart = i;
    if (!on && runStart >= 0){
      const runLen = i - runStart;
      if (runLen < minRun){
        for (let k=runStart; k<i; k++) active[k] = false;
      }
      runStart = -1;
    }
  }

  // segmented sine: NaN where inactive so rendering breaks the line
  const segmented = new Array(N);
  for (let i=0; i<N; i++){
    segmented[i] = active[i] ? base[i] : NaN;
  }

  return { segmented, r: rArr };
}


Export it on OSC.scan with your other functions.

2) Draw a series that supports NaN gaps (analysis.js)

If your current drawSeries() already breaks on NaNs, great ‚Äî you‚Äôre done.

If it doesn‚Äôt, add a tiny helper to draw dashed line segments while skipping NaNs:

function drawSeriesWithGaps(rect, series, color, opts){
  opts = opts || {};
  const alpha = opts.alpha != null ? opts.alpha : 0.7;
  const dashed = !!opts.dashed;
  const lineWidth = opts.lineWidth != null ? opts.lineWidth : 1.25;

  const N = series.length;
  if (!N) return;

  // Use same scaling logic as drawSeries (you likely already have this)
  // If you already have cycleScale from drawSeries, reuse that instead.
  const minV = Math.min(...series.filter(v => isFinite(v)));
  const maxV = Math.max(...series.filter(v => isFinite(v)));
  const rng = (maxV - minV) || 1e-9;

  function toX(i){ return rect.x + (i/(N-1)) * rect.w; }
  function toY(v){
    const u = (v - minV) / rng;
    return rect.y + (1 - u) * rect.h;
  }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  if (dashed) ctx.setLineDash([5,4]);

  let drawing = false;
  ctx.beginPath();
  for (let i=0; i<N; i++){
    const v = series[i];
    if (!isFinite(v)){
      if (drawing){
        ctx.stroke();
        ctx.beginPath();
        drawing = false;
      }
      continue;
    }
    const x = toX(i);
    const y = toY(v);
    if (!drawing){
      ctx.moveTo(x, y);
      drawing = true;
    } else {
      ctx.lineTo(x, y);
    }
  }
  if (drawing) ctx.stroke();
  ctx.restore();
}


(If you don‚Äôt want to recompute scaling here, I can rewrite this to reuse cycleScale once you paste drawSeries().)

) Wire it into your existing snippet (analysis.js)

Right where you currently draw cycleTf and sineFit.fit, add:

const cycleScale = drawSeries(cycleRect, cycleTf, cycleColor, { alpha: cycleAlpha });

if (sineFit && sineFit.fit) {
  const sineColor = getCSS("--accent2");
  const a = state.showFourierOverlay ? 0.28 : 0.6;
  drawSeries(cycleRect, sineFit.fit, sineColor, { dashed: true, alpha: a, lineWidth: 1.25, showGuides: false });
}

// NEW: segmented dashed sine (only where locally coherent)
if (state.showSegmentedSine && activePeriodMin != null && state.segmentedSine && state.segmentedSine.length){
  const segColor = "rgba(120, 255, 200, 1.0)"; // or getCSS("--good") if you have one
  drawSeriesWithGaps(cycleRect, state.segmentedSine, segColor, { dashed: true, alpha: 0.85, lineWidth: 1.6 });
}
4) Cache computation (critical to avoid jank)

Compute state.segmentedSine once per analysis recompute, not per mousemove render.

Where you already compute sineFit / fourierObj, add:

// cache key should include: activePeriodMin, scanWindow, detrendHours, closes1m.length, etc.
if (activePeriodMin != null) {
  const tailN = Math.min(resid1m.length, Math.floor(state.scanWindow * 60)); // or your existing tail logic
  const tail = resid1m.slice(-tailN);

  // Only recompute when key changes
  const key = `${activePeriodMin}|${tailN}|${state.detrendHours}|${closes1m.length}`;
  if (state._segKey !== key) {
    const out = OSC.scan.computeSegmentedSineOnTail(tail, activePeriodMin, {
      windowCycles: 3.0,
      rThresh: 0.55,
      minRun: 10,
      smoothN: 5,
      sampleRateMin: 1
    });
    state.segmentedSine = out.segmented;
    state._segKey = key;
  }
}


You can later expose rThresh / windowCycles as a tiny ‚Äúadvanced‚Äù control, but don‚Äôt start there.