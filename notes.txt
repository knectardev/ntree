The "static" you're hearing is a symptom of **voice pile-up**. In your current `conductor.js`, every time a sub-step triggers (even during a slide), the engine is layering new audio objects without properly disposing of the old ones. After 10 seconds, the browser is trying to calculate hundreds of overlapping sine waves, leading to digital "crackle" and eventually total silence.

To fix this, we need to enforce a **Strict Monophonic Policy** for the soprano slide.

### 1. The Fix: Clean Up Before New Notes

In `playSopranoSlideVoice`, you are calling `triggerAttack` frequently. If `doSlide` is false (meaning a new phrase or "pluck" starts), you **must** kill the existing sound immediately to prevent overlap.

**Modify `playSopranoSlideVoice` in `conductor.js`:**

```javascript
function playSopranoSlideVoice(midi, nowSec, duration, doSlide) {
    const synth = _sopranoSlide.voice;
    const note = Tone.Frequency(midi, "midi");

    if (!doSlide) {
        // ESSENTIAL: Kill the previous tail before starting a new pluck.
        // This prevents the "stacking" that causes the static.
        synth.triggerRelease(nowSec); 
        synth.triggerAttack(note, nowSec + 0.01); // Tiny offset to ensure release registers
    } else {
        // For a true slide, we do NOT triggerAttack. We only move the frequency.
        const midiGap = Math.abs(midi - (_phrasingState.soprano.lastMidi || midi));
        const glideSec = Math.max(0.02, Math.min(0.3, midiGap * 0.05));
        
        synth.portamento = glideSec;
        synth.setNote(note, nowSec);
    }
}

```

### 2. Safeguard: Polyphony Limit

Your `ensureSopranoSlideVoice` function likely creates a new synth if one doesn't exist. If for some reason the `_sopranoSlide.active` flag gets toggled incorrectly, you might be creating multiple synths.

**Check your `ensureSopranoSlideVoice` and add a `volume` cap and `polyphony` limit:**

```javascript
// Inside ensureSopranoSlideVoice
if (!_sopranoSlide.voice) {
    _sopranoSlide.voice = new Tone.MonoSynth({
        oscillator: { type: "sawtooth" },
        envelope: { attack: 0.02, release: 0.5 },
        portamento: 0.05
    }).toDestination();
    
    // Add a limiter to prevent signal peaking
    const limiter = new Tone.Limiter(-6).toDestination();
    _sopranoSlide.voice.connect(limiter);
}

```

### 3. The "Ghost" Release

The static often happens because a note is triggered but never told to stop. Ensure your `processSubStep` logic actually calls for a release if no note is found for that step.

**At the start of your Soprano logic block in `processSubStep`:**

```javascript
if (!shouldPlaySoprano && _sopranoSlide.active) {
    // If the price logic says "don't play", we must force a silence
    _sopranoSlide.voice.triggerRelease(now);
}

```

### Why this stops the static:

The crackling isn't a "bug" in the musical logic; it's the CPU hitting 100% because it's trying to render too many voices.

* **The Problem:** 16th note triggers  10 seconds = 160 active oscillators.
* **The Solution:** Using `triggerRelease` and `setNote` ensures that at any given millisecond, there is **exactly one** oscillator running for the soprano.

**Next Step:** Try adding `console.log(Tone.Destination.context.decodeAudioData)` (or checking the "Performance" tab in DevTools). If the number of "Active Nodes" keeps climbing while you play, the `triggerRelease` fix above is your primary solution. Would you like me to look at the specific `processSubStep` loop to see where the "orphaned" notes are coming from?