<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ ticker }} - Stock Detail</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            min-height: 100vh;
            padding: 5px;
            margin: 0;
        }
        
        .container {
            max-width: none; /* Remove max-width constraint */
            margin: 0;
            width: 100%; /* Use full available width */
            padding: 0; /* No side padding */
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: white;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .back-link {
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            transition: background 0.3s;
            font-weight: 500;
        }
        
        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .chart-container {
            background: #000;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 0; /* No padding to allow full width */
            padding-right: 0;
            margin-bottom: 20px;
            overflow: hidden; /* Hide overflow */
            width: 100% !important; /* Force full width */
            min-width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .interval-selector {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .interval-link {
            display: inline-block;
            margin: 0 10px;
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }
        
        .interval-link:hover {
            text-decoration: underline;
        }
        
        .interval-link.active {
            color: #764ba2;
            font-weight: 600;
            text-decoration: underline;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.2em;
        }
        
        .chart-wrapper {
            position: relative;
            width: 100% !important;
            min-width: 100% !important;
            max-width: 100% !important;
            height: 700px;
            padding-bottom: 30px;
            padding-right: 0;
            padding-left: 0;
            overflow: visible; /* Allow labels to be visible */
            box-sizing: border-box;
        }
        
        canvas {
            max-height: 700px;
            width: 100% !important; /* Ensure canvas uses full width */
            height: 700px !important; /* Set explicit height */
            cursor: crosshair;
            overflow: visible; /* Ensure canvas doesn't clip */
            display: block; /* Remove inline-block spacing */
            background: #000; /* Black chart background */
        }

        .macd-chart-container {
            margin-top: 8px;
            height: 180px;
        }

        #macdChart {
            width: 100% !important;
            height: 180px !important;
            display: block;
        }
        
        .chart-controls {
            margin-top: 15px;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }
        
        .market-hours-legend {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            padding: 10px;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.75em;
            z-index: 10;
            min-width: 180px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }
        
        .legend-color.regular {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .legend-color.pre-market {
            background-color: rgba(52, 152, 219, 0.1);
            border-color: rgba(52, 152, 219, 0.2);
        }
        
        .legend-color.after-hours {
            background-color: rgba(155, 89, 182, 0.1);
            border-color: rgba(155, 89, 182, 0.2);
        }
        
        .legend-color.closed {
            background-color: rgba(149, 165, 166, 0.1);
            border-color: rgba(149, 165, 166, 0.2);
        }

        .global-nav {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 2000;
        }
        .global-nav select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #334155;
            background: #0b1220;
            color: #e2e8f0;
        }
        
        .indicator-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
        }
        
        .indicator-controls-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.85em;
            align-items: flex-start;
        }
        
        .indicator-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            cursor: pointer;
            white-space: nowrap;
            color: #333;
        }
        
        .indicator-label-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .indicator-label input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        
        .indicator-color-line {
            height: 0;
            width: 30px;
            margin-left: 20px; /* Align with checkbox + text */
            margin-top: 2px;
        }

        .indicator-title {
            font-weight: 700;
            margin-right: 6px;
            color: #2c3e50;
            white-space: nowrap;
        }

        .strategy-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 12;
            background: rgba(255, 255, 255, 0.96);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.18);
            padding: 10px 12px;
            min-width: 260px;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .strategy-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .strategy-select {
            flex: 1;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.9em;
        }

        .strategy-button {
            padding: 7px 10px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .strategy-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        .strategy-card {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 0.85em;
            color: #374151;
        }

        .strategy-card h4 {
            margin: 0 0 4px 0;
            font-size: 0.95em;
            color: #111827;
        }

        .strategy-param {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            padding: 2px 0;
        }

        .strategy-result-line {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            padding: 2px 0;
        }
    </style>
</head>
<body>
    <div class="global-nav">
        <select id="globalNavSelect">
            <option value="/">Dashboard</option>
            <option value="/backtest-config">Backtest Configurations</option>
            <option value="/package-proof-of-concept">Package POC</option>
        </select>
    </div>
    <div class="container">
        <div class="header">
            <h1>{{ ticker }} - Stock Detail</h1>
            <a href="/" class="back-link">← Back to Dashboard</a>
        </div>
        
        <div class="chart-container">
            <div class="interval-selector">
                <a href="/ticker/{{ ticker }}?interval=1Min" class="interval-link" id="link-1min">1 Minute View</a>
                <a href="/ticker/{{ ticker }}?interval=5Min" class="interval-link" id="link-5min">5 Minute View</a>
            </div>
            
            <div id="loading" class="loading">Loading chart data...</div>
            <div class="chart-wrapper" id="chartWrapper" style="display: none;">
                <canvas id="stockChart"></canvas>
                <div class="indicator-controls" id="indicatorControls">
                    <div class="indicator-controls-box">
                        <label class="indicator-label">
                            <div class="indicator-label-row">
                                <input type="checkbox" id="toggle-pandas-ema9" onchange="toggleIndicator('pandas','ema9')" checked>
                                EMA 9
                            </div>
                            <div class="indicator-color-line" style="border-top: 3px solid rgba(255, 99, 132, 0.7);"></div>
                        </label>
                        <label class="indicator-label">
                            <div class="indicator-label-row">
                                <input type="checkbox" id="toggle-pandas-ema21" onchange="toggleIndicator('pandas','ema21')" checked>
                                EMA 21
                            </div>
                            <div class="indicator-color-line" style="border-top: 3px solid rgba(54, 162, 235, 0.7);"></div>
                        </label>
                        <label class="indicator-label">
                            <div class="indicator-label-row">
                                <input type="checkbox" id="toggle-pandas-ema50" onchange="toggleIndicator('pandas','ema50')">
                                EMA 50
                            </div>
                            <div class="indicator-color-line" style="border-top: 3px solid rgba(255, 206, 86, 0.7);"></div>
                        </label>
                        <label class="indicator-label">
                            <div class="indicator-label-row">
                                <input type="checkbox" id="toggle-pandas-vwap" onchange="toggleIndicator('pandas','vwap')" checked>
                                VWAP
                            </div>
                            <div class="indicator-color-line" style="border-top: 3.5px solid rgba(75, 192, 192, 0.7);"></div>
                        </label>
                    </div>
                    <div class="indicator-controls-box" style="margin-top: 8px;">
                        <label class="indicator-label">
                            <div class="indicator-label-row">
                                <input type="checkbox" id="toggle-candle-bias" onchange="toggleCandleBias()">
                                Candlestick Bias Overlay
                            </div>
                        </label>
                        <div style="margin-top: 8px; display: none;" id="candle-pattern-selector">
                            <label style="font-size: 0.8em; color: #333; margin-bottom: 4px; display: block;">Filter Pattern:</label>
                            <select id="candle-pattern-filter" onchange="filterCandlePattern()" style="width: 100%; padding: 4px; font-size: 0.85em; border: 1px solid #ccc; border-radius: 4px; background: white;">
                                <option value="all">All Patterns</option>
                                <optgroup label="Single Candle">
                                    <option value="doji_like">Doji</option>
                                    <option value="hammer_like">Hammer</option>
                                    <option value="shooting_star_like">Shooting Star</option>
                                    <option value="hanging_man_like">Hanging Man</option>
                                    <option value="strong_bullish_body">Strong Bullish Body</option>
                                    <option value="strong_bearish_body">Strong Bearish Body</option>
                                    <option value="weak_bullish">Weak Bullish</option>
                                    <option value="weak_bearish">Weak Bearish</option>
                                    <option value="neutral">Neutral</option>
                                </optgroup>
                                <optgroup label="Two Candle (Pair)">
                                    <option value="bullish_engulfing">Bullish Engulfing</option>
                                    <option value="bearish_engulfing">Bearish Engulfing</option>
                                    <option value="tweezers_top">Tweezers Top</option>
                                    <option value="tweezers_bottom">Tweezers Bottom</option>
                                </optgroup>
                                <optgroup label="Three Candle (Trio)">
                                    <option value="morning_star">Morning Star</option>
                                    <option value="evening_star">Evening Star</option>
                                    <option value="three_white_soldiers">Three White Soldiers</option>
                                    <option value="three_black_crows">Three Black Crows</option>
                                </optgroup>
                                <optgroup label="Fair Value Gap">
                                    <option value="bullish_fair_value_gap">Bullish Fair Value Gap</option>
                                    <option value="bearish_fair_value_gap">Bearish Fair Value Gap</option>
                                </optgroup>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="strategy-controls" id="strategyControls" style="display: none;">
                    <div class="strategy-row">
                        <span class="indicator-title">Strategy</span>
                        <select id="strategySelect" class="strategy-select">
                            <option value="none">None</option>
                            <option value="vwap_ema_crossover_v1">VWAP / EMA Crossover (v1)</option>
                            <option value="fools_paradise">Fools Paradise</option>
                        </select>
                        <select id="backtestConfigSelect" class="strategy-select" title="Backtest Configuration">
                            <option value="">Default (risk 0.5%, RR 2.0, fee 0)</option>
                        </select>
                        <button id="runBacktestBtn" class="strategy-button">Run Backtest</button>
                    </div>
                    <div class="strategy-card" id="strategyParams" style="display: none;"></div>
                    <div class="strategy-card" id="strategyResults" style="display: none;"></div>
                </div>
                <div class="market-hours-legend" id="marketHoursLegend" style="display: none;">
                    <div class="legend-item">
                        <div class="legend-color regular"></div>
                        <span><strong>Regular:</strong> 9:30 AM - 4:00 PM</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color pre-market"></div>
                        <span><strong>Pre-Market:</strong> 4:00 AM - 9:30 AM</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color after-hours"></div>
                        <span><strong>After-Hours:</strong> 4:00 PM - 8:00 PM</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color closed"></div>
                        <span><strong>Closed:</strong> 8:00 PM - 4:00 AM</span>
                    </div>
                </div>
            </div>
            <div class="macd-chart-container" id="macdContainer" style="display: none;">
                <canvas id="macdChart"></canvas>
            </div>
            <div class="chart-controls" id="chartControls" style="display: none;">
                <p>Click and drag to pan horizontally • Scroll to zoom • Shift+Drag to zoom area • Double-click to reset</p>
            </div>
        </div>
    </div>
    
    <script>
        // --- Candlestick theme ---
        const CANDLE_UP_FILL   = 'rgba(38, 166, 154, 1)';  // solid teal
        const CANDLE_DOWN_FILL = 'rgba(239, 83, 80, 1)';   // solid red
        const CANDLE_UNCH_FILL = 'rgba(150, 150, 150, 1)'; // solid gray
        const CANDLE_TRANSPARENT = 'rgba(0, 0, 0, 0)';
        const CANDLE_WICK_ALPHA = 0.7;

        // Apply theme at the element-default level (this is what chartjs-chart-financial uses)
        if (
            typeof Chart !== 'undefined' &&
            Chart.defaults &&
            Chart.defaults.elements &&
            Chart.defaults.elements.candlestick
        ) {
            Chart.defaults.elements.candlestick.color = {
                up: CANDLE_UP_FILL,
                down: CANDLE_DOWN_FILL,
                unchanged: CANDLE_UNCH_FILL
            };

            // No visible body border
            Chart.defaults.elements.candlestick.borderColor = {
                up: CANDLE_TRANSPARENT,
                down: CANDLE_TRANSPARENT,
                unchanged: CANDLE_TRANSPARENT
            };
            Chart.defaults.elements.candlestick.borderWidth = 0;

            // Wicks
            Chart.defaults.elements.candlestick.wickColor = {
                up: `rgba(38, 166, 154, ${CANDLE_WICK_ALPHA})`,
                down: `rgba(239, 83, 80, ${CANDLE_WICK_ALPHA})`,
                unchanged: `rgba(150, 150, 150, ${CANDLE_WICK_ALPHA})`
            };
            Chart.defaults.elements.candlestick.wickWidth = 1.2;
        }

        // Register the zoom plugin if available
        if (typeof ChartZoom !== 'undefined') {
            Chart.register(ChartZoom);
        } else if (typeof zoomPlugin !== 'undefined') {
            Chart.register(zoomPlugin);
        }
        
        // Register financial chart plugin for candlestick charts
        // The chartjs-chart-financial library auto-registers when loaded via CDN
        // No manual registration needed
        
        // Get interval from template variable or URL parameter, default to 1Min
        const urlParams = new URLSearchParams(window.location.search);
        const interval = urlParams.get('interval') || '{{ interval }}' || '1Min';
        let chartType = 'candlestick'; // Only candlestick charts
        let chartData = null;
        let chartTimestamps = null;
        let initialMin = null;
        let initialMax = null;
        let macdChart = null;
        
        // Indicator visibility state
        const indicatorVisibility = {
            pandas: {
                ema9: true,
                ema21: true,
                ema50: false,
                vwap: true,
                macd: true
            }
        };
        
        // Candlestick bias overlay state
        let candleBiasEnabled = false;
        let candleBiasData = [];
        let selectedCandlePattern = 'all'; // 'all' or specific pattern name
        let patternCounts = {}; // Store pattern counts from backend
        
        // Pattern display names mapping
        const patternDisplayNames = {
            'doji_like': 'Doji',
            'hammer_like': 'Hammer',
            'shooting_star_like': 'Shooting Star',
            'hanging_man_like': 'Hanging Man',
            'strong_bullish_body': 'Strong Bullish Body',
            'strong_bearish_body': 'Strong Bearish Body',
            'weak_bullish': 'Weak Bullish',
            'weak_bearish': 'Weak Bearish',
            'neutral': 'Neutral',
            'bullish_engulfing': 'Bullish Engulfing',
            'bearish_engulfing': 'Bearish Engulfing',
            'tweezers_top': 'Tweezers Top',
            'tweezers_bottom': 'Tweezers Bottom',
            'morning_star': 'Morning Star',
            'evening_star': 'Evening Star',
            'three_white_soldiers': 'Three White Soldiers',
            'three_black_crows': 'Three Black Crows',
            'bullish_fair_value_gap': 'Bullish Fair Value Gap',
            'bearish_fair_value_gap': 'Bearish Fair Value Gap'
        };
        
        // Helper function to calculate color based on count (conditional formatting)
        // Returns RGB color string interpolated from white (0) to medium green (max)
        function getCountColor(count, maxCount) {
            if (maxCount === 0 || count === 0) {
                return 'rgb(255, 255, 255)'; // White for zero
            }
            
            // Calculate ratio (0 to 1)
            const ratio = count / maxCount;
            
            // Color range: white (255, 255, 255) to medium green (76, 175, 80)
            const whiteR = 255, whiteG = 255, whiteB = 255;
            const greenR = 76, greenG = 175, greenB = 80;
            
            // Interpolate between white and green
            const r = Math.round(whiteR + (greenR - whiteR) * ratio);
            const g = Math.round(whiteG + (greenG - whiteG) * ratio);
            const b = Math.round(whiteB + (greenB - whiteB) * ratio);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Function to update pattern dropdown with counts
        function updatePatternDropdown() {
            const select = document.getElementById('candle-pattern-filter');
            if (!select) return;
            
            // Store current selection
            const currentValue = select.value;
            
            // Find maximum count across all patterns for conditional formatting
            const allPatterns = [
                'doji_like', 'hammer_like', 'shooting_star_like', 'hanging_man_like',
                'strong_bullish_body', 'strong_bearish_body', 'weak_bullish', 'weak_bearish', 'neutral',
                'bullish_engulfing', 'bearish_engulfing', 'tweezers_top', 'tweezers_bottom',
                'morning_star', 'evening_star', 'three_white_soldiers', 'three_black_crows',
                'bullish_fair_value_gap', 'bearish_fair_value_gap'
            ];
            const maxCount = Math.max(...allPatterns.map(p => patternCounts[p] || 0), 0);
            
            // Clear existing options except "All Patterns"
            select.innerHTML = '<option value="all">All Patterns</option>';
            
            // Helper function to create option with conditional formatting
            function createOptionWithColor(pattern) {
                const option = document.createElement('option');
                option.value = pattern;
                const count = patternCounts[pattern] || 0;
                option.textContent = `${patternDisplayNames[pattern]} (${count})`;
                
                // Apply conditional formatting background color
                const bgColor = getCountColor(count, maxCount);
                option.style.backgroundColor = bgColor;
                
                return option;
            }
            
            // Add Single Candle patterns
            const singleGroup = document.createElement('optgroup');
            singleGroup.label = 'Single Candle';
            const singlePatterns = [
                'doji_like', 'hammer_like', 'shooting_star_like', 'hanging_man_like',
                'strong_bullish_body', 'strong_bearish_body', 'weak_bullish', 'weak_bearish', 'neutral'
            ];
            singlePatterns.forEach(pattern => {
                singleGroup.appendChild(createOptionWithColor(pattern));
            });
            select.appendChild(singleGroup);
            
            // Add Two Candle (Pair) patterns
            const pairGroup = document.createElement('optgroup');
            pairGroup.label = 'Two Candle (Pair)';
            const pairPatterns = [
                'bullish_engulfing', 'bearish_engulfing', 'tweezers_top', 'tweezers_bottom'
            ];
            pairPatterns.forEach(pattern => {
                pairGroup.appendChild(createOptionWithColor(pattern));
            });
            select.appendChild(pairGroup);
            
            // Add Three Candle (Trio) patterns
            const trioGroup = document.createElement('optgroup');
            trioGroup.label = 'Three Candle (Trio)';
            const trioPatterns = [
                'morning_star', 'evening_star', 'three_white_soldiers', 'three_black_crows'
            ];
            trioPatterns.forEach(pattern => {
                trioGroup.appendChild(createOptionWithColor(pattern));
            });
            select.appendChild(trioGroup);
            
            // Add Fair Value Gap patterns
            const fvgGroup = document.createElement('optgroup');
            fvgGroup.label = 'Fair Value Gap';
            const fvgPatterns = [
                'bullish_fair_value_gap', 'bearish_fair_value_gap'
            ];
            fvgPatterns.forEach(pattern => {
                fvgGroup.appendChild(createOptionWithColor(pattern));
            });
            select.appendChild(fvgGroup);
            
            // Restore previous selection if it still exists
            if (currentValue) {
                select.value = currentValue;
            }
        }

        // Strategy state
        const strategyDefinitions = {
            none: {
                label: 'None',
                params: []
            },
            'vwap_ema_crossover_v1': {
                label: 'VWAP / EMA Crossover (v1)',
                params: [
                    { label: 'Rule', value: 'Mark every VWAP and EMA21 intersection' },
                    { label: 'Session', value: 'All sessions' },
                    { label: 'Exit', value: '2:1 Profit/Loss (0.5% risk)' }
                ]
            },
            'fools_paradise': {
                label: 'Fools Paradise',
                params: [
                    { label: 'Bullish', value: 'EMAs up, price > VWAP, enter on green, exit on red' },
                    { label: 'Bearish', value: 'EMAs down, price < VWAP, enter on red, exit on green' },
                    { label: 'Exit', value: '2:1 Profit/Loss (0.5% risk)' }
                ]
            }
        };

        const strategyState = {
            selected: 'none',
            backtest: null,
            running: false
        };
        
        // Set active link
        document.getElementById('link-1min').classList.toggle('active', interval === '1Min');
        document.getElementById('link-5min').classList.toggle('active', interval === '5Min');
        
        // Function to toggle indicator visibility
        function toggleIndicator(source, indicatorName) {
            const checkbox = document.getElementById(`toggle-${source}-${indicatorName}`);
            if (!checkbox || !indicatorVisibility[source]) return;
            indicatorVisibility[source][indicatorName] = checkbox.checked;
            updateChart();
        }
        
        // Function to toggle candlestick bias overlay
        function toggleCandleBias() {
            const checkbox = document.getElementById('toggle-candle-bias');
            if (!checkbox) return;
            candleBiasEnabled = checkbox.checked;
            
            // Show/hide pattern selector
            const selector = document.getElementById('candle-pattern-selector');
            if (selector) {
                selector.style.display = candleBiasEnabled ? 'block' : 'none';
            }
            
            updateChart();
        }
        
        // Function to filter candle patterns
        function filterCandlePattern() {
            const select = document.getElementById('candle-pattern-filter');
            if (!select) return;
            selectedCandlePattern = select.value;
            updateChart();
        }

        // Strategy UI helpers
        function renderStrategyParams() {
            const paramsBox = document.getElementById('strategyParams');
            if (!paramsBox) return;
            const defn = strategyDefinitions[strategyState.selected];
            if (!defn || strategyState.selected === 'none' || !defn.params || defn.params.length === 0) {
                paramsBox.style.display = 'none';
                paramsBox.innerHTML = '';
                return;
            }

            const lines = defn.params.map(p => `
                <div class="strategy-param">
                    <span>${p.label}</span>
                    <span><strong>${p.value}</strong></span>
                </div>
            `).join('');
            paramsBox.innerHTML = `<h4>${defn.label}</h4>${lines}`;
            paramsBox.style.display = 'block';
        }

        function renderStrategyResults() {
            const resultsBox = document.getElementById('strategyResults');
            if (!resultsBox) return;
            const res = strategyState.backtest;
            if (!res) {
                resultsBox.style.display = 'none';
                resultsBox.innerHTML = '';
                return;
            }

            const metrics = res.metrics || {};
            const lines = [
                { label: 'Trades', value: metrics.n_trades ?? '—' },
                { label: 'Win rate', value: metrics.win_rate != null ? (metrics.win_rate * 100).toFixed(1) + '%' : '—' },
                { label: 'Avg ret', value: metrics.avg_ret != null ? (metrics.avg_ret * 100).toFixed(2) + '%' : '—' },
                { label: 'Median', value: metrics.median_ret != null ? (metrics.median_ret * 100).toFixed(2) + '%' : '—' }
            ].map(r => `
                <div class="strategy-result-line">
                    <span>${r.label}</span>
                    <span><strong>${r.value}</strong></span>
                </div>
            `).join('');

            resultsBox.innerHTML = `<h4>Backtest Results</h4>${lines}`;
            resultsBox.style.display = 'block';
        }

        const backtestConfigState = { configs: [], selectedId: '' };

        function updateStrategyUI() {
            const controls = document.getElementById('strategyControls');
            const select = document.getElementById('strategySelect');
            const button = document.getElementById('runBacktestBtn');
            const cfgSelect = document.getElementById('backtestConfigSelect');

            if (controls) controls.style.display = 'flex';
            if (select && select.value !== strategyState.selected) {
                select.value = strategyState.selected;
            }
            if (button) {
                button.disabled = strategyState.selected === 'none' || strategyState.running;
                button.textContent = strategyState.running ? 'Running...' : 'Run Backtest';
            }
            if (cfgSelect && backtestConfigState.selectedId && cfgSelect.value !== backtestConfigState.selectedId) {
                cfgSelect.value = backtestConfigState.selectedId;
            }
            renderStrategyParams();
            renderStrategyResults();
        }

        async function loadBacktestConfigs() {
            try {
                const resp = await fetch('/api/backtest-configs');
                const data = await resp.json();
                backtestConfigState.configs = Array.isArray(data) ? data : [];
                const select = document.getElementById('backtestConfigSelect');
                if (select) {
                    const current = select.value;
                    select.innerHTML = '<option value="">Default (risk 0.5%, RR 2.0, fee 0)</option>';
                    backtestConfigState.configs.forEach(cfg => {
                        const opt = document.createElement('option');
                        opt.value = cfg.id;
                        opt.textContent = `${cfg.name} (R:${cfg.risk_percent}% RR:${cfg.reward_multiple} Fee:${cfg.fee_bp}bp)`;
                        select.appendChild(opt);
                    });
                    // Preserve selection if possible
                    if (current && backtestConfigState.configs.find(c => String(c.id) === String(current))) {
                        select.value = current;
                        backtestConfigState.selectedId = current;
                    }
                }
            } catch (e) {
                console.warn('Failed to load backtest configs', e);
            }
        }

        function getSelectedBacktestParams() {
            const cfg = backtestConfigState.configs.find(c => String(c.id) === String(backtestConfigState.selectedId));
            if (!cfg) {
                return { fee_bp: 0.0, risk_percent: 0.5, reward_multiple: 2.0 };
            }
            return {
                fee_bp: cfg.fee_bp ?? 0.0,
                risk_percent: cfg.risk_percent ?? 0.5,
                reward_multiple: cfg.reward_multiple ?? 2.0
            };
        }

        async function runBacktest() {
            if (strategyState.selected === 'none') return;
            const button = document.getElementById('runBacktestBtn');
            strategyState.running = true;
            updateStrategyUI();
            try {
                const params = getSelectedBacktestParams();
                const resp = await fetch(`/api/strategy/${strategyState.selected}/backtest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ticker: '{{ ticker }}',
                        interval: interval,
                        fee_bp: params.fee_bp,
                        risk_percent: params.risk_percent,
                        reward_multiple: params.reward_multiple
                    })
                });
                const data = await resp.json();
                strategyState.backtest = data && !data.error ? data : null;
            } catch (err) {
                console.error('Backtest error', err);
                strategyState.backtest = null;
            } finally {
                strategyState.running = false;
                updateStrategyUI();
            }
        }

        // Wire strategy controls
        const strategySelectEl = document.getElementById('strategySelect');
        if (strategySelectEl) {
            strategySelectEl.addEventListener('change', (e) => {
                strategyState.selected = e.target.value;
                // Reset backtest results when switching strategies
                strategyState.backtest = null;
                updateStrategyUI();
                updateChart();
            });
        }
        const runBacktestBtn = document.getElementById('runBacktestBtn');
        if (runBacktestBtn) {
            runBacktestBtn.addEventListener('click', () => runBacktest());
        }

        const backtestConfigSelect = document.getElementById('backtestConfigSelect');
        if (backtestConfigSelect) {
            backtestConfigSelect.addEventListener('change', (e) => {
                backtestConfigState.selectedId = e.target.value;
            });
        }

        (function setupGlobalNav() {
            const nav = document.getElementById('globalNavSelect');
            if (!nav) return;
            const path = window.location.pathname || '/';
            if (path.startsWith('/backtest-config')) nav.value = '/backtest-config';
            else if (path.startsWith('/package-proof-of-concept')) nav.value = '/package-proof-of-concept';
            else nav.value = '/';
            nav.addEventListener('change', (e) => {
                if (e.target.value) window.location.href = e.target.value;
            });
        })();

        // Initialize strategy UI once
        updateStrategyUI();
        loadBacktestConfigs();
        
        // Function to update chart based on chart type
        function updateChart() {
            if (!chartData) return;
            
            const canvas = document.getElementById('stockChart');
            if (!canvas) return;
            
            // Destroy existing chart if it exists
            if (window.stockChart) {
                try {
                    window.stockChart.destroy();
                } catch (e) {
                    console.warn('Error destroying chart:', e);
                }
                window.stockChart = null;
            }
            if (window.macdChart) {
                try {
                    window.macdChart.destroy();
                } catch (e) {
                    console.warn('Error destroying MACD chart:', e);
                }
                window.macdChart = null;
            }
            
            const ctx = canvas.getContext('2d');
            
            // Create candlestick chart
            createCandlestickChart(ctx, chartData, chartTimestamps, interval, initialMin, initialMax);

            renderMacdSubchart();
        }
        
        
        
        // Plugin to limit volume bar heights to 125px dynamically
        const volumeHeightLimitPlugin = {
            id: 'volumeHeightLimitPlugin',
            afterLayout: (chart) => {
                // Set the max value to help Chart.js scale correctly
                if (!window.volumeData || window.volumeData.length === 0) return;
                
                const y1Axis = chart.scales.y1;
                const xAxis = chart.scales.x;
                
                if (!y1Axis || !xAxis) return;
                
                // Get the visible x-axis range (indices)
                const xMin = Math.max(0, Math.floor(xAxis.min));
                const xMax = Math.min(window.volumeData.length - 1, Math.ceil(xAxis.max));
                
                // Find the maximum volume value in the visible range
                let maxVisibleVolume = 0;
                for (let i = xMin; i <= xMax; i++) {
                    const vol = window.volumeData[i] || 0;
                    if (vol > maxVisibleVolume) {
                        maxVisibleVolume = vol;
                    }
                }
                
                if (maxVisibleVolume === 0) {
                    maxVisibleVolume = Math.max(...window.volumeData) || 1;
                }
                
                // Calculate max value to make highest bar 125px
                const chartArea = chart.chartArea;
                const volumeAxisHeight = chartArea ? (chartArea.bottom - chartArea.top) : (y1Axis.bottom - y1Axis.top);
                const maxVolumeHeight = 125;
                const calculatedMax = maxVisibleVolume * (volumeAxisHeight / maxVolumeHeight);
                
                // Set the max value
                y1Axis.options.max = calculatedMax;
                y1Axis.max = calculatedMax;
            }
        };
        
        // Plugin to ensure price axis labels are always visible
        const priceAxisVisibilityPlugin = {
            id: 'priceAxisVisibilityPlugin',
            afterLayout: (chart) => {
                const yAxis = chart.scales.y;
                if (yAxis && yAxis.position === 'right') {
                    // Force minimum width to accommodate price labels positioned outside
                    const minWidth = 90;
                    if (yAxis.width < minWidth) {
                        yAxis.width = minWidth;
                    }
                }
            },
            afterUpdate: (chart) => {
                // Re-apply after updates (like zoom/pan)
                const yAxis = chart.scales.y;
                if (yAxis && yAxis.position === 'right') {
                    const minWidth = 90;
                    if (yAxis.width < minWidth) {
                        yAxis.width = minWidth;
                    }
                }
            }
        };
        
        // Market hours shading colors
        const marketHoursColors = {
            // Keep regular-hours overlay faint so grid lines remain visible
            'regular': 'rgba(255, 255, 255, 0.05)',
            'pre_market': 'rgba(52, 152, 219, 0.1)',
            'after_hours': 'rgba(155, 89, 182, 0.1)',
            'closed': 'rgba(149, 165, 166, 0.1)'
        };
        
        // Custom plugin to draw green dots at VWAP anchor points (market opens)
        const vwapAnchorPlugin = {
            id: 'vwapAnchorPlugin',
            afterDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const marketOpens = window.marketOpens || [];
                const timestamps = window.chartTimestamps || [];
                const vwapData = window.vwapData || [];
                
                if (!marketOpens || marketOpens.length === 0 || !timestamps || timestamps.length === 0) {
                    return;
                }
                
                ctx.save();
                
                // Draw green dots at market open positions
                marketOpens.forEach(marketOpen => {
                    try {
                        const openDate = new Date(marketOpen);
                        
                        // Find the index in timestamps array
                        let openIdx = -1;
                        for (let i = 0; i < timestamps.length; i++) {
                            const ts = new Date(timestamps[i]);
                            // Find closest timestamp (within 10 minutes)
                            const timeDiff = Math.abs(ts - openDate);
                            if (timeDiff <= 10 * 60 * 1000) { // 10 minutes in milliseconds
                                openIdx = i;
                                break;
                            }
                        }
                        
                        if (openIdx === -1) {
                            // Try to find the closest index
                            let minDiff = Infinity;
                            for (let i = 0; i < timestamps.length; i++) {
                                const ts = new Date(timestamps[i]);
                                const diff = Math.abs(ts - openDate);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    openIdx = i;
                                }
                            }
                        }
                        
                        if (openIdx >= 0 && openIdx < timestamps.length) {
                            // Get the VWAP value at this point
                            let vwapValue = null;
                            if (vwapData && vwapData[openIdx] !== null && vwapData[openIdx] !== undefined) {
                                vwapValue = vwapData[openIdx];
                            } else {
                                // Try to find the first non-null VWAP value after market open
                                for (let i = openIdx; i < Math.min(openIdx + 10, vwapData.length); i++) {
                                    if (vwapData[i] !== null && vwapData[i] !== undefined) {
                                        vwapValue = vwapData[i];
                                        break;
                                    }
                                }
                            }
                            
                            if (vwapValue !== null) {
                                // Get pixel positions
                                const xPixel = xAxis.getPixelForValue(openIdx);
                                const yPixel = yAxis.getPixelForValue(vwapValue);
                                
                                // Draw text "VWAP anchor" above the arrow
                                ctx.font = '12px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'bottom';
                                
                                // Measure text for background
                                const text = 'VWAP anchor';
                                const textMetrics = ctx.measureText(text);
                                const textWidth = textMetrics.width;
                                const textHeight = 14;
                                const padding = 4;
                                
                                // Draw text background for readability
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                ctx.fillRect(
                                    xPixel - textWidth / 2 - padding,
                                    yPixel - 30 - textHeight - padding,
                                    textWidth + padding * 2,
                                    textHeight + padding * 2
                                );
                                
                                // Draw text
                                ctx.fillStyle = '#2ecc71'; // Green color
                                ctx.fillText(text, xPixel, yPixel - 30);
                                
                                // Draw downward-pointing arrow
                                const arrowSize = 10;
                                const arrowY = yPixel - 15; // Position arrow below text
                                
                                ctx.fillStyle = '#2ecc71'; // Green color
                                ctx.beginPath();
                                ctx.moveTo(xPixel, arrowY + arrowSize); // Bottom point (tip)
                                ctx.lineTo(xPixel - arrowSize / 2, arrowY); // Top left
                                ctx.lineTo(xPixel + arrowSize / 2, arrowY); // Top right
                                ctx.closePath();
                                ctx.fill();
                                
                                // Add white border to arrow for visibility
                                ctx.strokeStyle = '#ffffff';
                                ctx.lineWidth = 1.5;
                                ctx.stroke();
                            }
                        }
                    } catch (e) {
                        console.warn('Error drawing VWAP anchor:', e);
                    }
                });
                
                ctx.restore();
            }
        };
        
        // Custom plugin to draw candlestick bias markers
        const candlestickBiasPlugin = {
            id: 'candlestickBiasPlugin',
            afterDatasetsDraw: (chart) => {
                if (!candleBiasEnabled || !candleBiasData || candleBiasData.length === 0) {
                    return;
                }
                
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const ohlcData = window.chartData ? window.chartData.ohlc : [];
                
                if (!ohlcData || ohlcData.length === 0) {
                    return;
                }
                
                ctx.save();
                
                // Clip to chart area
                const chartArea = chart.chartArea;
                if (chartArea) {
                    ctx.beginPath();
                    ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                    ctx.clip();
                }
                
                // Draw bias markers for each candle
                candleBiasData.forEach((bias, idx) => {
                    if (!bias || idx >= ohlcData.length) return;
                    
                    // Filter by selected pattern
                    if (selectedCandlePattern !== 'all' && bias.pattern !== selectedCandlePattern) {
                        return;
                    }
                    
                    const candle = ohlcData[idx];
                    if (!candle || candle.high === null || candle.low === null) return;
                    
                    // Get pixel positions
                    const xPixel = xAxis.getPixelForValue(idx);
                    const high = candle.high;
                    const low = candle.low;
                    const range = high - low;
                    
                    // Determine marker color based on bias
                    let markerColor = '#999'; // Default gray for neutral
                    if (bias.bias === 'bullish') {
                        markerColor = '#2ecc71'; // Green
                    } else if (bias.bias === 'bearish') {
                        markerColor = '#e74c3c'; // Red
                    }
                    
                    // Position marker above candle for bullish, below for bearish, at middle for neutral
                    let yPixel;
                    if (bias.bias === 'bullish') {
                        yPixel = yAxis.getPixelForValue(high + range * 0.15);
                    } else if (bias.bias === 'bearish') {
                        yPixel = yAxis.getPixelForValue(low - range * 0.15);
                    } else {
                        yPixel = yAxis.getPixelForValue((high + low) / 2);
                    }
                    
                    // Only draw if within visible chart area
                    if (xPixel >= chartArea.left && xPixel <= chartArea.right &&
                        yPixel >= chartArea.top && yPixel <= chartArea.bottom) {
                        // Draw colored dot
                        ctx.fillStyle = markerColor;
                        ctx.beginPath();
                        ctx.arc(xPixel, yPixel, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Add white border for visibility
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                });
                
                ctx.restore();
            }
        };
        
        // Custom plugin to draw market hours vertical shading
        const marketHoursPlugin = {
            id: 'marketHoursPlugin',
            beforeDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const marketHours = window.marketHours || [];
                const timestamps = window.chartTimestamps || [];
                
                if (!marketHours || marketHours.length === 0 || !timestamps || timestamps.length === 0) {
                    return;
                }
                
                ctx.save();
                
                // Clip drawing to chart area only
                const chartArea = chart.chartArea;
                if (chartArea) {
                    ctx.beginPath();
                    ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                    ctx.clip();
                }
                
                // Draw vertical shaded regions for each market hours period
                marketHours.forEach(period => {
                    try {
                        const startDate = new Date(period.start);
                        const endDate = new Date(period.end);
                        
                        // Find indices in timestamps array that fall within this period
                        let startIdx = -1;
                        let endIdx = -1;
                        
                        for (let i = 0; i < timestamps.length; i++) {
                            const ts = new Date(timestamps[i]);
                            if (ts >= startDate && startIdx === -1) {
                                startIdx = i;
                            }
                            if (ts <= endDate) {
                                endIdx = i;
                            }
                        }
                        
                        // If we couldn't find exact matches, try to find closest
                        if (startIdx === -1) {
                            // Find first timestamp after start
                            for (let i = 0; i < timestamps.length; i++) {
                                if (new Date(timestamps[i]) >= startDate) {
                                    startIdx = Math.max(0, i - 1);
                                    break;
                                }
                            }
                        }
                        
                        if (endIdx === -1) {
                            // Find last timestamp before end
                            for (let i = timestamps.length - 1; i >= 0; i--) {
                                if (new Date(timestamps[i]) <= endDate) {
                                    endIdx = Math.min(timestamps.length - 1, i + 1);
                                    break;
                                }
                            }
                        }
                        
                        if (startIdx === -1 || endIdx === -1 || startIdx > endIdx) {
                            return;
                        }
                        
                        // Get pixel positions
                        const startPixel = xAxis.getPixelForValue(startIdx);
                        const endPixel = xAxis.getPixelForValue(endIdx);
                        
                        // Clamp pixel positions to chart area boundaries
                        const clampedStart = Math.max(startPixel, chartArea.left);
                        const clampedEnd = Math.min(endPixel, chartArea.right);
                        
                        // Only draw if there's a valid width and it's within the visible area
                        if (clampedEnd <= clampedStart || clampedStart >= chartArea.right || clampedEnd <= chartArea.left) {
                            return;
                        }
                        
                        const color = marketHoursColors[period.type] || marketHoursColors['closed'];
                        ctx.fillStyle = color;
                        // Draw within the chart area, strictly bounded by chartArea
                        ctx.fillRect(
                            clampedStart,
                            chartArea.top,
                            clampedEnd - clampedStart,
                            chartArea.bottom - chartArea.top
                        );
                    } catch (e) {
                        console.warn('Error drawing market hours period:', e);
                    }
                });
                
                ctx.restore();
            }
        };
        
        // Custom plugin to draw date labels below time labels
        const dateLabelPlugin = {
            id: 'dateLabelPlugin',
            afterDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const timestamps = window.chartTimestamps;
                
                if (!timestamps || timestamps.length === 0) return;
                
                ctx.save();
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                let lastDateDrawn = null;
                const tickSpacing = 1;
                const xAxisLeft = xAxis.left;
                const xAxisRight = xAxis.right;
                
                for (let i = 0; i < timestamps.length; i += tickSpacing) {
                    const tickDate = timestamps[i];
                    if (!tickDate) continue;
                    
                    try {
                        const pixel = xAxis.getPixelForValue(i);
                        if (pixel < xAxisLeft || pixel > xAxisRight) {
                            continue;
                        }
                        
                        const weekday = tickDate.toLocaleDateString('en-US', { weekday: 'long' });
                        const date = tickDate.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric' });
                        const currentDateStr = `${weekday}, ${date}`;
                        
                        if (currentDateStr !== lastDateDrawn) {
                            const dateY = yAxis.bottom + 25;
                            ctx.fillText(currentDateStr, pixel, dateY);
                            lastDateDrawn = currentDateStr;
                        }
                    } catch (e) {
                        continue;
                    }
                }
                
                ctx.restore();
            }
        };
        
        // Crosshair plugin - stores mouse position
        let crosshairPosition = { x: null, y: null };
        
        // Custom plugin to draw crosshair lines
        const crosshairPlugin = {
            id: 'crosshairPlugin',
            afterDraw: (chart) => {
                if (crosshairPosition.x === null || crosshairPosition.y === null) {
                    return;
                }
                
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                const y1Axis = chart.scales.y1;
                const timestamps = window.chartTimestamps;
                
                if (!chartArea || !xAxis || !yAxis) return;
                
                ctx.save();
                
                // Get mouse position relative to canvas
                const rect = chart.canvas.getBoundingClientRect();
                const mouseX = crosshairPosition.x - rect.left;
                const mouseY = crosshairPosition.y - rect.top;
                const dataIndex = Math.round(xAxis.getValueForPixel(mouseX));
                
                // Check if mouse is within chart area
                if (mouseX < chartArea.left || mouseX > chartArea.right || 
                    mouseY < chartArea.top || mouseY > chartArea.bottom) {
                    ctx.restore();
                    return;
                }
                
                // Draw horizontal line (light thin line)
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)'; // light gray @ 80% opacity
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(chartArea.left, mouseY);
                ctx.lineTo(chartArea.right, mouseY);
                ctx.stroke();
                
                // Draw vertical line (light thin line)
                ctx.beginPath();
                ctx.moveTo(mouseX, chartArea.top);
                ctx.lineTo(mouseX, chartArea.bottom);
                ctx.stroke();
                
                // Highlight price on right side of chart (using right Y-axis for price)
                let priceValue = null;
                if (dataIndex >= 0 && window.chartData && window.chartData.ohlc && window.chartData.ohlc[dataIndex]) {
                    const candle = window.chartData.ohlc[dataIndex];
                    priceValue = candle.close ?? candle.c ?? candle.price ?? candle.o ?? candle.h ?? candle.l ?? null;
                }
                
                if (priceValue === null || priceValue === undefined || isNaN(priceValue)) {
                    priceValue = yAxis.getValueForPixel(mouseY);
                }
                
                if (priceValue !== null && !isNaN(priceValue)) {
                    // Draw background for price label on the right side
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 1;
                    
                    const priceText = '$' + priceValue.toFixed(2);
                    
                    ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    
                    const textWidth = ctx.measureText(priceText).width;
                    const padding = 6;
                    // Position label inside the chart area near the right edge to avoid clipping
                    const labelWidth = textWidth + padding * 2;
                    const labelX = chartArea.right - labelWidth - 8;
                    const labelY = yAxis.getPixelForValue(priceValue);
                    
                    // Draw rounded rectangle background
                    const rectX = labelX;
                    const rectY = labelY - 12;
                    const rectWidth = textWidth + padding * 2;
                    const rectHeight = 24;
                    
                    ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
                    ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                    
                    // Draw price text
                    ctx.fillStyle = '#333';
                    ctx.fillText(priceText, labelX + padding, labelY);
                }
                
                // Highlight time on X-axis
                if (timestamps && timestamps.length > 0) {
                    if (dataIndex >= 0 && dataIndex < timestamps.length) {
                        const timestamp = timestamps[dataIndex];
                        if (timestamp) {
                            const timeText = timestamp.toLocaleTimeString('en-US', {
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: true
                            });
                            const dateText = timestamp.toLocaleDateString('en-US', {
                                weekday: 'long',
                                month: 'numeric',
                                day: 'numeric'
                            });
                            const timeLabel = `${timeText} (${dateText})`;
                            
                            // Draw background for time label
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                            ctx.lineWidth = 1;
                            
                            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            const textWidth = ctx.measureText(timeLabel).width;
                            const padding = 6;
                            const labelX = mouseX;
                            const labelY = chartArea.bottom + 15;
                            
                            // Draw rounded rectangle background
                            const rectX = labelX - textWidth / 2 - padding;
                            const rectY = labelY - 12;
                            const rectWidth = textWidth + padding * 2;
                            const rectHeight = 24;
                            
                            ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
                            ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                            
                            // Draw time text
                            ctx.fillStyle = '#333';
                            ctx.fillText(timeLabel, labelX, labelY);
                        }
                    }
                }
                
                // Show candlestick bias tooltip if enabled and data exists
                if (candleBiasEnabled && candleBiasData && candleBiasData.length > 0 && 
                    dataIndex >= 0 && dataIndex < candleBiasData.length) {
                    const bias = candleBiasData[dataIndex];
                    // Only show tooltip if pattern matches filter (or filter is 'all')
                    if (bias && bias.pattern && 
                        (selectedCandlePattern === 'all' || bias.pattern === selectedCandlePattern)) {
                        // Format pattern name (replace underscores with spaces, capitalize)
                        const patternName = bias.pattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        const biasText = bias.bias ? bias.bias.charAt(0).toUpperCase() + bias.bias.slice(1) : 'Neutral';
                        const tooltipText = `${patternName} (${biasText})`;
                        
                        // Draw background for tooltip
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        
                        ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        
                        // Calculate text dimensions
                        const padding = 8;
                        const lineHeight = 16;
                        const lines = [tooltipText];
                        if (bias.explanation) {
                            lines.push(bias.explanation);
                        }
                        
                        let maxWidth = 0;
                        lines.forEach(line => {
                            const width = ctx.measureText(line).width;
                            if (width > maxWidth) maxWidth = width;
                        });
                        
                        const tooltipX = mouseX + 15;
                        const tooltipY = mouseY - 10;
                        const tooltipWidth = maxWidth + padding * 2;
                        const tooltipHeight = lines.length * lineHeight + padding * 2;
                        
                        // Draw rounded rectangle background
                        ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                        ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                        
                        // Draw text
                        ctx.fillStyle = '#fff';
                        lines.forEach((line, idx) => {
                            ctx.fillText(line, tooltipX + padding, tooltipY + padding + idx * lineHeight);
                        });
                    }
                }
                
                ctx.restore();
            }
        };
        
        // Custom plugin to manually draw candlesticks with full styling control
        const customCandlestickPlugin = {
            id: 'customCandlestickPlugin',
            beforeDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;
                
                if (!chartArea || !xAxis || !yAxis) return;
                
                // Find the candlestick dataset (look for one with candlestickData property)
                const candlestickDataset = chart.data.datasets.find(ds => 
                    ds.candlestickData && ds.candlestickData.length > 0
                );
                
                if (!candlestickDataset || !candlestickDataset.candlestickData) return;
                
                const data = candlestickDataset.candlestickData;
                
                ctx.save();
                
                // Clip to chart area
                ctx.beginPath();
                ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                ctx.clip();
                
                const visibleRange = {
                    min: Math.max(0, Math.floor(xAxis.min)),
                    max: Math.min(data.length - 1, Math.ceil(xAxis.max))
                };
                
                // Calculate candle width (leave some gap between candles)
                const candleSpacing = (xAxis.right - xAxis.left) / (visibleRange.max - visibleRange.min + 1);
                const candleWidth = Math.max(2, candleSpacing * 0.7); // 70% of spacing, min 2px
                
                // Draw each visible candle
                for (let i = visibleRange.min; i <= visibleRange.max; i++) {
                    const candle = data[i];
                    if (!candle || candle.o === undefined || candle.h === undefined || 
                        candle.l === undefined || candle.c === undefined) continue;
                    
                    const x = xAxis.getPixelForValue(i);
                    const openY = yAxis.getPixelForValue(candle.o);
                    const highY = yAxis.getPixelForValue(candle.h);
                    const lowY = yAxis.getPixelForValue(candle.l);
                    const closeY = yAxis.getPixelForValue(candle.c);
                    
                    // Determine if up or down
                    const isUp = candle.c >= candle.o;
                    const bodyTop = Math.min(openY, closeY);
                    const bodyBottom = Math.max(openY, closeY);
                    const bodyHeight = Math.max(1, bodyBottom - bodyTop); // Min 1px for visibility
                    
                    // Choose colors based on theme constants
                    const bodyColor = isUp ? CANDLE_UP_FILL : CANDLE_DOWN_FILL;
                    const wickColor = isUp 
                        ? `rgba(38, 166, 154, ${CANDLE_WICK_ALPHA})` 
                        : `rgba(239, 83, 80, ${CANDLE_WICK_ALPHA})`;
                    
                    // Draw wick (vertical line from high to low)
                    ctx.strokeStyle = wickColor;
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.stroke();
                    
                    // Draw body (rectangle from open to close)
                    // No border - just fill
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(
                        x - candleWidth / 2,
                        bodyTop,
                        candleWidth,
                        bodyHeight
                    );
                }
                
                ctx.restore();
            }
        };
        
        // Plugin to draw border around chart area
        const chartBorderPlugin = {
            id: 'chartBorderPlugin',
            afterDraw: (chart) => {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                
                if (!chartArea) return;
                
                ctx.save();
                
                // Draw border rectangle around chart area
                ctx.strokeStyle = '#cccccc'; // Light gray border
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                
                // Draw rectangle border
                ctx.strokeRect(
                    chartArea.left,
                    chartArea.top,
                    chartArea.right - chartArea.left,
                    chartArea.bottom - chartArea.top
                );
                
                ctx.restore();
            }
        };
        
        // Function to create candlestick chart
        function createCandlestickChart(ctx, data, timestamps, interval, initialMin, initialMax) {
            const labels = timestamps.map(date => date.toLocaleString());
            
            // Format data for candlestick chart (using OHLC format for custom plugin)
            const candlestickData = data.ohlc.map((ohlc, index) => ({
                x: index,
                o: ohlc.open,
                h: ohlc.high,
                l: ohlc.low,
                c: ohlc.close
            }));

            // Build datasets array - use a hidden line dataset for axis scaling
            // The custom plugin will draw the actual candlesticks
            const datasets = [{
                label: '{{ ticker }}',
                data: candlestickData.map(c => ({ x: c.x, y: c.c })), // Use close for line positioning
                candlestickData: candlestickData, // Store OHLC data for custom plugin
                borderColor: 'transparent',
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 0,
                order: 0 // Draw behind everything
            }];
            
            // Add volume bars dataset
            if (data.ohlc && data.ohlc.length > 0) {
                const volumeData = data.ohlc.map((ohlc, index) => {
                    // Determine color based on price movement (green if close > open, red if close < open)
                    const isUp = ohlc.close >= ohlc.open;
                    return {
                        x: index,
                        y: ohlc.volume || 0
                    };
                });
                
                // Create color array for volume bars
                const volumeColors = data.ohlc.map(ohlc => {
                    const isUp = ohlc.close >= ohlc.open;
                    return isUp ? 'rgba(38, 166, 154, 0.7)' : 'rgba(239, 83, 80, 0.7)'; // Green or red with transparency
                });
                
                datasets.push({
                    label: 'Volume',
                    type: 'bar',
                    data: volumeData,
                    backgroundColor: volumeColors,
                    borderColor: volumeColors,
                    borderWidth: 0,
                    yAxisID: 'y1', // Use second y-axis for volume
                    order: 1, // Draw volume bars behind other elements
                    barThickness: 'flex',
                    maxBarThickness: 50
                });
            }
            
            // Add indicator datasets if visible (as line overlays)
            if (data.indicators_ta) {
                const pandasIndicators = data.indicators_ta;
                if (indicatorVisibility.pandas.ema9 && pandasIndicators.ema_9) {
                    datasets.push({
                        label: 'EMA 9 (pandas_ta)',
                        type: 'line',
                        data: pandasIndicators.ema_9.map((val, idx) => ({x: idx, y: val})),
                        borderColor: 'rgba(255, 99, 132, 0.7)',
                        backgroundColor: 'transparent',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        tension: 0.4
                    });
                }
                if (indicatorVisibility.pandas.ema21 && pandasIndicators.ema_21) {
                    datasets.push({
                        label: 'EMA 21 (pandas_ta)',
                        type: 'line',
                        data: pandasIndicators.ema_21.map((val, idx) => ({x: idx, y: val})),
                        borderColor: 'rgba(54, 162, 235, 0.7)',
                        backgroundColor: 'transparent',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        tension: 0.4
                    });
                }
                if (indicatorVisibility.pandas.ema50 && pandasIndicators.ema_50) {
                    datasets.push({
                        label: 'EMA 50 (pandas_ta)',
                        type: 'line',
                        data: pandasIndicators.ema_50.map((val, idx) => ({x: idx, y: val})),
                        borderColor: 'rgba(255, 206, 86, 0.7)',
                        backgroundColor: 'transparent',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        tension: 0.4
                    });
                }
                if (indicatorVisibility.pandas.vwap && pandasIndicators.vwap) {
                    datasets.push({
                        label: 'VWAP (pandas_ta)',
                        type: 'line',
                        data: pandasIndicators.vwap.map((val, idx) => ({x: idx, y: val})),
                        borderColor: 'rgba(75, 192, 192, 0.7)',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4
                    });
                }
            }

            // Strategy markers
            const addStrategyMarkers = (strat, label, baseColor, style = 'triangle') => {
                const longEntries = strat.long_entry || [];
                const markers = [];
                const meta = [];
                const colors = [];
                const borders = [];
                const yOverrides = strat.cross_y || [];
                const directions = strat.direction || [];
                longEntries.forEach((flag, idx) => {
                    if (!flag) return;
                    const candle = data.ohlc[idx];
                    if (!candle) return;
                    const lows = [candle.low, candle.close, candle.open].filter(v => typeof v === 'number');
                    const highs = [candle.high, candle.close, candle.open].filter(v => typeof v === 'number');
                    if (lows.length === 0) return;
                    const low = Math.min(...lows);
                    const high = highs.length ? Math.max(...highs) : low;
                    const range = Math.max(high - low, Math.abs(low) * 0.0005, 0.01);
                    const yFromPayload = yOverrides[idx];
                    // Position entry markers just below the candle with minimal spacing
                    const markerY = (yFromPayload != null && !isNaN(yFromPayload)) ? (yFromPayload - range * 0.3) : (low - range * 0.3);
                    markers.push({ x: idx, y: markerY });
                    const dir = directions[idx];
                    const color = dir === 'bullish' ? '#2ecc71' : dir === 'bearish' ? '#e74c3c' : baseColor;
                    colors.push(color);
                    borders.push('#1b1b1b');
                    meta.push({
                        candleIndex: idx,
                        entry_price: strat.entry_price ? strat.entry_price[idx] : null,
                        ema9: strat.ema9 ? strat.ema9[idx] : null,
                        ema21: strat.ema21 ? strat.ema21[idx] : null,
                        vwap: strat.vwap ? strat.vwap[idx] : null,
                        time: data.labels ? data.labels[idx] : null,
                        close: candle.close,
                        low: candle.low,
                        direction: dir
                    });
                });

                if (markers.length > 0) {
                    datasets.push({
                        label,
                        type: 'scatter',
                        data: markers,
                        yAxisID: 'y',
                        pointStyle: style,
                        pointRadius: 8,
                        pointBackgroundColor: colors.length ? colors : baseColor,
                        pointBorderColor: borders.length ? borders : '#1b7f46',
                        pointBorderWidth: 1.5,
                        pointRotation: 0,
                        showLine: false,
                        strategyMarker: true,
                        strategyMeta: meta,
                        order: 10000, // draw on top
                        clip: false   // avoid clipping so markers sit above lines
                    });
                }
            };

            // Function to add exit markers for strategies
            const addStrategyExitMarkers = (strat, label, baseColor, style = 'triangle') => {
                const longExits = strat.long_exit || [];
                if (!longExits || longExits.length === 0) return;
                
                // Group markers by color/rotation for efficiency
                const redMarkers = []; // Red triangles (exiting long positions)
                const greenMarkers = []; // Green triangles (exiting short positions)
                const redMeta = [];
                const greenMeta = [];
                const yOverrides = strat.exit_y || [];
                const exitDirections = strat.exit_direction || [];
                
                longExits.forEach((flag, idx) => {
                    if (!flag) return;
                    const candle = data.ohlc[idx];
                    if (!candle) return;
                    const lows = [candle.low, candle.close, candle.open].filter(v => typeof v === 'number');
                    const highs = [candle.high, candle.close, candle.open].filter(v => typeof v === 'number');
                    if (lows.length === 0) return;
                    const low = Math.min(...lows);
                    const high = highs.length ? Math.max(...highs) : low;
                    const range = Math.max(high - low, Math.abs(low) * 0.0005, 0.01);
                    const yFromPayload = yOverrides[idx];
                    // Position exit markers just above the candle with minimal spacing
                    const markerY = (yFromPayload != null && !isNaN(yFromPayload)) ? (yFromPayload + range * 0.3) : (high + range * 0.3);
                    
                    const dir = exitDirections[idx];
                    const marker = { x: idx, y: markerY };
                    const metaItem = {
                        candleIndex: idx,
                        exit_price: strat.exit_price ? strat.exit_price[idx] : null,
                        time: data.labels ? data.labels[idx] : null,
                        close: candle.close,
                        high: candle.high,
                        direction: dir
                    };
                    
                    // Red triangle pointing down for exiting long (bullish) positions
                    if (dir === 'bullish') {
                        redMarkers.push(marker);
                        redMeta.push(metaItem);
                    }
                    // Green triangle pointing down for exiting short (bearish) positions
                    else if (dir === 'bearish') {
                        greenMarkers.push(marker);
                        greenMeta.push(metaItem);
                    }
                });

                // Add red exit markers (exiting long positions)
                if (redMarkers.length > 0) {
                    datasets.push({
                        label: label + ' (Exit Long)',
                        type: 'scatter',
                        data: redMarkers,
                        yAxisID: 'y',
                        pointStyle: 'triangle',
                        pointRadius: 8,
                        pointBackgroundColor: '#e74c3c', // Red
                        pointBorderColor: '#1b1b1b',
                        pointBorderWidth: 1.5,
                        pointRotation: 180, // Point down
                        showLine: false,
                        strategyMarker: true,
                        strategyMeta: redMeta,
                        order: 10001, // draw on top of entry markers
                        clip: false
                    });
                }
                
                // Add green exit markers (exiting short positions)
                if (greenMarkers.length > 0) {
                    datasets.push({
                        label: label + ' (Exit Short)',
                        type: 'scatter',
                        data: greenMarkers,
                        yAxisID: 'y',
                        pointStyle: 'triangle',
                        pointRadius: 8,
                        pointBackgroundColor: '#2ecc71', // Green
                        pointBorderColor: '#1b1b1b',
                        pointBorderWidth: 1.5,
                        pointRotation: 180, // Point down
                        showLine: false,
                        strategyMarker: true,
                        strategyMeta: greenMeta,
                        order: 10001, // draw on top of entry markers
                        clip: false
                    });
                }
            };

            if (data.strategies) {
                if (strategyState.selected === 'vwap_ema_crossover_v1' && data.strategies.vwap_ema_crossover_v1) {
                    addStrategyMarkers(data.strategies.vwap_ema_crossover_v1, 'Cross (VWAP / EMA21)', '#9b59b6', 'circle');
                }
                if (strategyState.selected === 'fools_paradise' && data.strategies.fools_paradise) {
                    // Add entry markers (triangles pointing up)
                    addStrategyMarkers(data.strategies.fools_paradise, 'Fools Paradise Entry', '#e67e22', 'triangle');
                    // Add exit markers (triangles pointing down)
                    addStrategyExitMarkers(data.strategies.fools_paradise, 'Fools Paradise Exit', '#e67e22', 'triangle');
                }
            }
            
            // Get volume data for max calculation
            const volumeData = data.ohlc ? data.ohlc.map(ohlc => ohlc.volume || 0) : [];
            const options = getChartOptions(interval, initialMin, initialMax, timestamps, volumeData);
            
            // Disable all tooltips to avoid confusing "Long entry" popups
            options.plugins.tooltip = options.plugins.tooltip || {};
            options.plugins.tooltip.enabled = false;
            
            window.stockChart = new Chart(ctx, {
                plugins: [customCandlestickPlugin, marketHoursPlugin, vwapAnchorPlugin, candlestickBiasPlugin, volumeHeightLimitPlugin, priceAxisVisibilityPlugin, dateLabelPlugin, crosshairPlugin, chartBorderPlugin],
                type: 'line', // Use line chart for axis scaling, custom plugin draws candlesticks
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: options
            });
            
            // Set up mouse event handlers for crosshair (only once)
            if (!window.crosshairHandlersSetup) {
                const canvas = document.getElementById('stockChart');
                canvas.addEventListener('mousemove', (e) => {
                    crosshairPosition.x = e.clientX;
                    crosshairPosition.y = e.clientY;
                    if (window.stockChart) {
                        window.stockChart.update('none'); // Update without animation
                    }
                });
                
                canvas.addEventListener('mouseleave', () => {
                    crosshairPosition.x = null;
                    crosshairPosition.y = null;
                    if (window.stockChart) {
                        window.stockChart.update('none');
                    }
                });
                
                window.crosshairHandlersSetup = true;
            }
        }

        // Function to create MACD sub-chart
        function createMacdChart(ctx, data, timestamps, interval) {
            const labels = timestamps.map(date => date.toLocaleString());
            const datasets = [];

            const macdData = data.indicators_ta && data.indicators_ta.macd ? data.indicators_ta.macd.map((val, idx) => ({x: idx, y: val})) : [];
            const macdSignalData = data.indicators_ta && data.indicators_ta.macd_signal ? data.indicators_ta.macd_signal.map((val, idx) => ({x: idx, y: val})) : [];

            if (macdData.length > 0 || macdSignalData.length > 0) {
                if (macdData.length > 0) {
                    datasets.push({
                        label: 'MACD (pandas_ta)',
                        type: 'line',
                        data: macdData,
                        borderColor: 'rgba(0, 0, 255, 0.7)',
                        backgroundColor: 'transparent',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        tension: 0.2
                    });
                }
                if (macdSignalData.length > 0) {
                    datasets.push({
                        label: 'MACD Signal (pandas_ta)',
                        type: 'line',
                        data: macdSignalData,
                        borderColor: 'rgba(255, 0, 0, 0.7)',
                        backgroundColor: 'transparent',
                        borderWidth: 1.2,
                        pointRadius: 0,
                        tension: 0.2
                    });
                }
            }

            // Zero reference line
            const zeroLine = timestamps.map((_, idx) => ({x: idx, y: 0}));
            datasets.push({
                label: 'Zero',
                type: 'line',
                data: zeroLine,
                borderColor: 'rgba(120,120,120,0.4)',
                backgroundColor: 'transparent',
                borderWidth: 1,
                pointRadius: 0,
                tension: 0
            });

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    y: {
                        position: 'left',
                        title: {
                            display: true,
                            text: 'MACD'
                        },
                        ticks: {
                            maxTicksLimit: 5
                        },
                        grid: {
                            drawOnChartArea: true,
                            color: 'rgba(200,200,200,0.1)'
                        }
                    },
                    x: {
                        display: false
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                }
            };

            if (window.macdChart) {
                try { window.macdChart.destroy(); } catch (e) {}
            }
            window.macdChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: options
            });
        }

        function renderMacdSubchart() {
            const macdContainer = document.getElementById('macdContainer');
            const macdCanvas = document.getElementById('macdChart');
            const hasMacdData = chartData && chartData.indicators_ta && (chartData.indicators_ta.macd || chartData.indicators_ta.macd_signal);
            if (macdContainer && macdCanvas && hasMacdData) {
                macdContainer.style.display = 'block';
                const macdCtx = macdCanvas.getContext('2d');
                createMacdChart(macdCtx, chartData, chartTimestamps, interval);
            } else if (macdContainer) {
                macdContainer.style.display = 'none';
            }
        }
        
        // Function to get chart options
        function getChartOptions(interval, initialMin, initialMax, timestamps, volumeData) {
            // Calculate available width for chart - use wrapper width directly
            const wrapper = document.querySelector('.chart-wrapper');
            const chartContainer = document.querySelector('.chart-container');
            let chartWidth = 1400; // Default
            if (wrapper) {
                chartWidth = wrapper.offsetWidth || wrapper.clientWidth || wrapper.getBoundingClientRect().width;
            } else if (chartContainer) {
                const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth;
                chartWidth = containerWidth - 85;
            }
            chartWidth = Math.max(chartWidth, 1000);
            
            return {
                responsive: true,
                maintainAspectRatio: false, // Allow chart to adjust for axis width
                animation: false,
                aspectRatio: undefined, // Disable aspect ratio to allow full width
                devicePixelRatio: window.devicePixelRatio || 1, // Handle high DPI displays
                layout: {
                    padding: {
                        left: 0,
                        right: 0, 
                        top: 0,
                        bottom: 0
                    }
                },
                resizeDelay: 0, // Update immediately on resize
                // Explicitly set canvas size
                onResize: (chart, size) => {
                    // Force chart to use full available width
                    const canvas = chart.canvas;
                    const wrapper = canvas ? canvas.closest('.chart-wrapper') : null;
                    if (wrapper && canvas) {
                        wrapper.offsetHeight; // Force reflow
                        const availableWidth = wrapper.offsetWidth || wrapper.clientWidth || wrapper.getBoundingClientRect().width;
                        if (availableWidth > 0 && canvas.offsetWidth !== availableWidth) {
                            canvas.width = availableWidth;
                            canvas.style.width = availableWidth + 'px';
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: false
                    },
                    legend: {
                        display: false
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x',
                            modifierKey: null,
                            threshold: 10
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                                modifierKey: null
                            },
                            drag: {
                                enabled: true,
                                modifierKey: 'shift'
                            },
                            pinch: {
                                enabled: true
                            },
                            mode: 'x',
                            limits: {
                                x: { min: 'original', max: 'original' }
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        type: 'linear',
                        position: 'right',
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Price ($)',
                            padding: {
                                right: 0 // Position title outside
                            }
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toFixed(2);
                            },
                            padding: 2, // Minimal padding to position labels outside
                            maxRotation: 0,
                            autoSkip: false
                        },
                        grid: {
                            drawOnChartArea: true,
                            drawTicks: false, // Don't draw tick marks extending into chart
                            color: 'rgba(200, 200, 200, 0.2)' // Light gray grid for visibility on dark bg
                        }
                    },
                    y1: {
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        grace: 0, // Don't add extra space above max value
                        title: {
                            display: false,
                            text: '',
                            padding: {
                                left: 0
                            }
                        },
                        ticks: {
                            display: false // Hide numeric scale labels
                        },
                        grid: {
                            drawOnChartArea: false // Don't draw grid lines for volume axis
                        }
                    },
                    x: {
                        type: 'linear', // keep x-values as numeric indexes that align with data
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        min: initialMin,
                        max: initialMax,
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45,
                            autoSkip: true,
                            autoSkipPadding: 20,
                            maxTicksLimit: 20,
                            padding: 10,
                            callback: function(value, index, ticks) {
                                // Use the tick's mapped value (data index) to pull the correct timestamp
                                const dataIndex = (ticks && ticks[index] && ticks[index].value != null) ? ticks[index].value : value;
                                const tickDate = timestamps[Math.round(dataIndex)];
                                if (!tickDate) return '';
                                return tickDate.toLocaleTimeString('en-US', { 
                                    hour: '2-digit', 
                                    minute: '2-digit',
                                    hour12: true 
                                });
                            }
                        },
                        grid: {
                            color: 'rgba(200, 200, 200, 0.1)' // Light gray grid on dark bg
                        }
                    }
                }
            };
        }
        
        // Fetch data and render chart
        fetch(`/api/ticker/{{ ticker }}/${interval}`)
            .then(response => response.json())
            .then(data => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('chartWrapper').style.display = 'block';
                document.getElementById('chartControls').style.display = 'block';
                
                // Get canvas and set dimensions before getting context
                const canvas = document.getElementById('stockChart');
                const wrapper = document.getElementById('chartWrapper');
                const chartContainer = wrapper ? wrapper.closest('.chart-container') : null;
                
                // Force container and wrapper to use full available width
                if (chartContainer) {
                    chartContainer.style.width = '100%';
                    chartContainer.style.minWidth = '100%';
                    chartContainer.style.maxWidth = '100%';
                }
                if (wrapper) {
                    wrapper.style.width = '100%';
                    wrapper.style.minWidth = '100%';
                    wrapper.style.maxWidth = '100%';
                }
                
                // Wait a moment for layout to settle, then calculate width
                setTimeout(() => {
                    // Calculate available width - use wrapper's full width
                    let availableWidth = 1400; // Default fallback
                    if (wrapper) {
                        // Force a reflow to get accurate measurements
                        wrapper.offsetHeight;
                        availableWidth = wrapper.offsetWidth || wrapper.clientWidth || wrapper.getBoundingClientRect().width;
                    } else if (chartContainer) {
                        chartContainer.offsetHeight;
                        const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth || chartContainer.getBoundingClientRect().width;
                        availableWidth = containerWidth;
                    }
                    
                    // Ensure minimum width
                    availableWidth = Math.max(availableWidth, 100);
                    
                    // Set canvas dimensions explicitly
                    if (canvas) {
                        canvas.style.width = availableWidth + 'px';
                        canvas.style.height = '700px';
                        canvas.style.display = 'block';
                        canvas.width = availableWidth;
                        canvas.height = 700;
                    }
                }, 50);
                
                // Set initial dimensions for immediate use
                let availableWidth = 1400;
                if (wrapper) {
                    availableWidth = Math.max(wrapper.offsetWidth || wrapper.clientWidth, 1200);
                } else if (chartContainer) {
                    const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth;
                    availableWidth = Math.max(containerWidth - 85, 1200);
                }
                
                // Set canvas dimensions explicitly - both style and attributes
                let ctx;
                if (canvas) {
                    // Set CSS dimensions first
                    canvas.style.width = availableWidth + 'px';
                    canvas.style.height = '700px';
                    canvas.style.display = 'block';
                    // Chart.js will handle device pixel ratio, so just set logical dimensions
                    canvas.width = availableWidth;
                    canvas.height = 700;
                    ctx = canvas.getContext('2d');
                } else {
                    ctx = canvas.getContext('2d');
                }
                
                // Process timestamps
                chartTimestamps = data.labels.map(ts => new Date(ts));
                chartData = data;
                
                // Calculate initial zoom range to show only recent data (last 1 day)
                const totalPoints = data.labels.length;
                
                if (totalPoints > 0) {
                    const pointsPerDay = interval === '1Min' ? 390 : 78;
                    const initialViewPoints = Math.min(pointsPerDay, totalPoints);
                    initialMin = Math.max(0, totalPoints - initialViewPoints);
                    initialMax = totalPoints - 1;
                } else {
                    initialMin = undefined;
                    initialMax = undefined;
                }
                
                // Store timestamps, market hours, and market opens globally for plugin access
                window.chartTimestamps = chartTimestamps;
                window.chartData = data; // Store full chart data for plugins
                window.marketHours = data.market_hours || [];
                window.marketOpens = data.market_opens || [];
                window.vwapData = (data.indicators_ta && data.indicators_ta.vwap) ? data.indicators_ta.vwap : [];
                window.volumeData = data.ohlc ? data.ohlc.map(ohlc => ohlc.volume || 0) : [];
                candleBiasData = data.candle_bias || [];
                patternCounts = data.pattern_counts || {};
                updatePatternDropdown(); // Update dropdown with counts
                
                // Show market hours legend
                const legendElement = document.getElementById('marketHoursLegend');
                if (window.marketHours && window.marketHours.length > 0 && legendElement) {
                    legendElement.style.display = 'flex';
                }
                
                // Create initial candlestick chart (canvas dimensions already set above)
                createCandlestickChart(ctx, chartData, chartTimestamps, interval, initialMin, initialMax);
                renderMacdSubchart();
                
                // Force chart to resize multiple times to ensure it uses full width
                const forceResize = () => {
                    if (window.stockChart && canvas && wrapper) {
                        let availableWidth = 1400;
                        // Use wrapper width directly
                        if (wrapper) {
                            wrapper.offsetHeight; // Force reflow
                            availableWidth = wrapper.offsetWidth || wrapper.clientWidth || wrapper.getBoundingClientRect().width;
                        } else {
                            const chartContainer = wrapper.closest('.chart-container');
                            if (chartContainer) {
                                const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth;
                                availableWidth = containerWidth;
                            }
                        }
                        availableWidth = Math.max(availableWidth, 100);
                        
                        if (availableWidth > 0 && canvas.offsetWidth !== availableWidth) {
                            canvas.width = availableWidth;
                            canvas.height = 700;
                            canvas.style.width = availableWidth + 'px';
                            canvas.style.height = '700px';
                            window.stockChart.resize();
                        }
                    }
                };
                
                // Resize immediately and after delays to catch any layout changes
                forceResize();
                setTimeout(forceResize, 100);
                setTimeout(forceResize, 300);
                setTimeout(forceResize, 500);
                
                // Resize chart on window resize
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (window.stockChart && canvas && wrapper) {
                            let availableWidth = 1400;
                            // Use wrapper width directly
                            if (wrapper) {
                                wrapper.offsetHeight; // Force reflow
                                availableWidth = wrapper.offsetWidth || wrapper.clientWidth || wrapper.getBoundingClientRect().width;
                            } else {
                                const chartContainer = wrapper.closest('.chart-container');
                                if (chartContainer) {
                                    const containerWidth = chartContainer.offsetWidth || chartContainer.clientWidth;
                                    availableWidth = containerWidth;
                                }
                            }
                            availableWidth = Math.max(availableWidth, 100);
                            
                            if (availableWidth > 0) {
                                canvas.width = availableWidth;
                                canvas.height = 700;
                                canvas.style.width = availableWidth + 'px';
                                canvas.style.height = '700px';
                                window.stockChart.resize();
                            }
                        }
                    }, 250);
                });
                
                // Add double-click to reset zoom
                document.getElementById('stockChart').addEventListener('dblclick', function() {
                    window.stockChart.resetZoom();
                });
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                document.getElementById('loading').textContent = 'Error loading chart data. Please try again.';
            });
    </script>
</body>
</html>

